Here’s a tight hand-off to Replit to fix the crash:

Crash
TypeError: Cannot read properties of null (reading 'length')
at DashboardContent (client/src/pages/dashboard.tsx:~435)

Root cause: we’re calling .length on data that can be null | undefined (one of the dashboard queries occasionally returns null—likely products, categories, submissions, or low-stock lists). Fix it in three layers so it can’t happen again: (1) hook-level defaults, (2) component guards, (3) API guarantees.

1) Frontend safety utilities (new)

File: client/src/lib/safe.ts

// Null-safe helpers for lists & counts
export function asArray<T>(v: T[] | ReadonlyArray<T> | null | undefined): T[] {
  return Array.isArray(v) ? [...v] : [];
}
export function count(v: unknown): number {
  return Array.isArray(v) ? v.length : 0;
}
export const isNonEmptyArray = (v: unknown): v is unknown[] =>
  Array.isArray(v) && v.length > 0;

2) Make all admin/dashboard hooks return arrays (never null)
Products

File: client/src/hooks/useProducts.ts (adjust to your actual file)

import { useQuery } from "@tanstack/react-query";
import { apiGet } from "@/lib/api";
import { asArray } from "@/lib/safe";

export function useProducts(params?: { active?: boolean }) {
  return useQuery({
    queryKey: ["products", params],
    queryFn: async () => {
      const data = await apiGet("/api/products", params);
      // normalize here so callers always get an array
      return asArray(data);
    },
    staleTime: 60_000,
  });
}

Categories

File: client/src/hooks/useCategories.ts

import { useQuery } from "@tanstack/react-query";
import { apiGet } from "@/lib/api";
import { asArray } from "@/lib/safe";

export function useCategories(params?: { active?: boolean }) {
  return useQuery({
    queryKey: ["categories", params],
    queryFn: async () => asArray(await apiGet("/api/categories", params)),
    staleTime: 60_000,
  });
}

Any other list hooks used by /admin/dashboard

(eg. useSubmissions, useLowStock, useUsers, etc.) — return asArray(...) the same way.

3) Guard in the Dashboard component (fix near line ~435)

File: client/src/pages/dashboard.tsx

Find where we read counts like products.length, categories.length, etc. Replace with null-safe versions:

import { asArray, count, isNonEmptyArray } from "@/lib/safe";

// ... inside DashboardContent:

const { data: productsData, isLoading: loadingProducts } = useProducts({ active: true });
const { data: categoriesData, isLoading: loadingCategories } = useCategories({ active: true });
// add other queries the same way...

const products   = asArray(productsData);
const categories = asArray(categoriesData);
// others...

// Use `count(...)` everywhere instead of `.length`
const totalProducts = count(products);
const activeCategories = count(categories);

// When rendering tables/cards:
{isNonEmptyArray(products) ? (
  <ProductsTable data={products} />
) : (
  <EmptyState label="No products yet" />
)}


Also ensure any chart data arrays get asArray(...) before computing length or mapping.

4) Ensure API never returns null for arrays (server)

Harden the endpoints the dashboard calls so they return [] on “no data”, not null.

Products (featured)
File: your products route (e.g., server/routes/products.ts or equivalent)

app.get("/api/products/featured", async (req, res) => {
  try {
    const items = await storage.getFeaturedProducts();
    return res.json(Array.isArray(items) ? items : []);
  } catch (e) {
    req.log?.warn({ e }, "[STORAGE] featured failed; returning []");
    return res.json([]); // never null
  }
});


Categories

app.get("/api/categories", async (req, res) => {
  const categories = await storage.getCategories({ active: req.query.active === "true" });
  res.json(Array.isArray(categories) ? categories : []);
});


Do the same for any other list endpoints used by the dashboard.

5) TypeScript + ESLint guardrails (prevents regressions)

tsconfig.json

{
  "compilerOptions": {
    "strictNullChecks": true,
    "noUncheckedIndexedAccess": true
  }
}


.eslintrc.js

module.exports = {
  rules: {
    "no-unsafe-optional-chaining": "error",
    "no-console": ["warn", { allow: ["info","warn","error","debug"] }]
  }
}


This will surface unsafe .length on possibly-null values during dev.

6) ErrorBoundary: show the offender (optional but helpful)

File: client/src/components/ErrorBoundary.tsx
When the error is a TypeError with message including 'length', render a hint that the page tried to read .length on a null list and advise to use asArray()/count(); also log window.__lastDashboardQueryPayloads if you store them (handy when chasing data mismatches).

7) Acceptance checks

Navigating to /admin → Dashboard no longer throws; tiles show 0 when empty.

All table renderers and charts handle empty data gracefully (no .length on null).

API responses for Products/Categories/Featured always return arrays ([]), never null.

TypeScript/ESLint prevent reintroducing unsafe .length reads.

Quick hotfix (if you need a 60-second unblock)

In dashboard.tsx at/near line ~435, change every X.length to count(X) and make sure X is created via asArray(...) first (see step 3). That removes the immediate crash; then complete steps 1–4 to harden the stack.