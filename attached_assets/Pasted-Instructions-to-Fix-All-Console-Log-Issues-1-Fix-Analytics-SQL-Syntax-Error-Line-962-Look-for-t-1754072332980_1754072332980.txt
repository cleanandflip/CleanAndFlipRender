Instructions to Fix All Console Log Issues
1. Fix Analytics SQL Syntax Error (Line 962)
Look for the analytics endpoint around line 962 in server/routes.ts and replace with:
ts// server/routes.ts - Fix analytics endpoint
app.get('/api/admin/analytics', requireAdmin, async (req, res) => {
  try {
    const { range = 'last30days' } = req.query;
    
    // Calculate date range
    const now = new Date();
    const startDate = new Date();
    
    switch (range) {
      case 'today':
        startDate.setHours(0, 0, 0, 0);
        break;
      case 'last7days':
        startDate.setDate(now.getDate() - 7);
        break;
      case 'last30days':
        startDate.setDate(now.getDate() - 30);
        break;
      case 'last90days':
        startDate.setDate(now.getDate() - 90);
        break;
      default:
        startDate.setFullYear(2020); // All time
    }
    
    // Get basic counts - Fixed queries without complex SQL
    const [totalRevenue, totalOrders, totalUsers, totalProducts] = await Promise.all([
      // Total revenue
      db.select({ sum: sum(orders.total) })
        .from(orders)
        .where(and(
          eq(orders.status, 'completed'),
          gte(orders.createdAt, startDate)
        )),
      
      // Total orders
      db.select({ count: count() })
        .from(orders)
        .where(gte(orders.createdAt, startDate)),
      
      // Total users
      db.select({ count: count() })
        .from(users),
      
      // Total products
      db.select({ count: count() })
        .from(products)
    ]);
    
    // Get orders for chart data
    const ordersForChart = await db.select({
      createdAt: orders.createdAt,
      total: orders.total
    })
    .from(orders)
    .where(and(
      eq(orders.status, 'completed'),
      gte(orders.createdAt, startDate)
    ))
    .orderBy(desc(orders.createdAt));
    
    // Group orders by date in JavaScript
    const chartData = {};
    ordersForChart.forEach(order => {
      const date = new Date(order.createdAt).toISOString().split('T')[0];
      if (!chartData[date]) {
        chartData[date] = { date, count: 0, amount: 0 };
      }
      chartData[date].count++;
      chartData[date].amount += Number(order.total || 0);
    });
    
    // Get top products - simplified query
    const topProductsData = await db.select({
      productId: orderItems.productId,
      productName: products.name,
      count: count()
    })
    .from(orderItems)
    .leftJoin(products, eq(orderItems.productId, products.id))
    .groupBy(orderItems.productId, products.name)
    .orderBy(desc(count()))
    .limit(5);
    
    res.json({
      revenue: {
        total: Number(totalRevenue[0]?.sum || 0),
        change: 0
      },
      orders: {
        total: totalOrders[0]?.count || 0,
        avgValue: totalOrders[0]?.count ? 
          Number(totalRevenue[0]?.sum || 0) / Number(totalOrders[0]?.count) : 0,
        change: 0
      },
      users: {
        total: totalUsers[0]?.count || 0,
        change: 0
      },
      products: {
        total: totalProducts[0]?.count || 0,
        change: 0
      },
      conversion: {
        rate: 0,
        change: 0
      },
      charts: {
        revenue: Object.values(chartData).sort((a, b) => 
          new Date(a.date).getTime() - new Date(b.date).getTime()
        )
      },
      topProducts: topProductsData.map(p => ({
        id: p.productId,
        name: p.productName || 'Unknown',
        soldCount: Number(p.count),
        revenue: 0
      })),
      traffic: {
        sources: []
      },
      recentActivity: []
    });
    
  } catch (error) {
    console.error('[ERROR] Error fetching analytics', error);
    res.status(500).json({ error: 'Failed to fetch analytics' });
  }
});
2. Fix Users SQL Syntax Error (Line 899)
Look for the users endpoint around line 899 and replace with:
ts// server/routes.ts - Fix users endpoint
app.get('/api/admin/users', requireAdmin, async (req, res) => {
  try {
    const { 
      search = '', 
      role = 'all', 
      status = 'all',
      sortBy = 'created', 
      sortOrder = 'desc', 
      page = 1, 
      limit = 20 
    } = req.query;
    
    // Build conditions
    const conditions = [];
    
    if (search) {
      conditions.push(
        or(
          ilike(users.email, `%${search}%`),
          ilike(users.firstName, `%${search}%`),
          ilike(users.lastName, `%${search}%`)
        )
      );
    }
    
    if (role !== 'all') {
      conditions.push(eq(users.role, role));
    }
    
    // Get users without complex subqueries
    const usersQuery = db.select()
      .from(users)
      .where(conditions.length > 0 ? and(...conditions) : undefined)
      .limit(Number(limit))
      .offset((Number(page) - 1) * Number(limit));
    
    // Apply sorting
    switch (sortBy) {
      case 'created':
        usersQuery.orderBy(sortOrder === 'desc' ? desc(users.createdAt) : asc(users.createdAt));
        break;
      case 'name':
        usersQuery.orderBy(sortOrder === 'desc' ? desc(users.firstName) : asc(users.firstName));
        break;
      case 'email':
        usersQuery.orderBy(sortOrder === 'desc' ? desc(users.email) : asc(users.email));
        break;
      default:
        usersQuery.orderBy(desc(users.createdAt));
    }
    
    const usersList = await usersQuery;
    
    // Get stats for each user separately
    const usersWithStats = await Promise.all(
      usersList.map(async (user) => {
        try {
          // Get order count for this user
          const orderCountResult = await db
            .select({ count: count() })
            .from(orders)
            .where(eq(orders.userId, user.id));
          
          // Get total spent for this user
          const totalSpentResult = await db
            .select({ total: sum(orders.total) })
            .from(orders)
            .where(and(
              eq(orders.userId, user.id),
              eq(orders.status, 'completed')
            ));
          
          return {
            ...user,
            orderCount: orderCountResult[0]?.count || 0,
            totalSpent: Number(totalSpentResult[0]?.total || 0)
          };
        } catch (error) {
          console.error(`Error fetching stats for user ${user.id}:`, error);
          return {
            ...user,
            orderCount: 0,
            totalSpent: 0
          };
        }
      })
    );
    
    // Get total count for pagination
    const totalUsersResult = await db
      .select({ count: count() })
      .from(users)
      .where(conditions.length > 0 ? and(...conditions) : undefined);
    
    res.json({
      users: usersWithStats,
      total: totalUsersResult[0]?.count || 0,
      page: Number(page),
      totalPages: Math.ceil((totalUsersResult[0]?.count || 0) / Number(limit))
    });
    
  } catch (error) {
    console.error('[ERROR] Error fetching users', error);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});
3. Fix Any Other SQL Issues
Create a utility file for safe SQL operations:
ts// server/utils/dbHelpers.ts

import { sql } from 'drizzle-orm';

// Safe aggregation functions that handle NULL values
export const safeSum = (column: any) => {
  return sql<number>`COALESCE(SUM(${column}), 0)::numeric`;
};

export const safeCount = (column?: any) => {
  if (column) {
    return sql<number>`COALESCE(COUNT(${column}), 0)::integer`;
  }
  return sql<number>`COUNT(*)::integer`;
};

export const safeAvg = (column: any) => {
  return sql<number>`COALESCE(AVG(${column}), 0)::numeric`;
};

// Date formatting helper
export const formatDate = (column: any) => {
  return sql<string>`TO_CHAR(${column}, 'YYYY-MM-DD')`;
};
4. Add Query Debugging
Add this helper to debug problematic queries:
ts// server/utils/queryDebug.ts

export const debugQuery = (queryName: string) => {
  return {
    before: () => console.log(`[QUERY START] ${queryName}`),
    after: (result: any) => console.log(`[QUERY END] ${queryName} - Rows: ${result?.length || 0}`),
    error: (error: any) => console.error(`[QUERY ERROR] ${queryName}:`, error.message)
  };
};

// Usage example:
const debug = debugQuery('Get Users');
try {
  debug.before();
  const result = await db.select().from(users);
  debug.after(result);
  return result;
} catch (error) {
  debug.error(error);
  throw error;
}
5. Fix Slow Request Warning
Add request timeout handling:
ts// server/middleware/performance.ts

export const performanceMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const start = Date.now();
  
  // Set a timeout for slow requests
  const slowRequestThreshold = 2000; // 2 seconds
  const timeoutId = setTimeout(() => {
    console.warn(`[SLOW REQUEST] ${req.method} ${req.path} is taking over ${slowRequestThreshold}ms`);
  }, slowRequestThreshold);
  
  // Override res.end to calculate duration
  const originalEnd = res.end;
  res.end = function(...args: any[]) {
    clearTimeout(timeoutId);
    const duration = Date.now() - start;
    
    if (duration > slowRequestThreshold) {
      console.warn(`[SLOW REQUEST] ${req.method} ${req.path} took ${duration}ms`);
    }
    
    originalEnd.apply(res, args);
  };
  
  next();
};
6. Clean Up Error Logging
Create a centralized error handler:
ts// server/utils/errorHandler.ts

export const handleDatabaseError = (error: any, operation: string) => {
  // PostgreSQL error codes
  const errorMessages: Record<string, string> = {
    '23505': 'Duplicate entry',
    '23503': 'Foreign key violation',
    '42601': 'SQL syntax error',
    '42703': 'Column does not exist',
    '42P01': 'Table does not exist'
  };
  
  const message = errorMessages[error.code] || 'Database error';
  console.error(`[DB ERROR - ${operation}] ${message}:`, {
    code: error.code,
    detail: error.detail,
    position: error.position
  });
  
  return {
    error: message,
    code: error.code
  };
};
7. Update All Endpoints to Use Fixed Patterns
Apply this pattern to all problematic endpoints:
ts// Template for safe endpoint
app.get('/api/admin/endpoint', requireAdmin, async (req, res) => {
  try {
    // 1. Parse and validate parameters
    const params = validateParams(req.query);
    
    // 2. Build simple queries without complex SQL
    const data = await db.select().from(table);
    
    // 3. Process data in JavaScript instead of SQL
    const processed = processData(data);
    
    // 4. Return consistent response
    res.json({
      success: true,
      data: processed,
      total: data.length
    });
    
  } catch (error) {
    // 5. Handle errors consistently
    const dbError = handleDatabaseError(error, 'endpoint name');
    res.status(500).json(dbError);
  }
});
Instructions for Replit:

First Priority - Fix the two main errors:

Replace the analytics endpoint (line ~962)
Replace the users endpoint (line ~899)


Test immediately after fixing:
bash# Test analytics
curl http://localhost:5000/api/admin/analytics

# Test users
curl http://localhost:5000/api/admin/users

If errors persist, check for:

Raw SQL template usage (sql\...``)
Complex subqueries in select statements
Missing imports for sql functions


Common fixes:

Replace sql\COUNT(*) AS count`with justcount()`
Replace sql\SUM(column) AS total`withsum(column)`
Move complex logic from SQL to JavaScript


Monitor the console for any remaining errors and apply the same pattern to fix them.

The key is to simplify the SQL queries and handle complex logic in JavaScript rather than in the database queries