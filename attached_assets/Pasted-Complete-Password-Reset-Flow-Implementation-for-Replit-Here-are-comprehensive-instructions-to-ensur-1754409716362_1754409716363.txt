Complete Password Reset Flow Implementation for Replit
Here are comprehensive instructions to ensure the password reset link properly redirects users to cleanandflip.com:

REPLIT: IMPLEMENT COMPLETE PASSWORD RESET FLOW
1. Backend: Generate Proper Reset Links
Update /server/services/password-reset.service.ts:
typescriptimport crypto from 'crypto';
import bcrypt from 'bcrypt';
import { db } from '../db';
import { users, passwordResetTokens } from '../db/schema';
import { emailService } from './email.service';
import { eq, and, gt } from 'drizzle-orm';

export class PasswordResetService {
  private static readonly TOKEN_LENGTH = 32;
  private static readonly TOKEN_EXPIRY_HOURS = 1;

  static async requestPasswordReset(
    email: string, 
    ipAddress: string, 
    userAgent: string
  ) {
    try {
      // Find user
      const [user] = await db
        .select()
        .from(users)
        .where(eq(users.email, email.toLowerCase()))
        .limit(1);

      // Always return success (prevent email enumeration)
      if (!user) {
        console.log('Password reset requested for non-existent email:', email);
        return { success: true, message: 'If an account exists, reset email sent' };
      }

      // Cancel any existing unused tokens for this user
      await db
        .update(passwordResetTokens)
        .set({ used: true })
        .where(
          and(
            eq(passwordResetTokens.userId, user.id),
            eq(passwordResetTokens.used, false)
          )
        );

      // Generate secure token (URL-safe)
      const rawToken = crypto.randomBytes(this.TOKEN_LENGTH).toString('hex');
      
      // Hash token for database storage (security)
      const hashedToken = await bcrypt.hash(rawToken, 10);
      
      // Set expiration
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + this.TOKEN_EXPIRY_HOURS);

      // Save hashed token to database
      await db.insert(passwordResetTokens).values({
        userId: user.id,
        token: hashedToken, // Store hashed version
        expiresAt,
        ipAddress,
        userAgent,
        used: false
      });

      // Create reset link with raw token
      // IMPORTANT: Use the production URL
      const baseUrl = process.env.NODE_ENV === 'production' 
        ? 'https://cleanandflip.com'
        : process.env.FRONTEND_URL || 'http://localhost:5173';
        
      const resetLink = `${baseUrl}/reset-password?token=${rawToken}&email=${encodeURIComponent(user.email)}`;

      console.log('Generated reset link:', resetLink);

      // Send email with reset link
      await emailService.sendPasswordResetEmail({
        to: user.email,
        userName: user.name || 'Customer',
        resetLink,
        ipAddress,
        userAgent,
        expiresIn: '1 hour'
      });

      return { 
        success: true, 
        message: 'If an account exists, reset email sent' 
      };
    } catch (error) {
      console.error('Password reset error:', error);
      throw error;
    }
  }

  static async validateResetToken(token: string, email?: string) {
    try {
      const now = new Date();

      // Get all valid tokens
      let query = db
        .select({
          id: passwordResetTokens.id,
          userId: passwordResetTokens.userId,
          token: passwordResetTokens.token,
          expiresAt: passwordResetTokens.expiresAt,
          used: passwordResetTokens.used
        })
        .from(passwordResetTokens)
        .where(
          and(
            eq(passwordResetTokens.used, false),
            gt(passwordResetTokens.expiresAt, now)
          )
        );

      const tokens = await query;

      // Check each token (bcrypt compare)
      for (const resetToken of tokens) {
        const isValid = await bcrypt.compare(token, resetToken.token);
        
        if (isValid) {
          // Get user details
          const [user] = await db
            .select({
              id: users.id,
              email: users.email,
              name: users.name
            })
            .from(users)
            .where(eq(users.id, resetToken.userId))
            .limit(1);

          // Verify email matches if provided
          if (email && user.email !== email.toLowerCase()) {
            return { valid: false, error: 'Invalid token or email combination' };
          }

          return {
            valid: true,
            tokenId: resetToken.id,
            userId: user.id,
            email: user.email,
            expiresAt: resetToken.expiresAt
          };
        }
      }

      return { valid: false, error: 'Invalid or expired token' };
    } catch (error) {
      console.error('Token validation error:', error);
      return { valid: false, error: 'Token validation failed' };
    }
  }

  static async resetPassword(
    token: string,
    newPassword: string,
    email: string,
    ipAddress: string
  ) {
    try {
      // Validate token with email
      const validation = await this.validateResetToken(token, email);
      
      if (!validation.valid) {
        throw new Error(validation.error || 'Invalid or expired reset token');
      }

      // Hash new password
      const hashedPassword = await bcrypt.hash(newPassword, 12);

      // Update user password
      await db
        .update(users)
        .set({
          password: hashedPassword,
          updatedAt: new Date()
        })
        .where(eq(users.id, validation.userId));

      // Mark token as used
      await db
        .update(passwordResetTokens)
        .set({
          used: true,
          usedAt: new Date()
        })
        .where(eq(passwordResetTokens.id, validation.tokenId));

      // Send confirmation email
      await emailService.sendPasswordResetSuccessEmail({
        to: validation.email,
        ipAddress,
        timestamp: new Date().toISOString()
      });

      return { success: true, message: 'Password successfully reset' };
    } catch (error) {
      console.error('Password reset error:', error);
      throw error;
    }
  }
}
2. Backend: API Routes
Update /server/routes/auth.ts:
typescriptimport express from 'express';
import { PasswordResetService } from '../services/password-reset.service';

const router = express.Router();

// Request password reset
router.post('/api/auth/forgot-password', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ error: 'Email is required' });
    }

    const ipAddress = req.ip || req.connection.remoteAddress || 'unknown';
    const userAgent = req.headers['user-agent'] || 'unknown';

    const result = await PasswordResetService.requestPasswordReset(
      email,
      ipAddress,
      userAgent
    );

    res.json(result);
  } catch (error) {
    console.error('Forgot password error:', error);
    // Always return success to prevent email enumeration
    res.json({ success: true, message: 'If an account exists, reset email sent' });
  }
});

// Validate reset token
router.post('/api/auth/validate-reset-token', async (req, res) => {
  try {
    const { token, email } = req.body;
    
    if (!token) {
      return res.status(400).json({ valid: false, error: 'Token is required' });
    }

    const result = await PasswordResetService.validateResetToken(token, email);
    res.json(result);
  } catch (error) {
    console.error('Token validation error:', error);
    res.json({ valid: false, error: 'Token validation failed' });
  }
});

// Reset password
router.post('/api/auth/reset-password', async (req, res) => {
  try {
    const { token, email, password } = req.body;
    
    // Validation
    if (!token || !email || !password) {
      return res.status(400).json({ 
        success: false, 
        error: 'Token, email, and password are required' 
      });
    }

    if (password.length < 8) {
      return res.status(400).json({ 
        success: false, 
        error: 'Password must be at least 8 characters' 
      });
    }

    const ipAddress = req.ip || req.connection.remoteAddress || 'unknown';
    
    const result = await PasswordResetService.resetPassword(
      token,
      password,
      email,
      ipAddress
    );

    res.json(result);
  } catch (error) {
    console.error('Password reset error:', error);
    res.status(400).json({ 
      success: false, 
      error: error.message || 'Password reset failed' 
    });
  }
});

export default router;
3. Frontend: Reset Password Page
Create /client/src/pages/ResetPassword.tsx:
typescriptimport { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Link, useLocation } from 'wouter';
import { Loader2, CheckCircle, XCircle } from 'lucide-react';

const resetPasswordSchema = z.object({
  password: z.string().min(8, 'Password must be at least 8 characters'),
  confirmPassword: z.string()
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ['confirmPassword']
});

type ResetPasswordForm = z.infer<typeof resetPasswordSchema>;

export function ResetPassword() {
  const [, setLocation] = useLocation();
  const [isLoading, setIsLoading] = useState(false);
  const [isValidating, setIsValidating] = useState(true);
  const [isSuccess, setIsSuccess] = useState(false);
  const [tokenValid, setTokenValid] = useState<boolean | null>(null);
  const [error, setError] = useState<string | null>(null);
  
  // Extract token and email from URL
  const urlParams = new URLSearchParams(window.location.search);
  const token = urlParams.get('token');
  const email = urlParams.get('email');

  const form = useForm<ResetPasswordForm>({
    resolver: zodResolver(resetPasswordSchema)
  });

  // Validate token on mount
  useEffect(() => {
    validateToken();
  }, []);

  const validateToken = async () => {
    if (!token || !email) {
      setTokenValid(false);
      setError('Invalid reset link. Missing token or email.');
      setIsValidating(false);
      return;
    }

    try {
      const response = await fetch('/api/auth/validate-reset-token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token, email })
      });

      const data = await response.json();
      setTokenValid(data.valid);
      
      if (!data.valid) {
        setError(data.error || 'This reset link is invalid or has expired.');
      }
    } catch (err) {
      setTokenValid(false);
      setError('Unable to validate reset link. Please try again.');
    } finally {
      setIsValidating(false);
    }
  };

  const onSubmit = async (data: ResetPasswordForm) => {
    if (!token || !email) return;
    
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/auth/reset-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          token,
          email,
          password: data.password
        })
      });

      const result = await response.json();

      if (result.success) {
        setIsSuccess(true);
        // Redirect to login after 3 seconds
        setTimeout(() => {
          setLocation('/login?reset=success');
        }, 3000);
      } else {
        setError(result.error || 'Failed to reset password. Please try again.');
      }
    } catch (err) {
      setError('An error occurred. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  // Loading state
  if (isValidating) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <Card className="w-full max-w-md">
          <CardContent className="pt-6">
            <div className="flex flex-col items-center space-y-4">
              <Loader2 className="h-8 w-8 animate-spin text-gray-500" />
              <p className="text-gray-600">Validating reset link...</p>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  // Invalid token
  if (tokenValid === false) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
        <Card className="w-full max-w-md">
          <CardHeader>
            <div className="flex items-center space-x-2">
              <XCircle className="h-6 w-6 text-red-500" />
              <CardTitle>Invalid Reset Link</CardTitle>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            <Alert variant="destructive">
              <AlertDescription>
                {error || 'This password reset link is invalid or has expired.'}
              </AlertDescription>
            </Alert>
            <p className="text-sm text-gray-600">
              Password reset links expire after 1 hour for security reasons.
              Please request a new reset link.
            </p>
            <div className="space-y-2">
              <Link href="/forgot-password">
                <Button className="w-full">Request New Reset Link</Button>
              </Link>
              <Link href="/login">
                <Button variant="outline" className="w-full">Back to Login</Button>
              </Link>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  // Success state
  if (isSuccess) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
        <Card className="w-full max-w-md">
          <CardHeader>
            <div className="flex items-center space-x-2">
              <CheckCircle className="h-6 w-6 text-green-500" />
              <CardTitle>Password Reset Successful!</CardTitle>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-gray-600">
              Your password has been successfully reset. You will be redirected to the login page in a few seconds.
            </p>
            <Link href="/login">
              <Button className="w-full">Go to Login Now</Button>
            </Link>
          </CardContent>
        </Card>
      </div>
    );
  }

  // Reset form
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>Reset Your Password</CardTitle>
          <CardDescription>
            Enter your new password below. Make sure it's at least 8 characters long.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <div className="space-y-2">
              <label htmlFor="password" className="text-sm font-medium">
                New Password
              </label>
              <Input
                {...form.register('password')}
                id="password"
                type="password"
                placeholder="Enter new password"
                disabled={isLoading}
              />
              {form.formState.errors.password && (
                <p className="text-sm text-red-500">
                  {form.formState.errors.password.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <label htmlFor="confirmPassword" className="text-sm font-medium">
                Confirm Password
              </label>
              <Input
                {...form.register('confirmPassword')}
                id="confirmPassword"
                type="password"
                placeholder="Confirm new password"
                disabled={isLoading}
              />
              {form.formState.errors.confirmPassword && (
                <p className="text-sm text-red-500">
                  {form.formState.errors.confirmPassword.message}
                </p>
              )}
            </div>

            {error && (
              <Alert variant="destructive">
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}

            <Button 
              type="submit" 
              className="w-full" 
              disabled={isLoading}
            >
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Resetting Password...
                </>
              ) : (
                'Reset Password'
              )}
            </Button>

            <div className="text-center text-sm">
              <Link href="/login" className="text-gray-600 hover:text-black">
                Back to Login
              </Link>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}
4. Frontend: Add Route
Update /client/src/App.tsx or your router file:
typescriptimport { Route, Switch } from 'wouter';
import { ResetPassword } from './pages/ResetPassword';
import { ForgotPassword } from './pages/ForgotPassword';

function App() {
  return (
    <Switch>
      {/* Other routes */}
      <Route path="/forgot-password" component={ForgotPassword} />
      <Route path="/reset-password" component={ResetPassword} />
      {/* Other routes */}
    </Switch>
  );
}
5. Email Template Update
Ensure the email template has the correct link format:
typescript// In /server/emails/password-reset.tsx
export const PasswordResetEmail = ({ resetLink, userName, expiresIn }) => {
  return (
    <Html>
      {/* ... */}
      <Text>Click the button below to reset your password:</Text>
      
      <Button href={resetLink} style={buttonStyles}>
        Reset Password
      </Button>
      
      <Text style={{ fontSize: '12px', color: '#666' }}>
        Or copy this link: {resetLink}
      </Text>
      
      <Text style={{ fontSize: '12px', color: '#666' }}>
        This link will expire in {expiresIn} and can only be used once.
      </Text>
      {/* ... */}
    </Html>
  );
};
6. Security Checklist
Ensure these security measures are in place:

✅ Tokens are hashed before storing in database
✅ Tokens expire after 1 hour
✅ Tokens can only be used once
✅ Email verification required with token
✅ Rate limiting on password reset requests
✅ Generic success messages to prevent email enumeration
✅ Old tokens are invalidated when new one is requested
✅ Confirmation email sent after successful reset
✅ IP address and user agent logging for security audit

7. Testing Protocol
Test the complete flow:

Go to /forgot-password
Enter email address
Check email for reset link
Click link - should go to https://cleanandflip.com/reset-password?token=xxx&email=xxx
Enter new password
Confirm successful reset
Try logging in with new password

This complete implementation ensures users can safely reset their passwords while staying on cleanandflip.com throughout the entire process