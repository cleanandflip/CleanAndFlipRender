comprehensive ‚Äútear-down & rebuild‚Äù instruction set for Replit that (1) purges all legacy address code and data, (2) rebuilds the address/onboarding system with one source of truth in the DB, (3) keeps Geoapify for search with proper rate-limits/caching, (4) enforces bulletproof LOCAL customer rules end-to-end, and (5) fixes the validation and UX issues you‚Äôve hit.

üî• Phase 0 ‚Äî Hard reset (code + data)
0.1 Delete legacy/duplicate code (no stubs left).

Remove these files/blocks entirely (commit shows deletions, not ‚Äúunused‚Äù):

server/routes.ts ‚Äî delete all address endpoints/handlers (lines 2269‚Äì2316 and any other /api/addresses logic).

server/storage.ts ‚Äî remove getUserAddresses() and any address-related helpers.

server/data/addressRepo.ts ‚Äî delete file (we‚Äôll unify repos).

client/src/pages/checkout_broken.tsx ‚Äî delete.

Any old components named like AddressFormOld, AddressModalOld, or *Legacy*.

Any client code that fetches addresses except through client/src/api/addresses.ts (will be rewritten below).

Remove ‚ÄúSMS notifications‚Äù UI and logic everywhere (onboarding step and any toggles).

Search & nuke (case-insensitive): addressRepo, getUserAddresses, /api/addresses in routes.ts, checkout_broken, SMS notifications, smsOptIn.

0.2 DB wipe (users + addresses + carts) for clean testing.

Only in development. Guard with if (process.env.NODE_ENV !== 'production') throw.

Run SQL (psql / Drizzle migration):

sql
Copy
Edit
-- Safety: dev only!
TRUNCATE TABLE carts RESTART IDENTITY CASCADE;
TRUNCATE TABLE cart_items RESTART IDENTITY CASCADE;
TRUNCATE TABLE addresses RESTART IDENTITY CASCADE;
TRUNCATE TABLE users RESTART IDENTITY CASCADE;
TRUNCATE TABLE sessions RESTART IDENTITY CASCADE;
üß± Phase 1 ‚Äî Database: single source of truth (SSOT)
1.1 Schema (Drizzle + SQL).
SSOT = the addresses table. All UI reads the default address via /api/addresses?default=true. The users.profile_address_id is a pointer (denormalized convenience) and must always mirror the default address.

sql
Copy
Edit
-- users (add columns if missing)
ALTER TABLE users
  ADD COLUMN IF NOT EXISTS profile_address_id uuid,
  ADD COLUMN IF NOT EXISTS is_local_customer boolean DEFAULT false;

-- addresses (drop columns that don‚Äôt match; then ensure canonical)
CREATE TABLE IF NOT EXISTS addresses (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  first_name text NOT NULL,
  last_name  text NOT NULL,
  street1    text NOT NULL,
  street2    text,
  city       text NOT NULL,
  state      text NOT NULL,
  postal_code text NOT NULL,
  country     text NOT NULL DEFAULT 'US',
  latitude   numeric(10,7),
  longitude  numeric(10,7),
  geoapify_place_id text,
  is_default boolean NOT NULL DEFAULT false,
  is_local   boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- One default address per user.
CREATE UNIQUE INDEX IF NOT EXISTS addresses_one_default_per_user
  ON addresses(user_id) WHERE is_default = true;

-- Useful indexes
CREATE INDEX IF NOT EXISTS idx_addresses_user ON addresses(user_id);
CREATE INDEX IF NOT EXISTS idx_addresses_postal ON addresses(postal_code);

-- Keep users.profile_address_id in sync with default
CREATE OR REPLACE FUNCTION sync_user_profile_address() RETURNS trigger AS $$
BEGIN
  IF NEW.is_default THEN
    UPDATE users SET profile_address_id = NEW.id WHERE id = NEW.user_id;
  ELSIF OLD.is_default = true AND NEW.is_default = false THEN
    -- If default turned off, pick newest as default (or leave null)
    UPDATE users u SET profile_address_id = (
      SELECT id FROM addresses a WHERE a.user_id = u.id ORDER BY a.created_at DESC LIMIT 1
    ) WHERE u.id = NEW.user_id;
  END IF;
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_profile_address ON addresses;
CREATE TRIGGER trg_sync_profile_address
AFTER INSERT OR UPDATE ON addresses
FOR EACH ROW EXECUTE FUNCTION sync_user_profile_address();
1.2 ‚ÄúLocal customer‚Äù computation.

We‚Äôll trust server-side computation and store the boolean. Use a service area env:

ini
Copy
Edit
LOCAL_CENTER_LAT=35.5951
LOCAL_CENTER_LNG=-82.5515
LOCAL_RADIUS_KM=40
On address save/update: compute haversine distance; set addresses.is_local and also users.is_local_customer = any default address local.

üõ†Ô∏è Phase 2 ‚Äî Server API (new, clean, validated)
2.1 Shared types & validators.

Create server/validators/address.ts:

ts
Copy
Edit
import { z } from "zod";

export const AddressInput = z.object({
  firstName: z.string().min(1),
  lastName: z.string().min(1),
  street1: z.string().min(1),
  street2: z.string().optional().nullable(),
  city: z.string().min(1),
  state: z.string().length(2),
  postalCode: z.string().min(5).max(10),
  country: z.string().default("US"),
  latitude: z.number().optional(),
  longitude: z.number().optional(),
  geoapifyPlaceId: z.string().optional(),
  isDefault: z.boolean().optional(), // default false
});
export type AddressInput = z.infer<typeof AddressInput>;
Why: Your logs show Zod receiving undefined for firstName, lastName, street1, postalCode. This enforces naming consistency across all clients.

2.2 Address controller (SSOT).
Create server/controllers/addressController.ts ‚Äî the only server module that touches addresses.

Endpoints in server/routes/addresses.ts:

GET /api/addresses ‚Üí list (option ?default=true)

POST /api/addresses ‚Üí create (validate with AddressInput)

PUT /api/addresses/:id ‚Üí full update

PATCH /api/addresses/:id/default ‚Üí set default (wrap in tx: unset others)

DELETE /api/addresses/:id ‚Üí remove (if deleting default: auto-promote newest, sync trigger covers it)

All endpoints:

requireAuth

return 400 on validation (never 500 for Zod)

recompute is_local and set users.is_local_customer if is_default=true

2.3 User endpoint.

GET /api/user must include:

json
Copy
Edit
{
  "id": "...",
  "email": "...",
  "isLocalCustomer": true|false,
  "profileAddress": { /* normalized address object or null */ }
}
2.4 Geoapify proxy with protection.

GET /api/geocode/autocomplete?text=...

Debounce on client (300‚Äì400ms).

Server rate-limit per IP (e.g., 5 req / 5s).

LRU cache (Redis preferred; fallback in-memory Map with TTL=10m).

When 429 from Geoapify ‚Üí return 200 with { results: [] , exhausted: true } so UI gracefully allows manual entry.

Map Geoapify fields ‚Üí our canonical fields (street1/city/state/postalCode/country/lat/lng/placeId).

2.5 Cart & product enforcement (LOCAL logic).

Add products.is_local_only boolean NOT NULL DEFAULT false.

When adding to cart (POST /api/cart/items) server checks:

if product.is_local_only then users.is_local_customer === true, else 400 with user-actionable message.

At checkout, verify that all items comply and that a default address exists.

For local-only purchases: set shipping cost $0 and show ‚ÄúFree local delivery within 48 hours.‚Äù

üß© Phase 3 ‚Äî Client rebuild (one address module to rule them all)
3.1 Shared client types.
client/src/types/address.ts mirrors server names exactly.

3.2 Central API client.
Rewrite client/src/api/addresses.ts:

ts
Copy
Edit
export async function listAddresses(opts?: { defaultOnly?: boolean }) { ... }
export async function createAddress(payload: AddressInput) { ... }
export async function updateAddress(id: string, payload: AddressInput) { ... }
export async function setDefaultAddress(id: string) { ... }
export async function deleteAddress(id: string) { ... }
export async function fetchUser() { ... } // includes profileAddress, isLocalCustomer
No other code fetches addresses directly. Everything goes through this module.

3.3 Address state (client).
Create client/src/state/addressStore.ts (Zustand or React Query with cache key ["address", "default"]):

getDefaultAddress() ‚Üí uses listAddresses({ defaultOnly: true })

invalidateAddresses() utility

Never duplicate state across pages; they all read from this store / React Query.

3.4 Components.

AddressAutocomplete (keep Geoapify, add debounce, disabled when exhausted: true, show ‚ÄúAPI limit reached ‚Äî please type manually‚Äù).

AddressForm (single component used in all places):

react-hook-form + Zod resolver (uses AddressInput).

Emits AddressInput only; caller decides create vs update.

When used in onboarding ‚Üí createAddress({ ..., isDefault: true }).

When used in checkout ‚Üí prefill from default; allow ‚ÄúUse a different address‚Äù which opens modal that reuses this same component.

Visual fixes: thicker borders/contrast for inputs as requested earlier, and error messages per field.

3.5 Pages (where address appears).

/dashboard?tab=addresses

Shows list of addresses, badges ‚ÄúDefault‚Äù & ‚ÄúLocal ‚úÖ/‚ùå‚Äù, actions: Set Default / Edit / Delete.

‚ÄúAdd Address‚Äù opens AddressForm.

/onboarding

Step 1: Address (remove SMS option entirely). Required. On submit ‚Üí create default address; proceed.

Step 2: Contact phone ‚Äî validate with libphonenumber-js (US default), allow only E.164 or 10 digits; block letters/single digits; format as (555) 555-5555.

Step 3: Summary (no SMS checkbox). ‚ÄúComplete Setup‚Äù calls /api/user/complete-onboarding and navigates back.

If onboarding opened ?from=cart, on finish route back to /cart or /checkout.

/checkout (Shipping step)

Prefill with default address (read-only summary).

Link: ‚ÄúUse a different address‚Äù ‚Üí Address modal (uses same AddressForm), on save set as default and refresh.

If cart contains any is_local_only item and user is not local ‚Üí block with actionable message + link to update address.

Show ‚ÄúFree local delivery within 48 hours‚Äù when isLocalCustomer && cartHasLocalOnly.

3.6 Remove SMS UI & routes.
Delete SMS checkbox and any smsOptIn state, server fields, or validators.

üßØ Phase 4 ‚Äî Validation & error handling polish
Client: disallow advancing onboarding Step 2 unless phone is valid (libphonenumber-js); show inline error.

Server: return { fieldErrors } shape on 400 (Zod flatten()), never 500 for bad input.

Geoapify 429: do not throw 500; respond with exhausted: true.

All forms: disable submit while pending; show toast success/failure.

üöß Phase 5 ‚Äî Product & cart rules (LOCAL only)
Product model: is_local_only flag exposed to client.

PDP, PLP cards: badge ‚ÄúLOCAL ONLY‚Äù.

Add-to-cart button: if is_local_only && !user.isLocalCustomer ‚Üí disabled with tooltip ‚ÄúLocal pickup/delivery only. Update your address to qualify.‚Äù

Server add-to-cart also enforces (defense-in-depth).

Checkout shipping: if any local-only items ‚Üí shipping = $0, show banner ‚ÄúFree local delivery within 48 hours.‚Äù

üß™ Phase 6 ‚Äî Testing plan (clean slate ‚Üí e2e)
6.1 Seed test accounts (dev only).

seed:users script creates:

Email/password user A (Asheville local address).

Email/password user B (non-local address).

Google user C (simulate via our Google callback handler with a stubbed profile; or use real if available).

Each gets one default address via API.

6.2 Playwright e2e (write now):

Onboarding (email sign-up): fills Step 1 with a valid address (Geoapify suggestion & manual fallback), Step 2 with valid phone, completes; assert GET /api/user includes profileAddress and isLocalCustomer as expected.

Onboarding loop bug: After completing, revisit /onboarding with ?required=true should redirect away (no restart).

Dashboard addresses: Add ‚Üí Set default ‚Üí Edit ‚Üí Delete flows; list reflects changes; default unique invariant holds.

Checkout:

Local user + local-only product ‚Üí allowed; shows free delivery banner.

Non-local user + local-only product ‚Üí blocked client-side and server-side.

Non-local product ‚Üí allowed for all users.

Validation: Try to submit Step 2 with a or 1 ‚Üí blocked with error.

Geoapify 429: mock 429 ‚Üí UI shows ‚ÄúAPI limit reached‚Ä¶‚Äù and allows manual entry ‚Üí successful save.

üìà Observability & UX
Server logs: downgrade Zod errors to warn with clear fieldErrors payload; stop logging as 500.

Add metrics counters: address.create, address.setDefault, geoapify.429, cart.blocked.localOnly.

Sentry (or your error collector): breadcrumb POST body keys (not values) for address saves, no PII.

üßπ Definition of Done (checklist)
 All legacy address code deleted; only server/routes/addresses.ts + server/controllers/addressController.ts handle addresses.

 DB constraint enforces single default per user.

 GET /api/user returns profileAddress + isLocalCustomer.

 Onboarding saves default address and doesn‚Äôt loop.

 Phone step validates with libphonenumber-js; SMS UI removed everywhere.

 Geoapify endpoint rate-limited, cached, and graceful on 429.

 Product/cart local-only restrictions enforced on client and server.

 Single AddressForm component used across dashboard, onboarding, checkout.

 Checkout pre-fills from default; switching addresses updates default and downstream state.

 Playwright tests green for the scenarios above.

 No 500s for invalid address payloads; only 400 with field errors.

 Visuals: clearer input borders + errors, as previously requested.

üß≠ Commands to run (dev)
Purge & migrate

graphql
Copy
Edit
pnpm db:migrate         # includes schema from Phase 1
pnpm db:wipe-dev        # runs the TRUNCATEs above (dev guard)
Start & seed

bash
Copy
Edit
pnpm dev
pnpm seed:users
Run e2e

bash
Copy
Edit
pnpm test:e2e
If anything in this spec conflicts with current env (e.g., Redis disabled), keep the in-memory LRU cache for Geoapify and leave a TODO to enable Redis in prod. This plan removes all duplication, guarantees one source of truth in the database, and locks down ‚ÄúLOCAL customer‚Äù behavior across onboarding, profile, checkout, cart, and products.