Complete Production Database Setup Instructions for Replit
PHASE 1: SECRETS CONFIGURATION
Instructions for Replit: Configure the following secrets in the Secrets tab. Replace placeholder values with actual credentials.
bash# Database Configuration
DATABASE_URL_DEV = [Insert Replit's original database URL]
DATABASE_URL_PROD = [Insert the new Neon production database URL]
DATABASE_URL = [Insert development URL as fallback]

# Admin Configuration
ADMIN_EMAIL = [Insert admin email address]
ADMIN_PASSWORD = [Insert secure admin password]
ADMIN_FIRST_NAME = [Insert admin first name]
ADMIN_LAST_NAME = [Insert admin last name]

# Service Configuration
STRIPE_SECRET_KEY = [Insert Stripe secret key]
STRIPE_WEBHOOK_SECRET = [Insert Stripe webhook secret]
STRIPE_PUBLISHABLE_KEY = [Insert Stripe publishable key]
CLOUDINARY_CLOUD_NAME = [Insert Cloudinary cloud name]
CLOUDINARY_API_KEY = [Insert Cloudinary API key]
CLOUDINARY_API_SECRET = [Insert Cloudinary API secret]
RESEND_API_KEY = [Insert Resend API key]

# Security Configuration
SESSION_SECRET = [Generate 64-character random string]
JWT_SECRET = [Generate 64-character random string]
ENCRYPTION_KEY = [Generate 32-character random string]

# Environment Configuration
NODE_ENV = development
ENABLE_DEBUG_LOGGING = false
ENABLE_REDIS = false
FORCE_SSL = true

PHASE 2: PROJECT STRUCTURE SETUP
Create the following directory structure:
Clean-Flip/
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ init-production.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ init-development.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ migrate.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ seed-dev.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ backup.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ verify.ts
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îî‚îÄ‚îÄ db-helper.ts
‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ environment.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security.ts
‚îÇ   ‚îî‚îÄ‚îÄ db/
‚îÇ       ‚îî‚îÄ‚îÄ index.ts
‚îî‚îÄ‚îÄ .replit

PHASE 3: CORE FILES TO CREATE
File 1: server/config/database.ts
Instructions: Create comprehensive database configuration that:

Detects environment (development/production/deployment)
Uses DATABASE_URL_PROD for production
Uses DATABASE_URL_DEV for development
Includes retry logic and health checks
Validates correct database is being used
Prevents using dev database in production

File 2: server/config/environment.ts
Instructions: Create environment detection utilities that:

Check for REPLIT_DEPLOYMENT flag
Check NODE_ENV variable
Provide helper functions for environment detection
Export environment status

File 3: server/config/security.ts
Instructions: Create security configuration that:

Validates all required secrets exist
Checks for production security requirements
Ensures SSL is enabled in production
Validates admin credentials are set

File 4: scripts/database/init-production.ts
Instructions: Create production initialization script that:

Validates DATABASE_URL_PROD exists
Creates admin user with hashed password
Creates all product categories
Sets up system settings table
Creates performance indexes
Verifies all tables exist
Includes safety checks to prevent accidental initialization

File 5: scripts/database/init-development.ts
Instructions: Create development initialization script that:

Uses DATABASE_URL_DEV
Creates test users
Generates sample products
Seeds test data
Marks all data as test data

File 6: scripts/database/migrate.ts
Instructions: Create migration script that:

Detects target environment
Runs Drizzle migrations
Logs migration status
Handles rollback on failure

File 7: scripts/database/seed-dev.ts
Instructions: Create development seeding script that:

Only runs on development database
Creates 50+ test products
Creates test orders
Creates test users
Generates realistic test data

File 8: scripts/database/verify.ts
Instructions: Create verification script that:

Tests both database connections
Verifies table structure
Checks indexes exist
Validates environment variables
Reports configuration status

File 9: scripts/database/backup.ts
Instructions: Create backup script that:

Only backs up production data
Exports to JSON format
Excludes sensitive data
Creates timestamped backups

File 10: .replit
Instructions: Create Replit configuration:
tomlrun = "npm run dev"
entrypoint = "server/index.ts"

[deployment]
run = ["sh", "-c", "NODE_ENV=production npm run start"]
deploymentTarget = "cloudrun"
ignorePorts = false

[env]
NODE_ENV = "production"

PHASE 4: PACKAGE.JSON SCRIPTS
Instructions: Add these scripts to package.json:
json{
  "scripts": {
    "dev": "NODE_ENV=development tsx watch server/index.ts",
    "start": "node dist/index.js",
    "build": "npm run build:client && npm run build:server",
    "build:client": "vite build",
    "build:server": "esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    
    "db:push": "drizzle-kit push",
    "db:push:dev": "NODE_ENV=development drizzle-kit push",
    "db:push:prod": "NODE_ENV=production drizzle-kit push",
    "db:migrate": "tsx scripts/database/migrate.ts",
    "db:migrate:dev": "NODE_ENV=development tsx scripts/database/migrate.ts",
    "db:migrate:prod": "NODE_ENV=production tsx scripts/database/migrate.ts",
    
    "db:init:dev": "NODE_ENV=development tsx scripts/database/init-development.ts",
    "db:init:prod": "NODE_ENV=production tsx scripts/database/init-production.ts",
    "db:seed:dev": "NODE_ENV=development tsx scripts/database/seed-dev.ts",
    "db:verify": "tsx scripts/database/verify.ts",
    "db:backup": "NODE_ENV=production tsx scripts/database/backup.ts",
    
    "setup:dev": "npm run db:push:dev && npm run db:init:dev && npm run db:seed:dev",
    "setup:prod": "npm run db:push:prod && npm run db:init:prod",
    "setup:all": "npm run setup:dev && npm run setup:prod && npm run db:verify",
    
    "test:db": "tsx scripts/database/verify.ts",
    "test:env": "tsx scripts/utils/check-environment.ts",
    "test:all": "npm run test:env && npm run test:db"
  }
}

PHASE 5: UPDATE DRIZZLE CONFIGURATION
File: drizzle.config.ts
Instructions: Update to support dual databases:

Read NODE_ENV to determine target
Use DATABASE_URL_PROD for production
Use DATABASE_URL_DEV for development
Include proper SSL configuration
Set correct output directories


PHASE 6: UPDATE SERVER FILES
Update: server/db/index.ts
Instructions:

Import from ../config/database
Export database instance
Export helper functions
Remove any hardcoded connections

Update: server/index.ts
Instructions: Add startup logging:

Display current environment
Show which database is active
Verify all required services
Test database connection
Display security status


PHASE 7: SAFETY VALIDATIONS
Create: scripts/utils/check-environment.ts
Instructions: Create validation script that:

Checks all required environment variables
Validates database URLs are different
Ensures production URL doesn't contain "lingering-flower"
Verifies admin credentials exist
Checks service keys are configured


PHASE 8: INITIALIZATION SEQUENCE
Run these commands in order:
bash# Step 1: Install dependencies
npm install bcrypt @types/bcrypt pg @types/pg

# Step 2: Verify environment
npm run test:env

# Step 3: Initialize development database
npm run setup:dev

# Step 4: Initialize production database  
npm run setup:prod

# Step 5: Verify both databases
npm run db:verify

# Step 6: Test development
npm run dev
# Should show: "Using DEVELOPMENT database"

# Step 7: Test production mode
NODE_ENV=production npm run start
# Should show: "Using PRODUCTION database"

PHASE 9: DEPLOYMENT CONFIGURATION
Pre-deployment Checklist:

Verify DATABASE_URL_PROD is set in secrets
Verify ADMIN_EMAIL and ADMIN_PASSWORD are set
Run npm run db:verify to check both databases
Ensure production database has been initialized
Test locally with NODE_ENV=production npm run start

Deployment Process:

Build the application: npm run build
Run verification: npm run test:all
Click Deploy button in Replit
Monitor deployment logs for database connection
Verify deployment uses production database


PHASE 10: POST-DEPLOYMENT VERIFICATION
Create: scripts/utils/post-deploy-check.ts
Instructions: Create script that:

Connects to production database
Verifies admin user exists
Checks categories are present
Tests search functionality
Validates all tables exist
Reports deployment health


CRITICAL SAFETY FEATURES TO IMPLEMENT

Database URL Validation:

Never allow dev database in production
Check for "lingering-flower" vs "muddy-moon"
Exit if wrong database detected


Environment Detection:

Check REPLIT_DEPLOYMENT flag
Check NODE_ENV variable
Use multiple detection methods


Seeding Protection:

Never seed production database
Check environment before seeding
Require confirmation for production operations


Connection Pooling:

Use different pool sizes for dev/prod
Implement retry logic
Handle connection failures gracefully


Logging:

Clear environment indicators
Database host logging (without passwords)
Operation timestamps




MONITORING AND MAINTENANCE
Daily Tasks:
bash# Development work
npm run dev  # Uses development database

# Before deployment
npm run db:verify  # Check both databases
npm run test:all   # Run all tests
Weekly Tasks:
bash# Backup production data
npm run db:backup

# Verify database health
npm run db:verify
For Each Feature Release:
bash# Test in development first
npm run dev

# Migrate production
NODE_ENV=production npm run db:migrate:prod

# Deploy
git push && deploy via Replit

TROUBLESHOOTING COMMANDS
bash# Check which database is being used
echo $DATABASE_URL_DEV | head -c 50
echo $DATABASE_URL_PROD | head -c 50

# Test connections
npm run db:verify

# Reset development database
npm run setup:dev

# Check environment detection
npm run test:env

SUCCESS INDICATORS
When properly configured, you should see:
In Development:

Console shows: "üõ†Ô∏è DEVELOPMENT MODE ACTIVE"
Database: "ep-lingering-flower"
Test data is present

In Production/Deployment:

Console shows: "üöÄ PRODUCTION MODE ACTIVE"
Database: "ep-muddy-moon (pooled)"
Only real data is present


Implementation Note for Replit: Follow each phase in order. The system uses DATABASE_URL_PROD and DATABASE_URL_DEV to maintain complete separation between environments, ensuring production data security while allowing free experimentation in development.