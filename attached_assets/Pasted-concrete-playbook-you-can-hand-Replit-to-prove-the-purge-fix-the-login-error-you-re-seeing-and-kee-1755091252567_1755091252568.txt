concrete playbook you can hand Replit to prove the purge, fix the login error you’re seeing, and keep the codebase locked to the new SSOT address system forever.

A) Fix what’s breaking right now (from your logs)
A1) Login is failing with column "street" does not exist
The legacy columns were dropped (good), but server/storage.ts#getUserByEmail still selects them.

Do this:

Update the query in server/storage.ts so it does not reference any legacy columns. It should only read from users and (optionally) join the default address via profile_address_id. Example patch:

ts
Copy
Edit
// server/storage.ts (replace the old getUserByEmail)
export async function getUserByEmail(email: string) {
  // MINIMAL USER SHAPE – no legacy columns
  const user = await db.query(`
    SELECT
      u.id, u.email, u.password_hash, u.first_name, u.last_name,
      u.phone, u.profile_address_id, u.is_local_customer,
      u.onboarding_step, u.profile_complete, u.onboarding_completed_at,
      u.created_at, u.updated_at
    FROM users u
    WHERE LOWER(u.email) = LOWER($1)
    LIMIT 1
  `, [email]);

  return user?.[0] ?? null;
}
If you want /api/user to include address details, do it there with a clean, optional join to SSOT:

ts
Copy
Edit
// server/routes/user.ts (or wherever /api/user lives)
router.get("/api/user", requireAuth, async (req, res) => {
  const user = await db.query(`
    SELECT
      u.id, u.email, u.first_name, u.last_name, u.phone,
      u.is_local_customer, u.profile_address_id,
      a.id        AS address_id,
      a.first_name AS address_first_name,
      a.last_name  AS address_last_name,
      a.street1, a.street2, a.city, a.state, a.postal_code, a.country,
      a.latitude, a.longitude, a.is_default, a.is_local
    FROM users u
    LEFT JOIN addresses a ON a.id = u.profile_address_id
    WHERE u.id = $1
    LIMIT 1
  `, [req.user!.id]);

  res.json({ user: user?.[0] ?? null });
});
Restart the server and try login again. The 42703 error should disappear.

B) Prove the purge: machine-enforced checks so no legacy code can sneak back
The goal: if any file references the old system, the build fails.

B1) Remove or archive the files (and make it impossible to import them)
Delete any legacy pages/components/routes you still have (including admin variants). If something truly must live for archaeology, move it to docs/_graveyard/ and exclude that folder from TypeScript/ESLint.

B2) Add a “banned terms” check (ripgrep + CI)
Create scripts/check-legacy.sh:

bash
Copy
Edit
#!/usr/bin/env bash
set -euo pipefail

# Banned tokens (old columns, endpoints, filenames, props)
PATTERNS=(
  # legacy user columns
  "\bstreet\b"
  "\bcity\b"
  "\bstate\b"
  "\bzip_code\b"
  "\blatitude\b"
  "\blongitude\b"
  # legacy files/components
  "checkout_broken"
  "Address.*Legacy"
  "Onboarding.*Legacy"
  # legacy DTO keys
  "\bzipCode\b"
  "\bstreet\b\s*:"   # object key street:
  # legacy endpoints living in server/routes.ts
  "server/routes.ts.*\/api\/addresses"
)

# Allow list where these words are legitimate (SSOT addresses table)
ALLOW='server/routes/addresses.ts|client/src/api/addresses.ts|client/src/components/addresses|client/src/pages/onboarding|server/types/address|server/lib/addressCanonicalizer'

FAIL=0
for p in "${PATTERNS[@]}"; do
  if rg -n --hidden -S -g '!docs/_graveyard/**' -e "$p" \
      | rg -v "$ALLOW" \
      | rg -v '\.sql$' \
      | rg -v '\baddresses?\b' > /tmp/legacy_hits.txt; then
    if [[ -s /tmp/legacy_hits.txt ]]; then
      echo "❌ Legacy pattern found for: $p"
      cat /tmp/legacy_hits.txt
      FAIL=1
    fi
  fi
done

if [[ $FAIL -eq 1 ]]; then
  echo "🔴 Legacy references detected. Purge them."
  exit 1
fi

echo "🟢 No legacy references detected."
Make it executable: chmod +x scripts/check-legacy.sh

Add to package.json:

json
Copy
Edit
{
  "scripts": {
    "prebuild": "scripts/check-legacy.sh",
    "prestart": "scripts/check-legacy.sh"
  }
}
Now the app won’t build or start if any legacy reference reappears.

B3) ESLint guard (compile-time)
In .eslintrc.* add:

json
Copy
Edit
{
  "rules": {
    "no-restricted-properties": [
      "error,
      {
        "objectPattern": true,
        "message": "Use SSOT addresses table; users.* address fields were dropped.",
        "properties": ["street", "city", "state", "zip_code", "latitude", "longitude"]
      }
    ],
    "no-restricted-syntax": [
      "error",
      {
        "selector": "ImportDeclaration[source.value=/checkout_broken|Legacy|OldAddress|server\\/routes\\.ts$/]",
        "message": "Do not import legacy address/onboarding files or server/routes.ts for address endpoints."
      }
    ]
  }
}
This is intentionally noisy. If it blocks legitimate SSOT usage (e.g., latitude in the addresses table), scope the rule to files under server/models/user* and server/storage.ts (user only), not the addresses domain.

B4) CI gate
Run npm run prebuild in CI on every PR. If any legacy token is detected, fail the PR.

C) Database truth & cleanup
C1) Ensure schema constraints for SSOT
Unique default per user:

sql
Copy
Edit
CREATE UNIQUE INDEX IF NOT EXISTS ux_addresses_default_per_user
  ON addresses (user_id)
  WHERE is_default = true;
users.profile_address_id should point to the default address when present. Add a small service function in server/lib/addressService.ts:

ts
Copy
Edit
export async function setDefaultAddress(userId: string, addressId: string) {
  await db.tx(async (t) => {
    await t.query(`UPDATE addresses SET is_default = false WHERE user_id = $1`, [userId]);
    await t.query(`UPDATE addresses SET is_default = true WHERE id = $1 AND user_id = $2`, [addressId, userId]);
    await t.query(`UPDATE users SET profile_address_id = $1 WHERE id = $2`, [addressId, userId]);
  });
}
And call this from POST/PUT address routes when isDefault is true.

C2) “Clean slate” user wipe (dev)
When you want to reset test data:

sql
Copy
Edit
TRUNCATE TABLE sessions RESTART IDENTITY CASCADE;
TRUNCATE TABLE cart_items RESTART IDENTITY CASCADE;
TRUNCATE TABLE carts RESTART IDENTITY CASCADE;
TRUNCATE TABLE addresses RESTART IDENTITY CASCADE;
TRUNCATE TABLE users RESTART IDENTITY CASCADE;
D) Onboarding, Profile, Checkout, Cart — single source and tests
D1) Onboarding (new pages are loading per your logs — keep them)
/onboarding/index.tsx, StepAddress.tsx, StepPhone.tsx, StepSummary.tsx must:

Use the shared AddressForm component.

POST only the SSOT fields: firstName,lastName,street1,street2?,city,state,postalCode,country,latitude?,longitude?,geoapifyPlaceId?,isDefault:true.

After completion → set users.profile_address_id to the default address and set is_local_customer (server decides based on radius).

No SMS anywhere.

Phone validation with libphonenumber-js; do not let users proceed with invalid input.

D2) Profile / Dashboard “Addresses” tab
Render from GET /api/addresses only.

One “Default” badge; actions: Set Default, Edit, Delete.

Mark “Local ✅/❌” using is_local.

D3) Checkout shipping
Prefill from GET /api/addresses?default=true.

“Use a different address” opens the same AddressForm. On save as default, summary updates, and server updates users.profile_address_id.

D4) Cart rules (local-only)
Product flag: products.is_local_only boolean DEFAULT false.

Add-to-cart (client): if not local and product is local-only → disable with tooltip.

Server guard: on POST /api/cart/items or on cart validate, if any item is local-only and user not local → 400 with message.

If any item local-only and user local → shipping $0 and show “Free local delivery within 48h”.

E) Geoapify hardening (no more 429 → 500)
Client autocomplete: debounce 350ms.

Server proxy /api/geocode/autocomplete:

Add in-memory LRU (or Redis) cache 10 mins by text.

Basic rate limit (e.g., 5/5s per IP).

On Geoapify 429: return { results: [], exhausted: true } with 200; UI should allow manual entry.

F) End-to-end verification script (what Replit should run)
bash
Copy
Edit
# 1) Prove purge
npm run prebuild    # runs scripts/check-legacy.sh → should print 🟢 No legacy references

# 2) Clean data (dev only)
psql "$DATABASE_URL" -f scripts/dev_truncate.sql

# 3) Start server & web
npm run dev

# 4) Flows to test manually or via Playwright
#   a) Email signup → onboarding address+phone → summary → redirect back (no loop)
#   b) Dashboard Addresses tab shows the default; edit/set default works
#   c) Checkout prefilled; “use different address” updates default
#   d) Non-local user cannot add local-only product (client blocks; server 400)
#   e) Local user sees free 48h delivery banner when cart has local-only item

# 5) Watch logs – should have:
#   - No /api/user 401 after login
#   - No 500s on /api/addresses (bad payloads must return 400 with zod details)
#   - No "column ... does not exist" errors
G) “Definition of Done” (merge is blocked unless all are true)
 scripts/check-legacy.sh passes (no hits)

 ESLint “no-restricted-*” rules added; app compiles

 getUserByEmail no longer selects legacy columns; login works

 /api/user returns SSOT-backed profileAddress (optional)

 Onboarding completes once and never loops; no SMS anywhere

 Dashboard → Addresses shows SSOT list with one default; actions work

 Checkout reads default only; can switch default via modal

 Cart local-only logic enforced client & server; 48h banner for local buyers

 Geoapify 429 no longer produces server 500

 Dev “wipe users” SQL available and documented

Notes on your current logs
The build is loading the new onboarding files (/src/pages/onboarding/*.tsx) — good.

The only red flag is the POST /api/login 500 from getUserByEmail selecting street. Fixing section A1 removes that.

The GET /api/user 401 is just “not logged in yet” noise prior to auth.

Hand this to Replit exactly as-is. It gives them a checklist, commands, code patches, and guards so you can be 100% confident every legacy trace is gone and the system stays locked to your new SSOT design.