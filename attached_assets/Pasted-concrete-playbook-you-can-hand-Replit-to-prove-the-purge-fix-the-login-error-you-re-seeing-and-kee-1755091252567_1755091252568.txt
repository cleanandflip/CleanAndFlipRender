concrete playbook you can hand Replit to prove the purge, fix the login error youâ€™re seeing, and keep the codebase locked to the new SSOT address system forever.

A) Fix whatâ€™s breaking right now (from your logs)
A1) Login is failing with column "street" does not exist
The legacy columns were dropped (good), but server/storage.ts#getUserByEmail still selects them.

Do this:

Update the query in server/storage.ts so it does not reference any legacy columns. It should only read from users and (optionally) join the default address via profile_address_id. Example patch:

ts
Copy
Edit
// server/storage.ts (replace the old getUserByEmail)
export async function getUserByEmail(email: string) {
  // MINIMAL USER SHAPE â€“ no legacy columns
  const user = await db.query(`
    SELECT
      u.id, u.email, u.password_hash, u.first_name, u.last_name,
      u.phone, u.profile_address_id, u.is_local_customer,
      u.onboarding_step, u.profile_complete, u.onboarding_completed_at,
      u.created_at, u.updated_at
    FROM users u
    WHERE LOWER(u.email) = LOWER($1)
    LIMIT 1
  `, [email]);

  return user?.[0] ?? null;
}
If you want /api/user to include address details, do it there with a clean, optional join to SSOT:

ts
Copy
Edit
// server/routes/user.ts (or wherever /api/user lives)
router.get("/api/user", requireAuth, async (req, res) => {
  const user = await db.query(`
    SELECT
      u.id, u.email, u.first_name, u.last_name, u.phone,
      u.is_local_customer, u.profile_address_id,
      a.id        AS address_id,
      a.first_name AS address_first_name,
      a.last_name  AS address_last_name,
      a.street1, a.street2, a.city, a.state, a.postal_code, a.country,
      a.latitude, a.longitude, a.is_default, a.is_local
    FROM users u
    LEFT JOIN addresses a ON a.id = u.profile_address_id
    WHERE u.id = $1
    LIMIT 1
  `, [req.user!.id]);

  res.json({ user: user?.[0] ?? null });
});
Restart the server and try login again. The 42703 error should disappear.

B) Prove the purge: machine-enforced checks so no legacy code can sneak back
The goal: if any file references the old system, the build fails.

B1) Remove or archive the files (and make it impossible to import them)
Delete any legacy pages/components/routes you still have (including admin variants). If something truly must live for archaeology, move it to docs/_graveyard/ and exclude that folder from TypeScript/ESLint.

B2) Add a â€œbanned termsâ€ check (ripgrep + CI)
Create scripts/check-legacy.sh:

bash
Copy
Edit
#!/usr/bin/env bash
set -euo pipefail

# Banned tokens (old columns, endpoints, filenames, props)
PATTERNS=(
  # legacy user columns
  "\bstreet\b"
  "\bcity\b"
  "\bstate\b"
  "\bzip_code\b"
  "\blatitude\b"
  "\blongitude\b"
  # legacy files/components
  "checkout_broken"
  "Address.*Legacy"
  "Onboarding.*Legacy"
  # legacy DTO keys
  "\bzipCode\b"
  "\bstreet\b\s*:"   # object key street:
  # legacy endpoints living in server/routes.ts
  "server/routes.ts.*\/api\/addresses"
)

# Allow list where these words are legitimate (SSOT addresses table)
ALLOW='server/routes/addresses.ts|client/src/api/addresses.ts|client/src/components/addresses|client/src/pages/onboarding|server/types/address|server/lib/addressCanonicalizer'

FAIL=0
for p in "${PATTERNS[@]}"; do
  if rg -n --hidden -S -g '!docs/_graveyard/**' -e "$p" \
      | rg -v "$ALLOW" \
      | rg -v '\.sql$' \
      | rg -v '\baddresses?\b' > /tmp/legacy_hits.txt; then
    if [[ -s /tmp/legacy_hits.txt ]]; then
      echo "âŒ Legacy pattern found for: $p"
      cat /tmp/legacy_hits.txt
      FAIL=1
    fi
  fi
done

if [[ $FAIL -eq 1 ]]; then
  echo "ğŸ”´ Legacy references detected. Purge them."
  exit 1
fi

echo "ğŸŸ¢ No legacy references detected."
Make it executable: chmod +x scripts/check-legacy.sh

Add to package.json:

json
Copy
Edit
{
  "scripts": {
    "prebuild": "scripts/check-legacy.sh",
    "prestart": "scripts/check-legacy.sh"
  }
}
Now the app wonâ€™t build or start if any legacy reference reappears.

B3) ESLint guard (compile-time)
In .eslintrc.* add:

json
Copy
Edit
{
  "rules": {
    "no-restricted-properties": [
      "error,
      {
        "objectPattern": true,
        "message": "Use SSOT addresses table; users.* address fields were dropped.",
        "properties": ["street", "city", "state", "zip_code", "latitude", "longitude"]
      }
    ],
    "no-restricted-syntax": [
      "error",
      {
        "selector": "ImportDeclaration[source.value=/checkout_broken|Legacy|OldAddress|server\\/routes\\.ts$/]",
        "message": "Do not import legacy address/onboarding files or server/routes.ts for address endpoints."
      }
    ]
  }
}
This is intentionally noisy. If it blocks legitimate SSOT usage (e.g., latitude in the addresses table), scope the rule to files under server/models/user* and server/storage.ts (user only), not the addresses domain.

B4) CI gate
Run npm run prebuild in CI on every PR. If any legacy token is detected, fail the PR.

C) Database truth & cleanup
C1) Ensure schema constraints for SSOT
Unique default per user:

sql
Copy
Edit
CREATE UNIQUE INDEX IF NOT EXISTS ux_addresses_default_per_user
  ON addresses (user_id)
  WHERE is_default = true;
users.profile_address_id should point to the default address when present. Add a small service function in server/lib/addressService.ts:

ts
Copy
Edit
export async function setDefaultAddress(userId: string, addressId: string) {
  await db.tx(async (t) => {
    await t.query(`UPDATE addresses SET is_default = false WHERE user_id = $1`, [userId]);
    await t.query(`UPDATE addresses SET is_default = true WHERE id = $1 AND user_id = $2`, [addressId, userId]);
    await t.query(`UPDATE users SET profile_address_id = $1 WHERE id = $2`, [addressId, userId]);
  });
}
And call this from POST/PUT address routes when isDefault is true.

C2) â€œClean slateâ€ user wipe (dev)
When you want to reset test data:

sql
Copy
Edit
TRUNCATE TABLE sessions RESTART IDENTITY CASCADE;
TRUNCATE TABLE cart_items RESTART IDENTITY CASCADE;
TRUNCATE TABLE carts RESTART IDENTITY CASCADE;
TRUNCATE TABLE addresses RESTART IDENTITY CASCADE;
TRUNCATE TABLE users RESTART IDENTITY CASCADE;
D) Onboarding, Profile, Checkout, Cart â€” single source and tests
D1) Onboarding (new pages are loading per your logs â€” keep them)
/onboarding/index.tsx, StepAddress.tsx, StepPhone.tsx, StepSummary.tsx must:

Use the shared AddressForm component.

POST only the SSOT fields: firstName,lastName,street1,street2?,city,state,postalCode,country,latitude?,longitude?,geoapifyPlaceId?,isDefault:true.

After completion â†’ set users.profile_address_id to the default address and set is_local_customer (server decides based on radius).

No SMS anywhere.

Phone validation with libphonenumber-js; do not let users proceed with invalid input.

D2) Profile / Dashboard â€œAddressesâ€ tab
Render from GET /api/addresses only.

One â€œDefaultâ€ badge; actions: Set Default, Edit, Delete.

Mark â€œLocal âœ…/âŒâ€ using is_local.

D3) Checkout shipping
Prefill from GET /api/addresses?default=true.

â€œUse a different addressâ€ opens the same AddressForm. On save as default, summary updates, and server updates users.profile_address_id.

D4) Cart rules (local-only)
Product flag: products.is_local_only boolean DEFAULT false.

Add-to-cart (client): if not local and product is local-only â†’ disable with tooltip.

Server guard: on POST /api/cart/items or on cart validate, if any item is local-only and user not local â†’ 400 with message.

If any item local-only and user local â†’ shipping $0 and show â€œFree local delivery within 48hâ€.

E) Geoapify hardening (no more 429 â†’ 500)
Client autocomplete: debounce 350ms.

Server proxy /api/geocode/autocomplete:

Add in-memory LRU (or Redis) cache 10 mins by text.

Basic rate limit (e.g., 5/5s per IP).

On Geoapify 429: return { results: [], exhausted: true } with 200; UI should allow manual entry.

F) End-to-end verification script (what Replit should run)
bash
Copy
Edit
# 1) Prove purge
npm run prebuild    # runs scripts/check-legacy.sh â†’ should print ğŸŸ¢ No legacy references

# 2) Clean data (dev only)
psql "$DATABASE_URL" -f scripts/dev_truncate.sql

# 3) Start server & web
npm run dev

# 4) Flows to test manually or via Playwright
#   a) Email signup â†’ onboarding address+phone â†’ summary â†’ redirect back (no loop)
#   b) Dashboard Addresses tab shows the default; edit/set default works
#   c) Checkout prefilled; â€œuse different addressâ€ updates default
#   d) Non-local user cannot add local-only product (client blocks; server 400)
#   e) Local user sees free 48h delivery banner when cart has local-only item

# 5) Watch logs â€“ should have:
#   - No /api/user 401 after login
#   - No 500s on /api/addresses (bad payloads must return 400 with zod details)
#   - No "column ... does not exist" errors
G) â€œDefinition of Doneâ€ (merge is blocked unless all are true)
 scripts/check-legacy.sh passes (no hits)

 ESLint â€œno-restricted-*â€ rules added; app compiles

 getUserByEmail no longer selects legacy columns; login works

 /api/user returns SSOT-backed profileAddress (optional)

 Onboarding completes once and never loops; no SMS anywhere

 Dashboard â†’ Addresses shows SSOT list with one default; actions work

 Checkout reads default only; can switch default via modal

 Cart local-only logic enforced client & server; 48h banner for local buyers

 Geoapify 429 no longer produces server 500

 Dev â€œwipe usersâ€ SQL available and documented

Notes on your current logs
The build is loading the new onboarding files (/src/pages/onboarding/*.tsx) â€” good.

The only red flag is the POST /api/login 500 from getUserByEmail selecting street. Fixing section A1 removes that.

The GET /api/user 401 is just â€œnot logged in yetâ€ noise prior to auth.

Hand this to Replit exactly as-is. It gives them a checklist, commands, code patches, and guards so you can be 100% confident every legacy trace is gone and the system stays locked to your new SSOT design.