ðŸš¨ PERSISTENT ERROR LOGGING & CODEBASE SCANNER
Instructions for Replit - Complete Error Capture System:
ðŸ“Œ 1. Database Schema for Persistent Error Storage
sql
-- CREATE these tables for permanent error storage:

CREATE TABLE IF NOT EXISTS error_logs (
    id VARCHAR PRIMARY KEY DEFAULT gen_random_uuid(),
    fingerprint VARCHAR NOT NULL,
    error_type VARCHAR NOT NULL,
    severity VARCHAR NOT NULL,
    message TEXT NOT NULL,
    stack_trace TEXT,
    file_path VARCHAR,
    line_number INTEGER,
    column_number INTEGER,
    user_id VARCHAR REFERENCES users(id),
    user_email VARCHAR,
    user_ip VARCHAR,
    user_agent TEXT,
    url VARCHAR,
    method VARCHAR,
    request_body JSONB,
    response_status INTEGER,
    browser VARCHAR,
    os VARCHAR,
    device_type VARCHAR,
    session_id VARCHAR,
    environment VARCHAR DEFAULT 'production',
    resolved BOOLEAN DEFAULT false,
    resolved_by VARCHAR REFERENCES users(id),
    resolved_at TIMESTAMP,
    notes TEXT,
    occurrence_count INTEGER DEFAULT 1,
    first_seen TIMESTAMP DEFAULT NOW(),
    last_seen TIMESTAMP DEFAULT NOW(),
    created_at TIMESTAMP DEFAULT NOW(),
    archived BOOLEAN DEFAULT false
);

CREATE INDEX IF NOT EXISTS idx_error_logs_fingerprint ON error_logs(fingerprint);
CREATE INDEX IF NOT EXISTS idx_error_logs_severity ON error_logs(severity);
CREATE INDEX IF NOT EXISTS idx_error_logs_created ON error_logs(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_error_logs_resolved ON error_logs(resolved);

-- Breadcrumbs table for error context
CREATE TABLE IF NOT EXISTS error_breadcrumbs (
    id VARCHAR PRIMARY KEY DEFAULT gen_random_uuid(),
    error_log_id VARCHAR REFERENCES error_logs(id) ON DELETE CASCADE,
    timestamp TIMESTAMP DEFAULT NOW(),
    type VARCHAR, -- 'navigation', 'click', 'api', 'console'
    category VARCHAR,
    message TEXT,
    data JSONB,
    level VARCHAR
);
ðŸ“Œ 2. Global Error Catchers - Backend
typescript
// server/services/errorCatcher.ts - CREATE THIS:

import { ErrorLogger } from './errorLogger';

class GlobalErrorCatcher {
  private static instance: GlobalErrorCatcher;
  
  static init(app: Express) {
    if (!this.instance) {
      this.instance = new GlobalErrorCatcher();
      this.instance.setupHandlers(app);
    }
  }
  
  private setupHandlers(app: Express) {
    // 1. CATCH UNCAUGHT EXCEPTIONS
    process.on('uncaughtException', async (error: Error) => {
      await ErrorLogger.logError({
        severity: 'critical',
        error_type: 'uncaught_exception',
        message: error.message,
        stack_trace: error.stack,
        environment: process.env.NODE_ENV
      });
      // Don't exit - keep running
    });
    
    // 2. CATCH UNHANDLED PROMISE REJECTIONS
    process.on('unhandledRejection', async (reason: any, promise: Promise<any>) => {
      await ErrorLogger.logError({
        severity: 'critical',
        error_type: 'unhandled_rejection',
        message: reason?.message || String(reason),
        stack_trace: reason?.stack,
        environment: process.env.NODE_ENV
      });
    });
    
    // 3. CATCH ALL EXPRESS ERRORS
    app.use('*', async (err: any, req: Request, res: Response, next: NextFunction) => {
      await ErrorLogger.logError({
        severity: err.status >= 500 ? 'critical' : 'error',
        error_type: 'express_error',
        message: err.message,
        stack_trace: err.stack,
        url: req.url,
        method: req.method,
        user_id: req.user?.id,
        user_ip: req.ip,
        user_agent: req.headers['user-agent']
      });
      next(err);
    });
    
    // 4. CATCH 404 ROUTING ERRORS
    app.use('*', async (req: Request, res: Response) => {
      await ErrorLogger.logError({
        severity: 'warning',
        error_type: 'route_not_found',
        message: `404 - Route not found: ${req.method} ${req.url}`,
        url: req.url,
        method: req.method,
        user_id: req.user?.id
      });
      res.status(404).json({ error: 'Route not found' });
    });
    
    // 5. DATABASE ERROR CATCHING
    db.on('error', async (error: any) => {
      await ErrorLogger.logError({
        severity: 'critical',
        error_type: 'database_error',
        message: error.message,
        stack_trace: error.stack
      });
    });
    
    // 6. CATCH STRIPE ERRORS
    stripe.on('error', async (error: any) => {
      await ErrorLogger.logError({
        severity: 'high',
        error_type: 'stripe_error',
        message: error.message,
        stack_trace: error.stack
      });
    });
  }
}

// Initialize in server/index.ts:
GlobalErrorCatcher.init(app);
ðŸ“Œ 3. Global Error Catchers - Frontend
typescript
// client/src/services/globalErrorCatcher.ts - CREATE THIS:

class FrontendErrorCatcher {
  private static breadcrumbs: any[] = [];
  private static maxBreadcrumbs = 50;
  
  static init() {
    // 1. CATCH ALL JAVASCRIPT ERRORS
    window.addEventListener('error', (event: ErrorEvent) => {
      this.logError({
        severity: 'error',
        error_type: 'javascript_error',
        message: event.message,
        stack_trace: event.error?.stack,
        file_path: event.filename,
        line_number: event.lineno,
        column_number: event.colno,
        url: window.location.href,
        breadcrumbs: this.breadcrumbs
      });
    });
    
    // 2. CATCH UNHANDLED PROMISE REJECTIONS
    window.addEventListener('unhandledrejection', (event: PromiseRejectionEvent) => {
      this.logError({
        severity: 'error',
        error_type: 'promise_rejection',
        message: event.reason?.message || String(event.reason),
        stack_trace: event.reason?.stack,
        url: window.location.href,
        breadcrumbs: this.breadcrumbs
      });
    });
    
    // 3. CATCH REACT ERRORS (Error Boundary)
    // Add this to your root App.tsx
    
    // 4. CATCH NETWORK/API ERRORS
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      try {
        const response = await originalFetch(...args);
        if (!response.ok && response.status >= 400) {
          this.logError({
            severity: response.status >= 500 ? 'critical' : 'warning',
            error_type: 'api_error',
            message: `API Error: ${response.status} ${response.statusText}`,
            url: args[0] as string,
            response_status: response.status
          });
        }
        return response;
      } catch (error) {
        this.logError({
          severity: 'critical',
          error_type: 'network_error',
          message: `Network Error: ${error.message}`,
          url: args[0] as string
        });
        throw error;
      }
    };
    
    // 5. CATCH ROUTING ERRORS
    window.addEventListener('popstate', () => {
      const path = window.location.pathname;
      // Check if route exists
      if (!this.isValidRoute(path)) {
        this.logError({
          severity: 'warning',
          error_type: 'routing_error',
          message: `Invalid route accessed: ${path}`,
          url: path
        });
      }
    });
    
    // 6. TRACK USER ACTIONS (Breadcrumbs)
    ['click', 'input', 'submit'].forEach(eventType => {
      document.addEventListener(eventType, (event: Event) => {
        this.addBreadcrumb({
          type: eventType,
          target: (event.target as HTMLElement)?.tagName,
          message: `User ${eventType} on ${(event.target as HTMLElement)?.tagName}`,
          timestamp: new Date()
        });
      }, true);
    });
    
    // 7. CONSOLE ERROR INTERCEPTION
    const originalConsoleError = console.error;
    console.error = (...args) => {
      this.logError({
        severity: 'error',
        error_type: 'console_error',
        message: args.join(' '),
        url: window.location.href
      });
      originalConsoleError.apply(console, args);
    };
  }
  
  private static async logError(errorData: any) {
    // Add user context
    errorData.user_id = getCurrentUser()?.id;
    errorData.user_email = getCurrentUser()?.email;
    errorData.browser = navigator.userAgent;
    errorData.timestamp = new Date();
    
    // Send to backend
    await fetch('/api/admin/errors/log', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(errorData)
    });
    
    // Also send via WebSocket for real-time updates
    socket.emit('error_logged', errorData);
  }
  
  private static addBreadcrumb(crumb: any) {
    this.breadcrumbs.push(crumb);
    if (this.breadcrumbs.length > this.maxBreadcrumbs) {
      this.breadcrumbs.shift();
    }
  }
}

// Initialize in main.tsx:
FrontendErrorCatcher.init();
ðŸ“Œ 4. Codebase Scanner Button & Logic
typescript
// client/src/components/admin/CodebaseScanner.tsx - CREATE:

const CodebaseScanner = () => {
  const [scanning, setScanning] = useState(false);
  const [scanResults, setScanResults] = useState(null);
  
  const scanCodebase = async () => {
    setScanning(true);
    
    const response = await fetch('/api/admin/scan-codebase', {
      method: 'POST'
    });
    
    const results = await response.json();
    setScanResults(results);
    setScanning(false);
  };
  
  return (
    <div className="bg-gray-800/50 rounded-lg p-4 border border-gray-700">
      <h3 className="text-white font-semibold mb-4">Codebase Error Scanner</h3>
      
      <button
        onClick={scanCodebase}
        disabled={scanning}
        className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg flex items-center space-x-2"
      >
        {scanning ? (
          <>
            <Loader2 className="animate-spin h-4 w-4" />
            <span>Scanning...</span>
          </>
        ) : (
          <>
            <Search className="h-4 w-4" />
            <span>Scan Entire Codebase</span>
          </>
        )}
      </button>
      
      {scanResults && (
        <div className="mt-4 space-y-2">
          <div className="text-sm text-gray-400">
            Found {scanResults.totalErrors} potential issues:
          </div>
          <div className="grid grid-cols-4 gap-2">
            <div className="bg-red-500/20 p-2 rounded">
              <div className="text-red-400 font-bold">{scanResults.critical}</div>
              <div className="text-xs text-gray-400">Critical</div>
            </div>
            <div className="bg-orange-500/20 p-2 rounded">
              <div className="text-orange-400 font-bold">{scanResults.errors}</div>
              <div className="text-xs text-gray-400">Errors</div>
            </div>
            <div className="bg-yellow-500/20 p-2 rounded">
              <div className="text-yellow-400 font-bold">{scanResults.warnings}</div>
              <div className="text-xs text-gray-400">Warnings</div>
            </div>
            <div className="bg-blue-500/20 p-2 rounded">
              <div className="text-blue-400 font-bold">{scanResults.info}</div>
              <div className="text-xs text-gray-400">Info</div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};
ðŸ“Œ 5. Backend Codebase Scanner
typescript
// server/routes/admin/codebaseScanner.ts - CREATE:

import { promises as fs } from 'fs';
import path from 'path';

router.post('/api/admin/scan-codebase', requireDeveloper, async (req, res) => {
  const errors = [];
  
  // 1. SCAN FOR CONSOLE.LOG STATEMENTS
  const scanForConsoleLogs = async (dir: string) => {
    const files = await fs.readdir(dir, { withFileTypes: true });
    
    for (const file of files) {
      const filePath = path.join(dir, file.name);
      
      if (file.isDirectory() && !file.name.includes('node_modules')) {
        await scanForConsoleLogs(filePath);
      } else if (file.name.match(/\.(ts|tsx|js|jsx)$/)) {
        const content = await fs.readFile(filePath, 'utf-8');
        const lines = content.split('\n');
        
        lines.forEach((line, index) => {
          // Check for console.log
          if (line.includes('console.log')) {
            errors.push({
              severity: 'info',
              error_type: 'console_log',
              message: 'Console.log found',
              file_path: filePath,
              line_number: index + 1
            });
          }
          
          // Check for TODO comments
          if (line.includes('TODO') || line.includes('FIXME')) {
            errors.push({
              severity: 'warning',
              error_type: 'todo_comment',
              message: line.trim(),
              file_path: filePath,
              line_number: index + 1
            });
          }
          
          // Check for hardcoded API keys
          if (line.match(/['"](sk_|pk_|api_|key_|secret_)/i)) {
            errors.push({
              severity: 'critical',
              error_type: 'hardcoded_secret',
              message: 'Potential hardcoded API key',
              file_path: filePath,
              line_number: index + 1
            });
          }
          
          // Check for any Error throws
          if (line.includes('throw new Error')) {
            errors.push({
              severity: 'warning',
              error_type: 'unhandled_throw',
              message: 'Error throw without try-catch',
              file_path: filePath,
              line_number: index + 1
            });
          }
          
          // Check for missing error handling
          if (line.includes('.catch(') === false && line.includes('await ')) {
            errors.push({
              severity: 'warning',
              error_type: 'missing_error_handling',
              message: 'Async operation without error handling',
              file_path: filePath,
              line_number: index + 1
            });
          }
        });
      }
    }
  };
  
  // 2. CHECK FOR MISSING ROUTES
  const checkRoutes = async () => {
    const clientRoutes = [
      '/', '/auth', '/products', '/cart', '/checkout', '/profile',
      '/orders', '/admin', '/search', '/forgot-password', '/reset-password'
    ];
    
    for (const route of clientRoutes) {
      // Check if route component exists
      const componentPath = `client/src/pages${route === '/' ? '/home' : route}.tsx`;
      try {
        await fs.access(componentPath);
      } catch {
        errors.push({
          severity: 'error',
          error_type: 'missing_route',
          message: `Missing route component for ${route}`,
          file_path: componentPath
        });
      }
    }
  };
  
  // 3. CHECK DATABASE QUERIES
  const checkDatabaseQueries = async () => {
    // Check for N+1 queries, missing indexes, etc.
    const queries = await db.query(`
      SELECT query, calls, mean_exec_time
      FROM pg_stat_statements
      WHERE mean_exec_time > 100
      ORDER BY mean_exec_time DESC
      LIMIT 10
    `).catch(() => []);
    
    queries.forEach(query => {
      errors.push({
        severity: 'warning',
        error_type: 'slow_query',
        message: `Slow query: ${query.mean_exec_time}ms`,
        query: query.query
      });
    });
  };
  
  // 4. CHECK TYPESCRIPT ERRORS
  const checkTypeScript = async () => {
    const { exec } = require('child_process');
    
    await new Promise((resolve) => {
      exec('npx tsc --noEmit', (error, stdout, stderr) => {
        if (stderr) {
          const lines = stderr.split('\n');
          lines.forEach(line => {
            if (line.includes('error TS')) {
              errors.push({
                severity: 'error',
                error_type: 'typescript_error',
                message: line
              });
            }
          });
        }
        resolve(null);
      });
    });
  };
  
  // RUN ALL SCANS
  await scanForConsoleLogs('./client/src');
  await scanForConsoleLogs('./server');
  await checkRoutes();
  await checkDatabaseQueries();
  await checkTypeScript();
  
  // LOG ALL FOUND ERRORS TO DATABASE
  for (const error of errors) {
    await ErrorLogger.logError(error);
  }
  
  // Return summary
  res.json({
    totalErrors: errors.length,
    critical: errors.filter(e => e.severity === 'critical').length,
    errors: errors.filter(e => e.severity === 'error').length,
    warnings: errors.filter(e => e.severity === 'warning').length,
    info: errors.filter(e => e.severity === 'info').length,
    details: errors
  });
});
ðŸ“Œ 6. WebSocket for Real-time Error Updates
typescript
// server/websocket.ts - ADD:

io.on('connection', (socket) => {
  // Join admin room if developer
  if (socket.request.user?.role === 'developer') {
    socket.join('admin-errors');
  }
  
  // When new error is logged, broadcast to admins
  socket.on('error_logged', (errorData) => {
    io.to('admin-errors').emit('new_error', errorData);
  });
});

// client/src/pages/admin/ErrorDashboard.tsx - ADD:
useEffect(() => {
  socket.on('new_error', (error) => {
    // Add to error list in real-time
    setErrors(prev => [error, ...prev]);
    
    // Show notification for critical errors
    if (error.severity === 'critical') {
      toast.error(`Critical Error: ${error.message}`);
    }
  });
  
  return () => socket.off('new_error');
}, []);
ðŸ“Œ 7. Error Dashboard Summary
tsx
// Add to Error Dashboard:

<div className="mb-6">
  {/* SCAN BUTTON */}
  <CodebaseScanner />
  
  {/* LIVE INDICATOR */}
  <div className="flex items-center space-x-2 mt-4">
    <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" />
    <span className="text-xs text-gray-400">Live - Catching all errors</span>
  </div>
  
  {/* PERSISTENCE NOTE */}
  <div className="text-xs text-gray-500 mt-2">
    All errors are permanently stored in database and persist across restarts
  </div>
</div>
What This System Catches:
âœ… JavaScript errors (syntax, reference, type errors)
âœ… Network/API errors (404s, 500s, timeouts)
âœ… React component errors (via Error Boundary)
âœ… Promise rejections (unhandled async errors)
âœ… Database errors (connection, query failures)
âœ… Routing errors (404 pages, invalid routes)
âœ… Server crashes (uncaught exceptions)
âœ… Console errors (intercepted console.error)
âœ… TypeScript errors (via code scan)
âœ… Code issues (TODOs, console.logs, hardcoded keys)
âœ… Slow queries (performance issues)
âœ… Third-party errors (Stripe, Cloudinary, etc.)

All errors persist in database and NEVER reset on restart!


