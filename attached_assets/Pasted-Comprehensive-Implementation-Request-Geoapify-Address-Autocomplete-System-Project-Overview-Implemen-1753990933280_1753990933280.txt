Comprehensive Implementation Request: Geoapify Address Autocomplete System
Project Overview
Implement a unified address autocomplete system using Geoapify API that replaces all current address inputs across the Clean & Flip website. This will provide a seamless, single-input address experience that automatically detects local customers in the Asheville, NC area.
Why Geoapify?

3,000 requests/day free tier
Better address parsing than alternatives
Excellent US coverage
Clean API with good documentation
Built for autocomplete functionality

Implementation Requirements
1. Geoapify Setup
bash# Add to .env
VITE_GEOAPIFY_API_KEY=your_api_key_here

# Get API key from: https://www.geoapify.com/
# Select "Geocoding API" when creating project
2. Create Address Autocomplete Component
Create src/components/ui/address-autocomplete.tsx:
tsximport { useState, useRef, useEffect } from 'react';
import { MapPin, Loader2, X, CheckCircle } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useDebounce } from '@/hooks/useDebounce';

interface ParsedAddress {
  street: string;
  city: string;
  state: string;
  zipCode: string;
  fullAddress: string;
  coordinates?: {
    lat: number;
    lng: number;
  };
}

interface AddressAutocompleteProps {
  value?: string;
  onChange: (address: ParsedAddress) => void;
  placeholder?: string;
  className?: string;
  required?: boolean;
  id?: string;
  name?: string;
}

export function AddressAutocomplete({
  value = '',
  onChange,
  placeholder = "Start typing your address...",
  className,
  required,
  id,
  name
}: AddressAutocompleteProps) {
  const [input, setInput] = useState(value);
  const [suggestions, setSuggestions] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [showDropdown, setShowDropdown] = useState(false);
  const [selectedAddress, setSelectedAddress] = useState<ParsedAddress | null>(null);
  const wrapperRef = useRef<HTMLDivElement>(null);
  const debouncedInput = useDebounce(input, 300);

  // Geoapify API call
  useEffect(() => {
    if (debouncedInput.length < 3) {
      setSuggestions([]);
      return;
    }

    const searchAddresses = async () => {
      setLoading(true);
      try {
        const response = await fetch(
          `https://api.geoapify.com/v1/geocode/autocomplete?` +
          `text=${encodeURIComponent(debouncedInput)}&` +
          `filter=countrycode:us&` +
          `format=json&` +
          `apiKey=${import.meta.env.VITE_GEOAPIFY_API_KEY}`
        );
        
        const data = await response.json();
        setSuggestions(data.features || []);
        setShowDropdown(true);
      } catch (error) {
        console.error('Address search failed:', error);
        setSuggestions([]);
      } finally {
        setLoading(false);
      }
    };

    searchAddresses();
  }, [debouncedInput]);

  // Parse Geoapify response
  const parseAddress = (feature: any): ParsedAddress => {
    const props = feature.properties;
    
    // Extract components
    const streetNumber = props.housenumber || '';
    const streetName = props.street || '';
    const street = `${streetNumber} ${streetName}`.trim();
    const city = props.city || props.town || props.village || '';
    const state = props.state_code || props.state || '';
    const zipCode = props.postcode || '';
    
    // Format: "123 Main St, Asheville, NC 28806"
    const fullAddress = `${street}, ${city}, ${state} ${zipCode}`.replace(/\s+/g, ' ').trim();
    
    return {
      street,
      city,
      state,
      zipCode,
      fullAddress,
      coordinates: {
        lat: props.lat,
        lng: props.lon
      }
    };
  };

  // Check if address is local to Asheville
  const isLocalCustomer = (address: ParsedAddress): boolean => {
    const ashevilleZips = [
      '28801', '28802', '28803', '28804', '28805', '28806',
      '28810', '28813', '28814', '28815', '28816'
    ];
    return ashevilleZips.includes(address.zipCode);
  };

  // Handle selection
  const selectAddress = (feature: any) => {
    const parsed = parseAddress(feature);
    setInput(parsed.fullAddress);
    setSelectedAddress(parsed);
    onChange(parsed);
    setShowDropdown(false);
    setSuggestions([]);
  };

  // Clear input
  const clearInput = () => {
    setInput('');
    setSuggestions([]);
    setShowDropdown(false);
    setSelectedAddress(null);
    onChange({
      street: '',
      city: '',
      state: '',
      zipCode: '',
      fullAddress: ''
    });
  };

  // Close dropdown on outside click
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) {
        setShowDropdown(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  return (
    <div ref={wrapperRef} className="relative">
      <div className="relative">
        <input
          type="text"
          id={id}
          name={name}
          value={input}
          onChange={(e) => {
            setInput(e.target.value);
            if (!e.target.value) clearInput();
          }}
          placeholder={placeholder}
          required={required}
          className={cn(
            "w-full px-3 py-3 bg-gray-800 border border-gray-700",
            "text-white placeholder-gray-500 rounded-lg",
            "focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent",
            "transition-all duration-200",
            className
          )}
          autoComplete="off"
        />
        
        {/* Loading indicator */}
        {loading && (
          <Loader2 className="absolute right-3 top-1/2 -translate-y-1/2 h-4 w-4 text-blue-500 animate-spin" />
        )}
        
        {/* Clear button */}
        {!loading && input && (
          <button
            type="button"
            onClick={clearInput}
            className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500 hover:text-white transition-colors"
          >
            <X className="h-4 w-4" />
          </button>
        )}
      </div>

      {/* Suggestions dropdown */}
      {showDropdown && suggestions.length > 0 && (
        <div 
          className="absolute z-[100] w-full mt-1 bg-gray-900 border border-gray-700 rounded-lg shadow-2xl max-h-60 overflow-auto"
          style={{ top: '100%' }}
        >
          {suggestions.map((feature, index) => {
            const parsed = parseAddress(feature);
            return (
              <button
                key={feature.properties.place_id || index}
                type="button"
                onClick={() => selectAddress(feature)}
                className="w-full px-4 py-3 text-left hover:bg-gray-800 focus:bg-gray-800 focus:outline-none transition-colors border-b border-gray-800 last:border-0"
              >
                <div className="flex items-start gap-3">
                  <MapPin className="h-4 w-4 text-gray-500 mt-0.5 flex-shrink-0" />
                  <div className="flex-1">
                    <div className="text-white">
                      {parsed.street}
                    </div>
                    <div className="text-gray-400 text-sm">
                      {parsed.city}, {parsed.state} {parsed.zipCode}
                    </div>
                  </div>
                </div>
              </button>
            );
          })}
        </div>
      )}

      {/* Local customer indicator */}
      {selectedAddress && isLocalCustomer(selectedAddress) && (
        <div className="mt-2 text-sm text-green-500 flex items-center gap-1">
          <CheckCircle className="w-4 h-4" />
          Local pickup available in Asheville
        </div>
      )}
    </div>
  );
}
3. Create Debounce Hook
Create src/hooks/useDebounce.ts:
tsximport { useEffect, useState } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
4. Update Database Schema
sql-- Add new columns to users table
ALTER TABLE users 
ADD COLUMN IF NOT EXISTS street VARCHAR(255),
ADD COLUMN IF NOT EXISTS city VARCHAR(100),
ADD COLUMN IF NOT EXISTS state VARCHAR(2),
ADD COLUMN IF NOT EXISTS zip_code VARCHAR(10),
ADD COLUMN IF NOT EXISTS latitude DECIMAL(10, 8),
ADD COLUMN IF NOT EXISTS longitude DECIMAL(11, 8),
ADD COLUMN IF NOT EXISTS is_local_customer BOOLEAN DEFAULT FALSE;

-- Migrate existing data
UPDATE users 
SET 
  street = SPLIT_PART(address, ',', 1),
  city = TRIM(SPLIT_PART(cityStateZip, ',', 1)),
  state = TRIM(SPLIT_PART(SPLIT_PART(cityStateZip, ',', 2), ' ', 1)),
  zip_code = TRIM(SPLIT_PART(SPLIT_PART(cityStateZip, ',', 2), ' ', 2))
WHERE address IS NOT NULL;

-- After verification, drop old columns
-- ALTER TABLE users DROP COLUMN address, DROP COLUMN cityStateZip;
5. Update All Forms
Registration Form (src/pages/auth.tsx):
tsx// Replace old address fields with:
<div className="space-y-2">
  <Label htmlFor="address">Address</Label>
  <AddressAutocomplete
    id="address"
    name="address"
    value={formData.address}
    onChange={(parsed) => {
      setFormData({
        ...formData,
        street: parsed.street,
        city: parsed.city,
        state: parsed.state,
        zipCode: parsed.zipCode,
        fullAddress: parsed.fullAddress,
        latitude: parsed.coordinates?.lat,
        longitude: parsed.coordinates?.lng
      });
    }}
    required
  />
</div>
Similar updates needed for:

User Profile (src/pages/dashboard.tsx)
Admin User Management
Checkout Page (src/pages/checkout.tsx)
Sell to Us Form (src/pages/sell-to-us.tsx)

6. Update API Endpoints
Registration endpoint:
typescript// server/routes/auth.ts
router.post('/register', async (req, res) => {
  const { email, password, firstName, lastName, street, city, state, zipCode, latitude, longitude } = req.body;
  
  // Determine if local customer
  const ashevilleZips = ['28801', '28802', '28803', '28804', '28805', '28806'];
  const isLocalCustomer = ashevilleZips.includes(zipCode);
  
  // Create user with new fields
  const user = await db.users.create({
    email,
    password: hashedPassword,
    firstName,
    lastName,
    street,
    city,
    state,
    zipCode,
    latitude,
    longitude,
    isLocalCustomer
  });
});
7. Create Address Display Component
tsx// src/components/ui/address-display.tsx
export function AddressDisplay({ user }: { user: User }) {
  if (!user.street) return <span className="text-gray-500">No address on file</span>;
  
  return (
    <div>
      <p className="text-white">{user.street}</p>
      <p className="text-gray-400">{user.city}, {user.state} {user.zipCode}</p>
      {user.isLocalCustomer && (
        <span className="text-xs text-green-500 mt-1 inline-block">
          âœ“ Local customer
        </span>
      )}
    </div>
  );
}
8. Backend Security
Add rate limiting to prevent abuse:
typescript// server/middleware/rateLimit.ts
const geocodeRateLimit = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 30, // 30 requests per minute per IP
  message: 'Too many address searches, please try again later'
});

app.use('/api/geocode', geocodeRateLimit);
Testing Checklist

 Registration form saves all address components
 Profile update works with new fields
 Admin can edit user addresses
 Local customer detection works correctly
 Address displays properly throughout site
 Old address data migrated successfully
 Geoapify API key is secure (not exposed in frontend)
 Rate limiting prevents abuse
 Mobile responsive
 Keyboard navigation works
 Clear button functions properly