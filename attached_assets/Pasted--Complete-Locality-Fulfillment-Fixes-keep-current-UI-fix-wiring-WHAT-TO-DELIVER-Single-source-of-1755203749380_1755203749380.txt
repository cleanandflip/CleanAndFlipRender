✅ Complete Locality/Fulfillment Fixes (keep current UI; fix wiring)
WHAT TO DELIVER
Single source of truth for locality using the precedence you listed (Default Address → ZIP override → IP fallback).

Server-side enforcement for cart + submissions (Sell to Us).

Client sync: default address immediately updates locality everywhere.

Purge old/stale locality code and “Shipping Only” remnants.

Fix the await in AddressForm.tsx compile error.

Keep all current visuals; only upgrade logic and data flow.

1) SHARED – One authority for locality
Create/replace shared/locality.ts (isomorphic):

ts
Copy
Edit
// shared/locality.ts
export type LocalitySource = 'DEFAULT_ADDRESS' | 'ZIP_OVERRIDE' | 'IP' | 'NONE';
export type LocalityReason =
  | 'IN_LOCAL_AREA'
  | 'NO_DEFAULT_ADDRESS'
  | 'ZIP_NOT_LOCAL'
  | 'FALLBACK_NON_LOCAL';

export type LocalityStatus = {
  eligible: boolean;
  source: LocalitySource;
  reason: LocalityReason;
  zipUsed?: string | null;
  city?: string | null;
  state?: string | null;
};

const LOCAL_ZIPS = new Set(['28801','28803','28804','28805','28806','28808']);

export function normalizeZip(input?: string | null) {
  if (!input) return null;
  const match = String(input).match(/\d{5}/);
  return match ? match[0] : null;
}

export function isLocalZip(zip?: string | null) {
  const z = normalizeZip(zip);
  return !!(z && LOCAL_ZIPS.has(z));
}

type EvaluateArgs = {
  defaultAddressZip?: string | null; // from user default address
  zipOverride?: string | null;       // from ?zip= or UI checker
  ipZipFallback?: string | null;     // optional geolocate
};

export function evaluateLocality({
  defaultAddressZip,
  zipOverride,
  ipZipFallback
}: EvaluateArgs): LocalityStatus {
  // 1) Default address
  if (defaultAddressZip) {
    const ok = isLocalZip(defaultAddressZip);
    return {
      eligible: ok,
      source: 'DEFAULT_ADDRESS',
      reason: ok ? 'IN_LOCAL_AREA' : 'ZIP_NOT_LOCAL',
      zipUsed: normalizeZip(defaultAddressZip)
    };
  }

  // 2) Explicit override
  if (zipOverride) {
    const ok = isLocalZip(zipOverride);
    return {
      eligible: ok,
      source: 'ZIP_OVERRIDE',
      reason: ok ? 'IN_LOCAL_AREA' : 'ZIP_NOT_LOCAL',
      zipUsed: normalizeZip(zipOverride)
    };
  }

  // 3) IP fallback (safe non-local if absent)
  const ok = isLocalZip(ipZipFallback);
  return {
    eligible: ok,
    source: ipZipFallback ? 'IP' : 'NONE',
    reason: ok ? 'IN_LOCAL_AREA' : 'FALLBACK_NON_LOCAL',
    zipUsed: normalizeZip(ipZipFallback)
  };
}
2) SERVER – Unified endpoint + enforcement
2.1 Locality controller (new)
Create server/locality/locality.controller.ts:

ts
Copy
Edit
// server/locality/locality.controller.ts
import type { Request, Response } from 'express';
import { evaluateLocality } from '../../shared/locality';
import { db } from '../db';

async function getDefaultAddressZip(userId?: string | null): Promise<string | null> {
  if (!userId) return null;
  // adjust table/columns to your schema
  const row = await db.queryOne<{
    zip: string | null;
  }>(
    `SELECT zip FROM addresses
     WHERE user_id = $1 AND is_default = TRUE
     ORDER BY updated_at DESC
     LIMIT 1`,
    [userId]
  );
  return row?.zip ?? null;
}

export async function getLocalityStatus(req: Request, res: Response) {
  const zipOverride = (req.query.zip as string | undefined) ?? null;
  const userId = (req as any).user?.id ?? null;

  const defaultAddressZip = await getDefaultAddressZip(userId);

  // optional IP-derived zip if you have it (otherwise null):
  const ipZipFallback = null;

  const status = evaluateLocality({ defaultAddressZip, zipOverride, ipZipFallback });
  res.json(status);
}
2.2 Middleware to require local customers (new)
Create server/middleware/requireLocalCustomer.ts:

ts
Copy
Edit
// server/middleware/requireLocalCustomer.ts
import type { Request, Response, NextFunction } from 'express';
import { evaluateLocality } from '../../shared/locality';
import { db } from '../db';

async function getDefaultAddressZip(userId?: string | null) {
  if (!userId) return null;
  const row = await db.queryOne<{ zip: string | null }>(
    `SELECT zip FROM addresses WHERE user_id=$1 AND is_default=TRUE LIMIT 1`,
    [userId]
  );
  return row?.zip ?? null;
}

export async function requireLocalCustomer(req: Request, res: Response, next: NextFunction) {
  const userId = (req as any).user?.id ?? null;
  const defaultAddressZip = await getDefaultAddressZip(userId);
  const status = evaluateLocality({ defaultAddressZip, zipOverride: null, ipZipFallback: null });

  if (!status.eligible) {
    return res.status(403).json({
      code: 'LOCAL_CUSTOMER_REQUIRED',
      message: 'This action is only available to local customers.',
      resolution: 'Set a default local address in your account or enter a local ZIP.'
    });
  }
  next();
}
2.3 Wire routes & server-side cart guard
In server/routes.ts:

ts
Copy
Edit
import { getLocalityStatus } from './locality/locality.controller';
import { requireLocalCustomer } from './middleware/requireLocalCustomer';
import { modeFromProduct } from '../shared/fulfillment'; // already exists per your spec

// Locality endpoint
app.get('/api/locality/status', getLocalityStatus);

// SELL-TO-US: Gate create submission(s) endpoints
app.post('/api/submissions', requireAuth, requireLocalCustomer, createSubmission);
// (and any other Sell-to-Us actions)

// CART: Block LOCAL_ONLY for non-local
app.post('/api/cart/items', requireSession, async (req, res, next) => {
  try {
    const { productId, quantity } = req.body;
    const product = await storage.getProductById(productId);
    if (!product) return res.status(404).json({ message: 'Product not found' });

    const userId = (req as any).user?.id ?? null;

    // read default zip
    const defaultZip = await db.queryOne<{ zip: string | null }>(
      `SELECT zip FROM addresses WHERE user_id=$1 AND is_default=TRUE LIMIT 1`,
      [userId]
    ).then(r => r?.zip ?? null);

    const { evaluateLocality } = await import('../shared/locality');
    const status = evaluateLocality({ defaultAddressZip: defaultZip, zipOverride: null, ipZipFallback: null });

    const mode = modeFromProduct(product);

    if (mode === 'LOCAL_ONLY' && !status.eligible) {
      return res.status(403).json({
        code: 'LOCAL_ONLY_NOT_ELIGIBLE',
        message: 'This item is local delivery only and is not available in your area.',
        resolution: 'Set a local default address or enter a local ZIP to qualify for local delivery.'
      });
    }

    // proceed to normal add-to-cart
    return next();
  } catch (e) {
    return next(e);
  }
});
Important: Remove/stop exporting any old server/services/locality.ts and any routes that returned conflicting shapes (keep the single /api/locality/status).

3) CLIENT – Use one hook & fix invalidation
3.1 Primary hook
Replace client/src/hooks/useLocality.ts:

ts
Copy
Edit
import { useQuery } from '@tanstack/react-query';

export type LocalityStatus = {
  eligible: boolean;
  source: 'DEFAULT_ADDRESS' | 'ZIP_OVERRIDE' | 'IP' | 'NONE';
  reason: 'IN_LOCAL_AREA' | 'NO_DEFAULT_ADDRESS' | 'ZIP_NOT_LOCAL' | 'FALLBACK_NON_LOCAL';
  zipUsed?: string | null;
};

export function useLocality(zipOverride?: string | null) {
  const query = useQuery<LocalityStatus>({
    queryKey: ['locality', { zipOverride: zipOverride ?? null }],
    queryFn: async () => {
      const params = new URLSearchParams();
      if (zipOverride) params.set('zip', zipOverride);
      const res = await fetch(`/api/locality/status?${params.toString()}`, { credentials: 'include' });
      if (!res.ok) throw new Error('Failed to fetch locality');
      return res.json();
    },
    staleTime: 5 * 60 * 1000
  });

  return {
    status: query.data,
    eligible: query.data?.eligible ?? false,
    loading: query.isLoading,
    error: query.error
  };
}
3.2 AddressForm compile error & invalidation
Fix client/src/components/addresses/AddressForm.tsx (the vite error “Unexpected reserved word await” happened because the surrounding function wasn’t async). Change that handler to async and invalidate locality too:

ts
Copy
Edit
// make the handler async
const onSubmit = async (values: FormValues) => {
  // ... existing submit logic ...
  if (form.getValues('setDefault')) {
    await Promise.all([
      queryClient.invalidateQueries({ queryKey: ['addresses'] }),
      queryClient.invalidateQueries({ queryKey: ['cart'] }),
      queryClient.invalidateQueries({ queryKey: ['user'] }),
      queryClient.invalidateQueries({ queryKey: ['locality'] }) // <-- critical
    ]);
  }
};
If the await cannot be used (e.g., inside non-async callback), use:
void Promise.all([ /* same list */ ]);

3.3 AddToCartButton – client guard (keeps UI)
Ensure client/src/components/AddToCartButton.tsx checks mode + locality (do not change styling):

ts
Copy
Edit
import { useLocality } from '@/hooks/useLocality';
import { modeFromProduct } from '@/shared/fulfillment';

export function AddToCartButton({ product, ...rest }: { product: Product } & ButtonProps) {
  const { eligible, loading } = useLocality();
  const mode = modeFromProduct(product);

  const blocked = mode === 'LOCAL_ONLY' && !eligible;

  return (
    <Button
      {...rest}
      disabled={loading || blocked || rest.disabled}
      title={blocked ? 'Local delivery only – set a local default address to order' : rest.title}
    >
      {blocked ? 'Local delivery only' : rest.children ?? 'Add to Cart'}
    </Button>
  );
}
3.4 Checkout – remove shipping & show ETA for LOCAL_ONLY
Patch client/src/pages/checkout.tsx:

ts
Copy
Edit
const { eligible } = useLocality();
// when computing totals:
const hasLocalOnly = cart.items.some(i => modeFromProduct(i.product) === 'LOCAL_ONLY');

// For local-only items: no shipping line item
const shippingCost = hasLocalOnly ? 0 : computedShipping;

// In the summary UI:
{hasLocalOnly && eligible && (
  <InlineNotice success text="Local Delivery ETA: 24–48 hrs" />
)}
3.5 Sell-to-Us page – hard gate (keep same look)
In client/src/pages/sell-to-us.tsx:

ts
Copy
Edit
import { useLocality } from '@/hooks/useLocality';
import { DeliveryEligibilityBanner } from '@/components/fulfillment/DeliveryEligibilityBanner';

export default function SellToUsPage() {
  const { eligible, loading } = useLocality();

  if (loading) return <PageLoader />;

  if (!eligible) {
    // Keep your current banner/card look; reuse component
    return (
      <div className="mx-auto max-w-5xl">
        <DeliveryEligibilityBanner variant="blocked" />
        <BlockedCard
          title="Local customers only"
          message="Sell to Us is available to local customers. Set a local default address or enter an eligible ZIP."
        />
      </div>
    );
  }

  return <SellToUsForm />; // existing UI
}
On the server, the corresponding /api/submissions (or your create endpoint) is already protected by requireLocalCustomer to prevent bypassing the page gate.

4) PURGE old/stale locality code
Remove all legacy locality hooks/components/services:

client/src/hooks/useLocality* (anything not the new one)

server/services/locality.ts (if still referenced)

Any “Shipping Only” badges/labels.

Grep for: Shipping Only, LocalBadge (old), isLocalZipCode(, and older /api/locality/* endpoints → delete or rewrite to proxy /api/locality/status shape.

Ensure only shared/locality.ts + GET /api/locality/status+useLocality` are referenced.

5) BUSINESS RULES (enforced everywhere)
LOCAL_ONLY

Non-local: Add to Cart blocked both client (disabled) and server (403).

Local: no shipping fees; checkout shows “Local Delivery ETA: 24–48 hrs.”

LOCAL_AND_SHIPPING

Always purchasable; locals can choose free delivery; non-locals pay shipping.

Locality precedence: Default Address → ZIP override → IP fallback (safe non-local if none).

6) ACCEPTANCE CHECKLIST
 With a local default address, banner shows eligible, product cards show enabled Add to Cart for local-only items, checkout removes shipping and shows ETA.

 With no local address (and no zip override), banner shows non-eligible, local-only add button disabled, server responds 403 if attempted via API.

 Entering a valid local ZIP in banner instantly flips locality everywhere (React Query invalidations).

 Sell to Us page blocks non-local users (page + server).

 No “Shipping Only” labels anywhere.

 No duplicate locality utilities remain (one hook, one endpoint, one shared evaluator).

 Build error in AddressForm.tsx gone.

7) Notes on the specific bug you saw
The products page banner said “outside local delivery area” despite a local default address. That happened because the client was not sourcing from /api/locality/status using default address (or the cache wasn’t invalidated after setting default).

The fixes above ensure:

Endpoint always prioritizes the default address.

AddressForm now invalidates ['locality'] when you switch default, immediately syncing UI.

Cart/checkout use the same evaluator, so there’s no chance for split-brain behavior.

This keeps your new UI intact, cleans out the conflicting code, and makes the locality/fulfillment logic consistent, enforceable, and fast across the whole site.