make the Errors (Observability) tab behave correctly:

Filters actually filter

“Mark resolved” / “Ignore” actions actually persist and update the UI

Noise (non-errors) doesn’t get reported or skew counts

I’m giving you the server, data layer, and client UI changes end-to-end. Do all of this.

1) Data layer (single source of truth)
File: server/data/errorStore.ts
Make sure we have these methods and that they work exactly like this.

ts
Copy
Edit
export type Issue = {
  _id?: string;
  fingerprint: string;
  title: string;
  level: "error"|"warn"|"info";
  firstSeen: Date;
  lastSeen: Date;
  count: number;                 // total events (excluding ignored if you choose)
  affectedUsers?: number;
  resolved: boolean;
  ignored: boolean;
  sampleEventId?: string;
  envs: Record<string, number>;
};

export const ErrorStore = {
  async insertRaw(doc: any) {
    return db.errors_raw.insertOne(doc);
  },

  async upsertIssue(raw: any) {
    const title = (raw.message?.split("\n")[0] ?? raw.type ?? "Error").slice(0, 160);
    await db.issues.updateOne(
      { fingerprint: raw.fingerprint },
      {
        $setOnInsert: {
          fingerprint: raw.fingerprint,
          title,
          firstSeen: raw.createdAt,
          resolved: false,
          ignored: false,
          sampleEventId: raw.eventId,
          level: raw.level,
          envs: {},
          count: 0,
        },
        $set: { lastSeen: raw.createdAt },
        $inc: { [`envs.${raw.env}`]: 1, count: 1 },
      },
      { upsert: true }
    );
  },

  async bumpRollup(raw: any) {
    const hr = new Date(raw.createdAt); hr.setMinutes(0,0,0);
    await db.issue_events.updateOne(
      { fingerprint: raw.fingerprint, hour: hr.toISOString() },
      { $inc: { count: 1 } },
      { upsert: true }
    );
  },

  async listIssues({ q, level, env, resolved, ignored=false, page=1, limit=20, sortBy="lastSeen", sortOrder="desc" }: any) {
    const f: any = {};
    if (q) f.$text = { $search: q };
    if (level) f.level = level;
    if (env) f[`envs.${env}`] = { $gt: 0 };
    if (resolved !== undefined) f.resolved = resolved;
    // default: ignored=false unless explicitly requested
    f.ignored = ignored;

    const sort: any = { [sortBy]: sortOrder === "asc" ? 1 : -1 };

    const cursor = db.issues.find(f).sort(sort).skip((page-1)*limit).limit(limit);
    const [items, total] = await Promise.all([cursor.toArray(), db.issues.countDocuments(f)]);
    return { items, total, page, limit };
  },

  getIssue(fp: string) {
    return db.issues.findOne({ fingerprint: fp });
  },

  getRawForIssue(fp: string, limit=50) {
    return db.errors_raw.find({ fingerprint: fp }).sort({ createdAt: -1 }).limit(limit).toArray();
  },

  setResolved(fp: string, resolved: boolean) {
    return db.issues.updateOne({ fingerprint: fp }, { $set: { resolved } });
  },

  setIgnored(fp: string, ignored: boolean) {
    return db.issues.updateOne({ fingerprint: fp }, { $set: { ignored } });
  },

  chartByHour({ from, to, env }: {from: Date; to: Date; env?: string}) {
    const match: any = { hour: { $gte: from.toISOString(), $lte: to.toISOString() } };
    if (env) match.env = env; // include if you added env to rollup docs
    return db.issue_events.find(match).sort({ hour: 1 }).toArray();
  },
};
Indexes (Mongo examples):

js
Copy
Edit
db.errors_raw.createIndex({ fingerprint: 1 });
db.errors_raw.createIndex({ createdAt: -1 });
db.issues.createIndex({ lastSeen: -1 });
db.issues.createIndex({ resolved: 1, ignored: 1 });
db.issues.createIndex({ title: "text" });
db.issue_events.createIndex({ hour: 1, fingerprint: 1 });
2) Server routes (filters + actions that actually work)
File: server/routes/observability.ts
Fix imports and add endpoints exactly like this. Also serialize dates to ISO to avoid client crashes.

ts
Copy
Edit
import { z } from "zod";
import { ErrorStore } from "../data/errorStore";

app.get("/api/observability/issues", async (req, res) => {
  const Query = z.object({
    q: z.string().optional(),
    level: z.enum(["error","warn","info"]).optional(),
    env: z.enum(["production","development"]).optional(),
    resolved: z.coerce.boolean().optional(),     // true/false
    ignored: z.coerce.boolean().optional(),      // default false in store
    page: z.coerce.number().int().min(1).default(1),
    limit: z.coerce.number().int().min(1).max(100).default(20),
    sortBy: z.enum(["lastSeen","count","firstSeen"]).default("lastSeen"),
    sortOrder: z.enum(["asc","desc"]).default("desc"),
  });

  const q = Query.safeParse(req.query);
  if (!q.success) return res.status(400).json({ error: q.error.flatten() });

  const result = await ErrorStore.listIssues(q.data);
  res.json({
    ...result,
    items: result.items.map(i => ({
      ...i,
      firstSeen: new Date(i.firstSeen).toISOString(),
      lastSeen: new Date(i.lastSeen).toISOString(),
    })),
  });
});

app.get("/api/observability/issues/:fp", async (req, res) => {
  const issue = await ErrorStore.getIssue(req.params.fp);
  if (!issue) return res.status(404).json({ error: "Issue not found" });
  res.json({
    ...issue,
    firstSeen: new Date(issue.firstSeen).toISOString(),
    lastSeen: new Date(issue.lastSeen).toISOString(),
  });
});

app.get("/api/observability/issues/:fp/events", async (req, res) => {
  const limit = Math.min(Number(req.query.limit ?? 50), 200);
  const rows = await ErrorStore.getRawForIssue(req.params.fp, limit);
  res.json(rows.map(r => ({ ...r, createdAt: new Date(r.createdAt).toISOString() })));
});

app.put("/api/observability/issues/:fp/resolve", async (req, res) => {
  await ErrorStore.setResolved(req.params.fp, true);
  const issue = await ErrorStore.getIssue(req.params.fp);
  res.json({ ok: true, issue: issue && {
    ...issue,
    firstSeen: new Date(issue.firstSeen).toISOString(),
    lastSeen: new Date(issue.lastSeen).toISOString(),
  }});
});

app.put("/api/observability/issues/:fp/reopen", async (req, res) => {
  await ErrorStore.setResolved(req.params.fp, false);
  const issue = await ErrorStore.getIssue(req.params.fp);
  res.json({ ok: true, issue: issue && {
    ...issue,
    firstSeen: new Date(issue.firstSeen).toISOString(),
    lastSeen: new Date(issue.lastSeen).toISOString(),
  }});
});

app.put("/api/observability/issues/:fp/ignore", async (req, res) => {
  await ErrorStore.setIgnored(req.params.fp, true);
  res.json({ ok: true });
});

app.put("/api/observability/issues/:fp/unignore", async (req, res) => {
  await ErrorStore.setIgnored(req.params.fp, false);
  res.json({ ok: true });
});

app.get("/api/observability/series", async (req, res) => {
  const days = Math.min(Number(req.query.days ?? 1), 30);
  const now = new Date();
  const from = new Date(now.getTime() - days*24*3600*1000);
  const rows = await ErrorStore.chartByHour({ from, to: now });
  res.json(rows.map(r => ({ ...r, hour: new Date(r.hour).toISOString() })));
});
Sanitizer allowlist must include /api/observability/* and you must mount express.json() before sanitizer.

3) Ingest (server) – don’t count noise as “errors”
File: server/routes/observability-ingest.ts (or same routes file)

Add rules so non-errors don’t inflate error counts.

ts
Copy
Edit
import { z } from "zod";
import { v4 as uuid } from "uuid";
import { ErrorStore } from "../data/errorStore";

const IGNORE_URL = [
  /:\/\/replit\.com\/public\/js\/beacon\.js$/,
];
const DOWNGRADE_TO_INFO = [
  /res\.cloudinary\.com\/clean-flip\/image\/upload\/.+\/categories\/.+\.(jpg|png|webp)$/i,
];

const Ingest = z.object({
  service: z.enum(["client","server"]),
  level: z.enum(["error","warn","info"]).default("error"),
  env: z.enum(["development","production"]).default(process.env.NODE_ENV==="production"?"production":"development"),
  release: z.string().optional(),
  url: z.string().optional(),
  method: z.string().optional(),
  statusCode: z.number().optional(),
  message: z.string().min(1),
  type: z.string().optional(),
  stack: z.string().optional(),
  user: z.object({ id: z.string().optional() }).optional(),
  tags: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])).optional(),
  extra: z.record(z.string(), z.any()).optional(),
}).strict();

function normalizeStack(raw?: string): string[] {
  if (!raw) return [];
  return raw.split("\n")
    .map(l => l.trim())
    .filter(l => l && !l.includes("node_modules") && !l.includes("(internal"))
    .map(l => l.replace(/\(\w+:\/\/.*?\)/g, "()").replace(/:\d+:\d+/g, ":__:__"));
}

function fingerprintOf(p: { message?: string; stack?: string[]; url?: string; type?: string; service: string }) {
  const top = p.stack?.[0] ?? "";
  const basis = [p.service, p.type ?? "", p.message ?? "", top, p.url ?? ""].join("|").slice(0, 2048);
  let h = 0; for (let i=0;i<basis.length;i++) h = (h*31 + basis.charCodeAt(i))|0;
  return `fp_${Math.abs(h)}`;
}

app.post("/api/observability/errors", async (req, res) => {
  const parsed = Ingest.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });

  const now = new Date();
  const stack = normalizeStack(parsed.data.stack);
  let level = parsed.data.level;

  // Noise rules (server-side safety net)
  const msg = parsed.data.message ?? "";
  const urlMatch = /https?:\/\/[^\s]+/i.exec(msg)?.[0] ?? parsed.data.url ?? "";

  if (urlMatch && IGNORE_URL.some(rx => rx.test(urlMatch))) {
    return res.status(204).end(); // ignore silently
  }
  if (urlMatch && DOWNGRADE_TO_INFO.some(rx => rx.test(urlMatch))) {
    level = "info";
  }
  // If someone sent "error" without stack and it's not from boundary, downgrade to warn
  const fromBoundary = parsed.data.extra && parsed.data.extra.source === "boundary";
  if (level === "error" && !fromBoundary && stack.length === 0) {
    level = "warn";
  }

  const base = { ...parsed.data, level, stack };
  const fingerprint = fingerprintOf({ ...base, stack });

  const raw = {
    eventId: uuid(),
    createdAt: now,
    ...base,
    fingerprint,
  };

  await ErrorStore.insertRaw(raw);

  // If issue is currently ignored, do not bump counters/rollup
  const existing = await ErrorStore.getIssue(fingerprint);
  if (existing?.ignored) {
    return res.status(201).json({ ok: true, eventId: raw.eventId, fingerprint, ignored: true });
  }

  await Promise.all([
    ErrorStore.upsertIssue(raw),
    ErrorStore.bumpRollup(raw),
  ]);

  res.status(201).json({ ok: true, eventId: raw.eventId, fingerprint });
});
4) Client API for actions (used by the page)
File: src/api/observability.ts

ts
Copy
Edit
export const obsApi = {
  issues: async (params: Record<string, any> = {}) => {
    const qs = new URLSearchParams(Object.entries(params).filter(([,v]) => v !== undefined) as any);
    const r = await fetch(`/api/observability/issues?${qs}`, { credentials: "include" });
    if (!r.ok) throw new Error(await r.text());
    return r.json();
  },
  issue: async (fp: string) => (await fetch(`/api/observability/issues/${fp}`, { credentials: "include" })).json(),
  events: async (fp: string, limit=50) => (await fetch(`/api/observability/issues/${fp}/events?limit=${limit}`, { credentials: "include" })).json(),
  resolve: async (fp: string) => (await fetch(`/api/observability/issues/${fp}/resolve`, { method: "PUT", credentials: "include" })).json(),
  reopen:  async (fp: string) => (await fetch(`/api/observability/issues/${fp}/reopen`,  { method: "PUT", credentials: "include" })).json(),
  ignore:  async (fp: string) => (await fetch(`/api/observability/issues/${fp}/ignore`,  { method: "PUT", credentials: "include" })).json(),
  unignore:async (fp: string) => (await fetch(`/api/observability/issues/${fp}/unignore`,{ method: "PUT", credentials: "include" })).json(),
  series:  async (days=1) => (await fetch(`/api/observability/series?days=${days}`, { credentials: "include" })).json(),
};
5) UI wiring (filters + actions + unified dropdowns)
File: src/pages/admin/observability/index.tsx (or your page)
Key points:

Default filters: level="error", resolved=false, ignored=false.

Use Unified Dropdown for Level / Env / Status / Ignored.

Optimistic updates for Resolve/Ignore.

Debounce search.

tsx
Copy
Edit
import { useState, useMemo } from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { obsApi } from "@/api/observability";
import { Dropdown } from "@/components/ui/Dropdown"; // unified
import { toDateSafe, fmtDateTime } from "@/lib/dates";

export default function ObservabilityPage() {
  const qc = useQueryClient();

  const [q, setQ] = useState("");
  const [level, setLevel] = useState<""|"error"|"warn"|"info">("error");
  const [env, setEnv] = useState<""|"production"|"development">("");
  const [resolved, setResolved] = useState(false);
  const [ignored, setIgnored] = useState(false); // default false
  const [page, setPage] = useState(1);
  const limit = 20;

  const debouncedQ = useMemo(() => q, [q]); // add a real debounce(250ms) if you have a util

  const { data, isLoading } = useQuery({
    queryKey: ["obs:issues", debouncedQ, level, env, resolved, ignored, page, limit],
    queryFn: () => obsApi.issues({
      q: debouncedQ || undefined,
      level: level || undefined,
      env: env || undefined,
      resolved,
      ignored,
      page,
      limit,
      sortBy: "lastSeen",
      sortOrder: "desc",
    }),
    keepPreviousData: true,
  });

  const onResolve = async (fp: string) => {
    // optimistic
    qc.setQueryData<any>(["obs:issues", debouncedQ, level, env, resolved, ignored, page, limit], (prev) => {
      if (!prev) return prev;
      return { ...prev, items: prev.items.map((i:any) => i.fingerprint===fp ? { ...i, resolved: true } : i) };
    });
    await obsApi.resolve(fp).catch(() => qc.invalidateQueries({ queryKey: ["obs:issues"] }));
  };

  const onReopen = async (fp: string) => {
    qc.setQueryData<any>(["obs:issues", debouncedQ, level, env, resolved, ignored, page, limit], (prev) => {
      if (!prev) return prev;
      return { ...prev, items: prev.items.map((i:any) => i.fingerprint===fp ? { ...i, resolved: false } : i) };
    });
    await obsApi.reopen(fp).catch(() => qc.invalidateQueries({ queryKey: ["obs:issues"] }));
  };

  const onIgnore = async (fp: string) => {
    // default view hides ignored; remove it from the list immediately
    qc.setQueryData<any>(["obs:issues", debouncedQ, level, env, resolved, ignored, page, limit], (prev) => {
      if (!prev) return prev;
      return { ...prev, items: prev.items.filter((i:any) => i.fingerprint!==fp) };
    });
    await obsApi.ignore(fp).catch(() => qc.invalidateQueries({ queryKey: ["obs:issues"] }));
  };

  const onUnignore = async (fp: string) => {
    await obsApi.unignore(fp);
    qc.invalidateQueries({ queryKey: ["obs:issues"] });
  };

  // Unified dropdowns
  const LEVELS = [
    { label: "Errors", value: "error" },
    { label: "Warnings", value: "warn" },
    { label: "Info", value: "info" },
    { label: "All levels", value: "" },
  ];
  const ENVS = [
    { label: "All envs", value: "" },
    { label: "Production", value: "production" },
    { label: "Development", value: "development" },
  ];
  const STATUS = [
    { label: "Unresolved", value: "unresolved" },
    { label: "Resolved", value: "resolved" },
  ];
  const IGNORED = [
    { label: "Hide ignored", value: "false" },
    { label: "Show ignored", value: "true"  },
  ];

  // …render toolbar with Dropdowns bound to setLevel/setEnv/setResolved/setIgnored…

  // …render table rows with buttons: Resolve/Reopen/Ignore/Unignore calling handlers above…

  return null; // replace with your themed UI – logic above is the key
}
Important: Remove any Radix/native selects or custom dropdowns on this page—use the unified one only.

6) Client reporter – don’t report non-errors
File: src/lib/err.ts
Final rules (pair with server rules):

Deduplicate per session

Ignore beacon.js

Downgrade Cloudinary category images to info

Never downgrade ErrorBoundary-originated exceptions

You already have most of this; keep it in.

7) Sanity & regression checks
Filters:

Default view shows Unresolved + Errors + Ignored=false

Changing Level/Env/Status/Show Ignored changes the results

Actions:

Resolve toggles badge and persists after refresh

Reopen toggles back

Ignore removes row in default view; appears when “Show ignored” is ON; Unignore puts it back in default view

Noise:

No beacon.js entries

Category image failures show at most once per URL per session and as info

Real runtime errors (from ErrorBoundary) always show as error

8) One-liners Replit can run to catch leftovers
bash
Copy
Edit
# Wrong endpoints or missing routes
rg -n "/api/observability/issues|/api/observability/series|/api/observability/errors" server

# Old error endpoints that must be gone
rg -n "/api/error-log|/api/scan|/api/diagnostics" server src

# Legacy dropdowns on the errors page
rg -n "StandardDropdown|@radix-ui/react-select|<select" src/pages/admin/observability

# Missing allowlist (sanitizer must allow observability routes)
rg -n "sanitize|allow|observability" server
Apply all of the above and the filters / mark resolved / ignore will work, and the dashboard will stop surfacing non-errors.








Ask ChatGPT
