fix the Observability (Errors) page:

1) Fix the runtime crash: parseISO reading split of undefined
Root cause: the page is calling parseISO(row.hour) (or similar) when row.hour is undefined or not a string.

Patch (defensive date parsing + stable series shape)
Add this util once (e.g., src/lib/dates.ts):

ts
Copy
Edit
// src/lib/dates.ts
export function toDateSafe(v: unknown): Date | null {
  if (v instanceof Date) return v;
  if (typeof v === "number") return new Date(v);        // epoch ms
  if (typeof v === "string" && v) {
    const d = new Date(v);                              // ISO or parseable
    return isNaN(+d) ? null : d;
  }
  return null;
}

export function fmtDateTime(d: Date | null): string {
  return d ? d.toLocaleString() : "—";
}
Normalize API responses (so the page always receives ISO strings):

/api/observability/issues must return firstSeen/lastSeen as toISOString().

/api/observability/series must return rows like:

json
Copy
Edit
[{ "hour": "2025-08-12T18:00:00.000Z", "fingerprint": "client:123", "count": 4 }]
In the server routes, adjust serialization:

ts
Copy
Edit
// when sending issues
const items = rawItems.map(it => ({
  ...it,
  firstSeen: new Date(it.firstSeen).toISOString(),
  lastSeen: new Date(it.lastSeen).toISOString(),
}));

// when sending series
const series = rows.map(r => ({
  ...r,
  hour: new Date(r.hour).toISOString(),
}));
In the page, replace any parseISO(...)/new Date(...) usage with the safe helper:

ts
Copy
Edit
import { toDateSafe, fmtDateTime } from "@/lib/dates";

// Issue list row:
const lastSeen = toDateSafe(issue.lastSeen);

// Series mapping:
const points = (data?.series ?? []).map((r: any) => {
  const t = toDateSafe(r.hour);
  return t ? { x: t.getTime(), y: Number(r.count) || 0 } : null;
}).filter(Boolean) as {x:number;y:number}[];
And when rendering:

tsx
Copy
Edit
<span className="text-xs opacity-70">{fmtDateTime(toDateSafe(issue.lastSeen))}</span>
Also guard in arrays where you map:

ts
Copy
Edit
const items = Array.isArray(data?.items) ? data.items : [];
That removes the crash permanently, regardless of what the backend sends.

2) Replace ad-hoc dropdowns with the Unified Dropdown everywhere on this page
Your observability page created its own selects. Swap to the shared component we standardized (the one used on Sell/Contact/etc.). I’ll refer to it as Dropdown (adjust the import path to whatever you actually finalized, e.g. @/components/ui/Dropdown).

Import the unified control
tsx
Copy
Edit
import { Dropdown } from "@/components/ui/Dropdown"; // <-- your unified dropdown
Use it for Level, Environment, and Status filters
tsx
Copy
Edit
const LEVELS = [
  { label: "All levels", value: "" },
  { label: "Error",     value: "error" },
  { label: "Warn",      value: "warn" },
  { label: "Info",      value: "info" },
];

const ENVS = [
  { label: "All envs",    value: "" },
  { label: "Production",  value: "production" },
  { label: "Development", value: "development" },
];

const STATUSES = [
  { label: "Unresolved", value: "false" },
  { label: "Resolved",   value: "true"  },
];

// in JSX toolbar:
<Dropdown
  value={level ?? ""}
  onChange={(v) => setLevel(v || undefined)}
  options={LEVELS}
  placeholder="Level"
/>

<Dropdown
  value={env ?? ""}
  onChange={(v) => setEnv(v || undefined)}
  options={ENVS}
  placeholder="Env"
/>

<Dropdown
  value={resolved ? "true" : "false"}
  onChange={(v) => setResolved(v === "true")}
  options={STATUSES}
  placeholder="Status"
/>
Remove any local <select>, Radix, or custom dropdown code in this page. The unified component already handles hover, focus ring, animation, z-index, and theme tokens.

If you see StandardDropdown imports here, delete them and use the unified Dropdown. This avoids the earlier “StandardDropdown is not defined” errors.

3) Z-index: keep dropdown menus above cards
Make sure the unified dropdown’s popover/portal has a high z-index (we set this globally, but enforce here too):

css
Copy
Edit
/* e.g. in your global.css or tailwind layer */
.dropdown-portal,
.dropdown-menu {
  z-index: 60; /* above cards/panels */
}
Or if the unified component exposes a portalClassName, set it on this page to ensure it renders above the grid.

4) Tighten the query + state wiring
Use one query key prefix to avoid cache collisions:

ts
Copy
Edit
const { data } = useQuery({
  queryKey: ["obs:issues", q, level, env, resolved, page, limit],
  queryFn: () => obsApi.issues({ q, level, env, resolved, page, limit }),
  keepPreviousData: true,
});
Debounce search input (250ms) to reduce API spam.

Always default data.items to [].

5) API contracts (so the UI doesn’t have to guess)
/api/observability/issues returns:

ts
Copy
Edit
{
  items: Array<{
    fingerprint: string;
    title: string;
    level: "error"|"warn"|"info";
    firstSeen: string;  // ISO
    lastSeen:  string;  // ISO
    count: number;
    affectedUsers?: number;
    resolved: boolean;
    ignored: boolean;
    envs?: Record<string, number>;
  }>;
  total: number;
  page: number;
  limit: number;
}
/api/observability/series?days=7 returns:

ts
Copy
Edit
Array<{ hour: string /* ISO */, fingerprint?: string, count: number }>
If your DB returns Dates, serialize to ISO in the route (see §1).

6) Quick grep & cleanup
Replace any straggler dropdowns created inside the Observability page:

bash
Copy
Edit
rg -n "select|StandardDropdown|@radix-ui/react-select" src/pages/admin/observability
Remove/replace with the unified Dropdown.

Confirm no direct parseISO calls remain here:

bash
Copy
Edit
rg -n "parseISO|date-fns" src/pages/admin/observability
7) Sanity test (what you should see)
Open /admin/observability → page loads without errors.

Filters (Level/Env/Status) all use the same dropdown look/feel as the rest of the site.

Chart/list render even when the API returns missing or null dates (they will show “—” or skip those points).

No console errors; no error boundaries triggered.

provide a drop-in minimal chart snippet that consumes points: {x:number,y:number}[] in Recharts/ChartJS
