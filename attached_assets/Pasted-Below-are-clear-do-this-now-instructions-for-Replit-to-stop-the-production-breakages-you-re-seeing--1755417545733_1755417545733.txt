Below are clear, do-this-now instructions for Replit to stop the production breakages you’re seeing (missing columns like profile_address_id, onboarding_completed_at, old code artifacts, 500s on /api/user). This plan (1) detects schema drift, (2) applies safe hotfix migrations, (3) cleans builds so old code can’t run, and (4) adds guards so this never happens again.

A) Pin deployments to the exact database + branch

Verify DB URL(s) for every production deployment

Open Replit Secrets/Env for each prod repl / deployment.

Ensure only one database connection string is used (Neon recommended).

Set DATABASE_URL to the same Neon branch (e.g., prod), not main or a forked branch.

Remove any legacy envs like NEON_DB_URL, PG_URL, POSTGRES_URL if present to avoid accidental use.

Confirm at runtime

Add this log at server start (one line):

console.log("[BOOT] COMMIT:", process.env.APP_BUILD_ID, "DB:", process.env.DATABASE_URL?.slice(0, 32) + "…");


Set APP_BUILD_ID on each deploy (e.g., the current commit SHA) so logs prove which build is running against which DB.

B) Inspect the live DB to see what’s missing

Open a Replit shell connected to prod (or your local psql with the prod DATABASE_URL) and run:

-- Sanity: where are we?
select current_database(), current_user, version();

-- Do we have the columns the code expects?
select column_name, data_type 
from information_schema.columns 
where table_name='users'
  and column_name in ('profile_address_id','onboarding_completed_at')
order by column_name;

-- Drizzle migration state table (adjust if your table name differs)
select * from "drizzle__migrations" order by created_at desc limit 10;

-- Search for carts uniqueness issues (optional but recommended)
select indexname, indexdef 
from pg_indexes 
where tablename in ('cart_items','users');


If either column is missing → proceed with C).

C) Apply hotfix, backward-compatible migrations (no downtime)

These migrations add nullable columns so code can read/write immediately without breaking older rows.

Run these directly in prod (Neon SQL console or psql):

-- USERS TABLE HOTFIX
ALTER TABLE "users"
  ADD COLUMN IF NOT EXISTS "profile_address_id" uuid REFERENCES "addresses"("id") ON DELETE SET NULL,
  ADD COLUMN IF NOT EXISTS "onboarding_completed_at" timestamptz;

-- Helpful indexes (idempotent)
CREATE INDEX IF NOT EXISTS "idx_users_profile_address_id" ON "users"("profile_address_id");
CREATE INDEX IF NOT EXISTS "idx_users_onboarding_completed_at" ON "users"("onboarding_completed_at");

-- CART de-dup safety (choose the one that matches your schema):
-- If you have an explicit ownerId column:
-- CREATE UNIQUE INDEX IF NOT EXISTS "uniq_cart_owner_product"
-- ON "cart_items" (owner_id, product_id, COALESCE(variant_id, ''));
-- If you store user_id OR session_id (no ownerId), create a functional index:
-- CREATE UNIQUE INDEX IF NOT EXISTS "uniq_cart_owner_product_func"
-- ON "cart_items" (
--   COALESCE(user_id::text, session_id),
--   product_id,
--   COALESCE(variant_id, '')
-- );


If your Drizzle schema names differ, adapt the identifiers to match exactly (case-sensitive if quoted).

Record the hotfix in your migrations folder so Drizzle stays in sync:

Create a new SQL migration (e.g., drizzle/000XX_users_onboarding_profile.sql) with those ALTER TABLE/CREATE INDEX statements and commit it. This keeps future environments consistent.

D) Make the code resilient (nullable + default handling)

Schema file (shared/schema.ts)

Ensure both fields exist and are nullable:

export const users = pgTable("users", {
  // ...
  profileAddressId: uuid("profile_address_id").references(() => addresses.id).nullable(),
  onboardingCompletedAt: timestamp("onboarding_completed_at", { withTimezone: true }).nullable(),
});


Reads (server/auth, server/db storage)

Never select a non-existent column by name without migration guard. With Drizzle it’s safe once columns are declared nullable.

When using raw SQL anywhere, wrap optional selects:

-- example raw select pattern
SELECT
  u.id,
  u.email,
  u.profile_address_id,
  u.onboarding_completed_at
FROM users u
WHERE u.id = $1;


Avoid fallback queries that still select missing columns. Now that we added them, keep one select.

Writes

When setting onboarding_completed_at, always supply a value or leave NULL:

await db.update(users)
  .set({ onboardingCompletedAt: new Date() })
  .where(eq(users.id, userId));


Type usage

Anywhere in TS using the field: user.onboardingCompletedAt ?? null, not assumed Date.

E) Fix old code being served: clean build artifacts & lock the build

Ignore compiled output

In repo .gitignore, ensure:

dist
.next
build


Delete any committed dist/ folders from git history if present.

Add a clean step before build

package.json:

{
  "scripts": {
    "clean": "rimraf dist .turbo .next",
    "build": "npm run clean && tsc -b && vite build", // or your actual build
    "start": "node dist/server/index.js"
  }
}


npm i -D rimraf if not installed.

Stop stale processes

If using pm2 or background runners:

pm2 delete all || true


Start only the new build.

Log the build ID

Set APP_BUILD_ID=$(git rev-parse --short HEAD) in your deploy step/env.

On boot, log it (step A). Compare logs after deploy to confirm the correct build runs.

F) Add startup migration guard so drift can’t reach production

Run Drizzle migrations programmatically at server boot (safe, idempotent):

// server/db/migrate.ts
import { migrate } from "drizzle-orm/neon-http/migrator";
import { drizzle } from "drizzle-orm/neon-http";
import { neon } from "@neondatabase/serverless";

export async function runMigrations() {
  const sql = neon(process.env.DATABASE_URL!);
  const db = drizzle(sql);
  console.log("[MIGRATIONS] Applying…");
  await migrate(db, { migrationsFolder: "./drizzle" });
  console.log("[MIGRATIONS] Done.");
}


Then in your server bootstrap (before routes):

import { runMigrations } from "./db/migrate";

await runMigrations().catch((e) => {
  console.error("[MIGRATIONS] Failed:", e);
  process.exit(1); // fail fast if schema is wrong
});


This guarantees the app won’t start on a DB that’s missing required migrations.

G) Patch the /api/user 500s now

Those 500s are thrown during passport deserialize/getUser because the query references columns that weren’t there. After C/D/F:

Redeploy with clean build (E).

Hit /api/user again.

You should see 200 and no “Schema mismatch detected” logs.

H) CI guard (prevents future drift before deploy)

Add a GitHub Action (or Replit CI) that checks migrations on each PR:

name: DB Check
on: [pull_request]
jobs:
  migrate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - run: npm ci
      - run: npm run build --if-present
      - name: Drizzle Lint (compare schema to SQL)
        run: npx drizzle-kit check # or your preferred check


(If you don’t use drizzle-kit check, keep a small script that connects to a throwaway Neon branch, runs migrations, and exits non-zero on failure.)

I) Optional: “defensive” SQL for multi-version deploys

If you must roll out code before columns are guaranteed, add one-time defensive guards:

-- Example pattern to avoid selecting a missing column in raw SQL
-- (Use only temporarily; proper fix is migrations.)
SELECT
  u.id,
  u.email,
  CASE WHEN EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name='users' AND column_name='onboarding_completed_at'
  ) THEN u.onboarding_completed_at ELSE NULL END AS onboarding_completed_at
FROM users u
WHERE u.id = $1;


But again, prefer the migration-first approach above.

J) Smoke tests (run after redeploy)

Columns exist

select profile_address_id, onboarding_completed_at from users limit 1;


Auth endpoints

GET /api/user → 200 (unauthenticated shape is fine).

Login → 200 → then GET /api/user returns user JSON with nullable fields.

Products/featured

GET /api/products/featured → 200.

Cart sanity (optional)

Add → Get → Delete for the same product. No duplicate rows (unique index enforces).

Summary

You’re seeing schema drift: code expects users.profile_address_id and users.onboarding_completed_at, but prod DB didn’t have them.

Fix now: run the hotfix SQL, make fields nullable, clean rebuild, and start with migrations at boot.

Prevent repeat: CI migration check + single source DB URL + logging build ID at boot.

If you paste back the results of the inspection queries from section B (column lists + drizzle__migrations rows), I’ll tailor the exact Drizzle migration file to your repo’s naming and confirm indexes match your current cart and users schema.