0) Goals
Selection works everywhere (click → onChange → parent state updates → label updates).

Placeholder appears translucent like other inputs (not solid white), regardless of global CSS.

One dropdown implementation only at src/components/ui/Dropdown.tsx.

Delete all unused/duplicate dropdown code & CSS.

Keep SearchBar untouched.

1) Replace the dropdown with a hardened, type-safe version
This version fixes the two reported issues:

Selection not updating (value normalization + RHF adapter + event-proof onChange).

Placeholder too white (stronger specificity + inline style fallback to defeat legacy CSS).

tsx
Copy
Edit
// src/components/ui/Dropdown.tsx
import { useState, useRef, useEffect, useCallback } from "react";
import { createPortal } from "react-dom";
import { ChevronDown } from "lucide-react";

export interface DropdownOption {
  label: string;
  value: string; // we standardize on strings
}

interface DropdownProps {
  options: DropdownOption[];
  value: string | null;                 // controlled value only
  onChange: (value: string) => void;    // MUST accept a string
  placeholder?: string;
  className?: string;
  menuClassName?: string;
  id?: string;
  name?: string;
  disabled?: boolean;
}

function normalize(v: unknown): string | null {
  if (v === null || v === undefined) return null;
  return String(v).trim();
}

export default function Dropdown({
  options,
  value,
  onChange,
  placeholder = "Select...",
  className = "",
  menuClassName = "",
  id,
  name,
  disabled = false,
}: DropdownProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [menuPos, setMenuPos] = useState<{ left: number; top: number; width: number }>({ left: 0, top: 0, width: 0 });
  const rootRef = useRef<HTMLDivElement>(null);
  const buttonRef = useRef<HTMLButtonElement>(null);
  const menuRef = useRef<HTMLDivElement>(null);

  // Normalize both current value and options
  const current = normalize(value);
  const normalizedOptions = options.map(o => ({ label: o.label, value: normalize(o.value)! }));
  const selectedOption = normalizedOptions.find(opt => opt.value === current) ?? null;

  // Close on outside click
  useEffect(() => {
    const handleOutside = (e: MouseEvent) => {
      if (rootRef.current && !rootRef.current.contains(e.target as Node)) setIsOpen(false);
    };
    if (isOpen) {
      document.addEventListener("mousedown", handleOutside);
      return () => document.removeEventListener("mousedown", handleOutside);
    }
  }, [isOpen]);

  // Position menu (prevents clipping)
  const updateMenuPos = useCallback(() => {
    const el = buttonRef.current;
    if (!el) return;
    const r = el.getBoundingClientRect();
    setMenuPos({ left: r.left + window.scrollX, top: r.bottom + window.scrollY + 6, width: r.width });
  }, []);

  useEffect(() => {
    if (!isOpen) return;
    updateMenuPos();
    const onScroll = () => updateMenuPos();
    const onResize = () => updateMenuPos();
    window.addEventListener("scroll", onScroll, true);
    window.addEventListener("resize", onResize, true);
    return () => {
      window.removeEventListener("scroll", onScroll, true);
      window.removeEventListener("resize", onResize, true);
    };
  }, [isOpen, updateMenuPos]);

  // Minimal keyboard navigation
  useEffect(() => {
    if (!isOpen) return;
    const handler = (e: KeyboardEvent) => {
      const items = Array.from(menuRef.current?.querySelectorAll<HTMLButtonElement>("[data-option]") ?? []);
      const idx = Math.max(0, items.findIndex((n) => n === document.activeElement));
      if (e.key === "Escape") setIsOpen(false);
      if (e.key === "ArrowDown") { e.preventDefault(); (items[idx + 1] ?? items[0])?.focus(); }
      if (e.key === "ArrowUp")   { e.preventDefault(); (items[idx - 1] ?? items[items.length - 1])?.focus(); }
      if (e.key === "Enter")     { (document.activeElement as HTMLButtonElement | null)?.click(); }
    };
    document.addEventListener("keydown", handler);
    return () => document.removeEventListener("keydown", handler);
  }, [isOpen]);

  const empty = !selectedOption;

  return (
    <div ref={rootRef} className={`relative ${className}`}>
      <button
        ref={buttonRef}
        id={id}
        name={name}
        type="button"
        disabled={disabled}
        onClick={() => setIsOpen((o) => !o)}
        data-empty={empty ? "true" : "false"}
        className={[
          "flex items-center justify-between w-full",
          "px-3 py-2 text-sm rounded-md",
          "border border-white/10",
          "bg-slate-800/70 hover:bg-slate-800",
          "focus:outline-none focus:ring-2 focus:ring-blue-500/60",
          disabled ? "opacity-60 cursor-not-allowed" : "",
          // fallback: if global CSS forces text-white, we ensure placeholder opacity with higher specificity below
        ].join(" ")}
        aria-haspopup="listbox"
        aria-expanded={isOpen}
      >
        <span
          className={empty ? "cf-placeholder" : "text-slate-100"}
          // hard override in case global CSS uses !important:
          style={empty ? { color: "rgba(255,255,255,0.45)" } : undefined}
        >
          {selectedOption?.label ?? placeholder}
        </span>
        <ChevronDown className={`w-4 h-4 ${empty ? "text-white/60" : "text-slate-300"} transition-transform ${isOpen ? "rotate-180" : ""}`} />
      </button>

      {isOpen &&
        createPortal(
          <div
            ref={menuRef}
            role="listbox"
            style={{ position: "absolute", left: menuPos.left, top: menuPos.top, width: menuPos.width, zIndex: 60 }}
            className={[
              "rounded-md border border-white/10",
              "bg-[#121822]/95 backdrop-blur",
              "shadow-xl shadow-black/30",
              "max-h-60 overflow-auto",
              "animate-[fadeIn_120ms_ease-out]",
              menuClassName || "",
            ].join(" ")}
            onMouseDown={(e) => {
              // Prevent parent focus/blur races in some forms:
              e.preventDefault();
            }}
          >
            {normalizedOptions.map((option) => {
              const isSelected = option.value === current;
              return (
                <button
                  key={option.value}
                  type="button"
                  role="option"
                  aria-selected={isSelected}
                  data-option
                  onClick={() => {
                    // robust: always send a clean string
                    onChange(option.value);
                    setIsOpen(false);
                  }}
                  className={[
                    "w-full px-3 py-2 text-sm text-left transition-colors",
                    isSelected ? "bg-blue-500/10 text-blue-300" : "text-slate-100 hover:bg-white/5",
                  ].join(" ")}
                >
                  {option.label}
                </button>
              );
            })}
          </div>,
          document.body
        )}
    </div>
  );
}
Why this fixes your two issues:

Selection “does nothing” is usually a type/normalization or RHF adapter issue. We normalize both the prop and every option value (trim() + String()), and we call onChange(option.value) with a guaranteed string. If a parent was passing numbers/undefined, this removes the mismatch.

Placeholder opacity defeats global text-white overrides using:

a dedicated class .cf-placeholder,

data-empty attribute (for CSS specificity),

and inline style as last-resort.

Add the tiny CSS helper (stronger than most legacy rules, low risk):

css
Copy
Edit
/* src/styles/dropdown-fixes.css */
button[data-empty="true"] .cf-placeholder {
  color: rgba(255,255,255,0.45) !important; /* beats legacy !important */
}
Import once (e.g., in src/index.css or your global styles).

2) Fix all call-sites (this is where selection usually breaks)
Enforce strings at the edges
Wherever we build options, stringify IDs:

ts
Copy
Edit
// BEFORE (bug-prone if id is number)
const options = categories.map(c => ({ label: c.name, value: c.id }));

// AFTER
const options = categories.map(c => ({ label: c.name, value: String(c.id) }));
Controlled values
Every dropdown must have a state value and setState handler:

tsx
Copy
Edit
const [category, setCategory] = useState<string | null>(null);
<Dropdown value={category} onChange={setCategory} options={options} />
React Hook Form (this is the #1 “click does nothing” culprit)
Replace ad-hoc wiring with our adapter:

tsx
Copy
Edit
// Use this everywhere you integrate with RHF
// src/components/ui/RHFDropdown.tsx
import { Controller, Control, FieldValues, Path } from "react-hook-form";
import Dropdown, { DropdownOption } from "./Dropdown";

type Props<T extends FieldValues> = {
  control: Control<T>;
  name: Path<T>;
  options: DropdownOption[];
  placeholder?: string;
  className?: string;
};

export function RHFDropdown<T extends FieldValues>({ control, name, options, placeholder, className }: Props<T>) {
  return (
    <Controller
      control={control}
      name={name}
      render={({ field }) => (
        <Dropdown
          value={field.value == null ? null : String(field.value)}
          onChange={(v) => field.onChange(v)}  // <-- not an event, just the string
          options={options}
          placeholder={placeholder}
          className={className}
        />
      )}
    />
  );
}
Search & replace any RHF usage that expected (e) => onChange(e.target.value) and switch to the adapter.

No mixed types anywhere
Audit and fix all sites that pass numbers/booleans:

bash
Copy
Edit
# Find likely offenders
rg -n "<Dropdown[^>]*value=\{[^}]*\}" src
rg -n "value:\s*\d+(\s*[,}])" src
Update to strings.

Prevent parent handlers from swallowing clicks
If a parent has an onClick on the container, ensure it doesn’t block menu items. Our menu now uses onMouseDown(e => e.preventDefault()) to prevent blur/submit races. Keep your item buttons as type="button".

3) Delete duplicates and conflicting CSS (for real)
After call-sites are fixed:

bash
Copy
Edit
# List all “other dropdowns”
rg -n "(UnifiedDropdown|StandardDropdown|DropdownMenu|@radix-ui/react-select|HeadlessUI|Listbox|select.tsx)" src

# Remove now-unused components/wrappers
git rm -f src/components/UnifiedDropdown.tsx 2>/dev/null || true
git rm -f src/components/StandardDropdown.tsx 2>/dev/null || true
git rm -f src/components/dropdown-menu.tsx 2>/dev/null || true
git rm -f src/components/ui/select.tsx 2>/dev/null || true

# CSS (keep only dropdown-fixes.css you just added)
git rm -f src/styles/dropdown.css 2>/dev/null || true
git rm -f src/styles/simple-dropdown.css 2>/dev/null || true
git rm -f src/styles/dropdown-theme.css 2>/dev/null || true
Block reintroduction via ESLint:

js
Copy
Edit
// .eslintrc.cjs
module.exports = {
  rules: {
    "no-restricted-imports": [
      "error",
      {
        paths: [
          { name: "@radix-ui/react-select", message: "Use src/components/ui/Dropdown instead." },
          { name: "headlessui", message: "Use src/components/ui/Dropdown instead." },
          { name: "@/components/UnifiedDropdown", message: "Use src/components/ui/Dropdown instead." },
          { name: "@/components/StandardDropdown", message: "Use src/components/ui/Dropdown instead." },
          { name: "@/components/dropdown-menu", message: "Use src/components/ui/Dropdown instead." },
          { name: "@/components/ui/select", message: "Use src/components/ui/Dropdown instead." },
        ],
      },
    ],
  },
};
4) Smoke tests (do these quickly)
Contact & Sell-to-Us: pick values → label updates instantly; placeholder shows translucently beforehand.

Admin filters (Products/Categories/Users/etc.): all option values are strings; selection drives state and fetches.

Navbar user menu (if it uses dropdown): same component, no clipping behind cards.

No console warnings about controlled/uncontrolled inputs or invalid onChange event objects.

5) If selection still doesn’t update on a specific page…
That page is almost certainly:

Passing a number to value, or

Using RHF and expecting an event, or

Keeping two sources of truth (e.g., local state + form state).

Fix by:

Casting to String(...) at the top where you build options/values.

Using the RHFDropdown adapter shown above.

Removing the duplicate local state and relying on one controlled value.

Add a temporary assertion while testing:

tsx
Copy
Edit
// At the call-site
console.debug("Dropdown debug", { valueType: typeof value, value, options });
You should see valueType: "string" and an option with the same string.

6) Placeholder consistency vs. global CSS
If any global/legacy CSS still forces white text, our three-layer approach (data-attr class + inline style + fixes.css) wins. Keep dropdown-fixes.css imported globally so placeholders always appear semi-transparent until a real value is chosen.

Follow this verbatim and you’ll get:

Reliable selection behavior across all pages and forms,

Proper translucent placeholders matching your other fields,

One clean dropdown implementation and no duplicate/legacy code left behind.