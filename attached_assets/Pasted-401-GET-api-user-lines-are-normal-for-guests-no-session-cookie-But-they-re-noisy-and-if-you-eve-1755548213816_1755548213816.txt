401 GET /api/user lines are normal for guests (no session cookie). But they’re noisy, and if you ever see them after a successful login then something’s misconfigured. Below is a clean plan for Replit that (a) keeps security correct, (b) reduces noise, and (c) prevents accidental 401 loops.

What Replit should change (copy/paste tasks)
1) Make /api/user guest-safe (no hard 401 for anonymous)

Return a 200 with {auth:false} instead of 401 when there’s no session. Keep true 401s for protected/admin endpoints only.

// before: res.status(401).json({error:'Not authenticated'})
app.get('/api/user', async (req, res) => {
  const hasSession = !!req.session?.userId;
  if (!hasSession) {
    // Guest-safe response
    return res.status(200).json({ auth: false, user: null });
  }
  // ...lookup and return the user
  res.json({ auth: true, user: {/* ... */} });
});


Benefits:

No scary WARN logs during normal browsing.

Frontend can render instantly (no error path) for logged-out users.

If you prefer to keep 401 semantics: do both 1) and 2) below, but keep the route returning 401. The rest of this plan still applies.

2) Tame the logs: 401 on expected paths → INFO (not WARN)

Add a tiny logger wrapper that demotes 401 on “expected anonymous” endpoints (e.g., /api/user if you keep it 401, /api/cart peek, etc).

const EXPECTED_ANON_401 = new Set(['/api/user']);
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const ms = Date.now() - start;
    if (res.statusCode === 401 && EXPECTED_ANON_401.has(req.path) && !req.session?.userId) {
      console.info(`[INFO] ${req.method} ${req.path} 401 ${ms}ms (guest)`);
      return;
    }
    // your normal logger here
  });
  next();
});

3) Frontend: stop refetch loops & always send cookies

If you keep 401s, React Query can spin. Even with 200/guest, it’s good to set sane query options:

// client/src/lib/queryClient.ts (or your fetcher)
const res = await fetch(apiUrl('/api/user'), { credentials: 'include' });

// react-query options for the user query
useQuery({
  queryKey: ['user'],
  queryFn: fetchUser,
  refetchOnWindowFocus: false,
  retry: (count, err: any) => {
    const status = err?.status ?? err?.response?.status;
    // Don’t retry unauth; retry only server errors
    return status >= 500 && count < 2;
  },
});

4) Cookie/CORS checklist (prod vs dev)

These four switches are the usual cause of “unexpected 401 after login”:

Server

app.set('trust proxy', 1);

const isProd = APP_ENV === 'production';
app.use(cors({
  origin: isProd ? CORS_ORIGINS /* exact prod origins */ : CORS_ORIGINS, // dev list
  credentials: true,
}));

app.use(session({
  // connect-pg-simple store...
  secret: SESSION_SECRET,
  name: 'cf.sid',
  resave: false,
  saveUninitialized: false,
  cookie: {
    path: '/',
    httpOnly: true,
    secure: isProd,                 // ✅ secure only in prod
    sameSite: isProd ? 'none' : 'lax', // ✅ 'none' only in prod
    domain: isProd ? SESSION_COOKIE_DOMAIN : undefined, // ✅ no domain in dev
    maxAge: 7 * 24 * 60 * 60 * 1000,
  },
}));


Client

Always: { credentials: 'include' }

Prefer relative API URLs in preview/dev (prevents third-party cookie issues).

If using OAuth: use redirect (top-level nav) not popup, so cookies are first-party on return.

5) Add an explicit auth-state endpoint (optional but nice)

This makes the pattern crystal clear: never 401, just tell the UI if it’s logged in.

app.get('/api/auth/state', (req, res) => {
  if (!req.session?.userId) return res.json({ auth: false });
  res.json({ auth: true });
});


Then the UI can check auth first and only query /api/user when auth:true.

6) Public health endpoints (no auth)

You already saw /health returning 401. Ensure your health routes are mounted before any auth gate and are public:

app.get('/api/healthz', async (_req, res) => {
  const r = await pool.query('select current_database() as db');
  res.json({ ok: true, env: APP_ENV, db: r.rows[0]?.db });
});
app.get('/health', (_req, res) => res.redirect(307, '/api/healthz'));
app.get('/api/admin/system/health', (_req, res) => res.redirect(307, '/api/healthz'));

7) Instrument why users are 401 (for real)

When a 401 actually happens outside the expected guest places, print the cause, not just a code. This prevents wild goose chases.

app.use((req, res, next) => {
  const end = res.end;
  (res as any).end = function (...args: any[]) {
    if (res.statusCode === 401) {
      console.warn('[AUTH]', {
        path: req.path,
        hasCookie: Boolean(req.headers.cookie),
        hasSession: Boolean(req.session?.userId),
        origin: req.headers.origin,
        referer: req.headers.referer,
      });
    }
    return end.apply(this, args as any);
  };
  next();
});

What’s “normal” vs “not normal”

Normal

A guest hits your site → /api/user returns 200 {auth:false} (with the change above) or 401 if you keep old semantics.

Your logs show INFO (not WARN) for that path.

Not normal

A user just logged in and /api/user still returns 401 (or {auth:false}) on subsequent requests → cookie/CORS issue. Re-check §4.

The browser Network tab shows your Set-Cookie coming back from login but not sent on the next /api/user → wrong domain, SameSite, or missing credentials:'include'.

Quick acceptance tests Replit should run

Logged-out page view

/api/user → 200 {auth:false} (or 401 if you keep it)

No WARN logs for this path.

Login flow

Complete login (email/google).

Next request to /api/user → 200 {auth:true, user:…}.

Network shows cf.sid cookie sent.

CORS/cookie flags

In prod, Set-Cookie has Secure; SameSite=None; Domain=.yourprod.com.

In dev/preview, no Domain, SameSite=Lax, not Secure.

Health

/health and /api/healthz → 200 JSON without auth.

TL;DR for Replit

Change /api/user to return 200 + {auth:false} for guests (or keep 401 but demote logging to INFO on that known path).

Ensure relative API calls + credentials:'include' everywhere.

Confirm cookie flags per env (prod: Secure+None; dev: Lax and no domain).

Make health endpoints public and mounted early.

Add logging that prints why a 401 happened (cookie present? session present?).