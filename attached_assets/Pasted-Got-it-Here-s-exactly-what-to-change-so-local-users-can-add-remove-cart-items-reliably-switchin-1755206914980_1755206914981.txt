Got it. Here’s exactly what to change so:

local users can add/remove cart items reliably,

switching a default address from local → non-local auto-purges LOCAL-ONLY items,

non-local users are clearly blocked from “Sell to Us,”

and responses are always JSON (no more “Unexpected token <” toasts).

1) Fix cart delete: delete by userId + productId (not by item id)
Your logs show:

csharp
Copy
Edit
[STORAGE] Deleting cart item with ID: 9e43...de b3
[STORAGE] Delete result - rowCount: 0
That means the delete was using the productId as a row id and didn’t match anything. Make deletion key off user_id and product_id.

If you’re using Prisma (recommended)
server/storage/index.ts

ts
Copy
Edit
export async function removeCartItem(userId: string, productId: string) {
  const { count } = await prisma.cartItem.deleteMany({
    where: { userId, productId },
  });
  return { count };
}
If you’re using pg directly
server/storage/index.ts

ts
Copy
Edit
export async function removeCartItem(userId: string, productId: string) {
  const { rowCount } = await pool.query(
    'DELETE FROM cart_items WHERE user_id=$1 AND product_id=$2',
    [userId, productId]
  );
  return { rowCount };
}
Route must pass both values to storage
server/routes/cart.v2.ts

ts
Copy
Edit
cartV2.delete('/items/:productId', async (req, res, next) => {
  try {
    const userId = req.session?.user?.id as string;
    if (!userId) return res.status(401).json({ ok:false, code:'AUTH_REQUIRED', message:'Sign in required' });

    const { productId } = req.params;
    const result = await storage.removeCartItem(userId, productId);

    const removed = (result as any).count ?? (result as any).rowCount ?? 0;
    return res.status(200).json({ ok: true, removed });
  } catch (err) { next(err); }
});
Client stays the same; it already expects { ok: true, removed }. (If you haven’t yet, keep the “parseJsonSafe” guard we added earlier.)

2) Auto-purge LOCAL-ONLY items when user becomes non-local
When a user changes their default address and the new default is out of zone, remove any LOCAL-ONLY products from their cart immediately.

Shared: a tiny helper
server/services/cartCleanup.ts

ts
Copy
Edit
import { prisma } from '../db/prisma';
import { modeFromProduct } from '../../shared/fulfillment';

export async function purgeLocalOnlyItemsIfIneligible(userId: string) {
  // pull cart with product join
  const items = await prisma.cartItem.findMany({
    where: { userId },
    include: { product: true },
  });

  const localOnlyIds = items
    .filter(i => modeFromProduct(i.product) === 'LOCAL_ONLY')
    .map(i => i.productId);

  if (localOnlyIds.length === 0) return { removed: 0 };

  const { count } = await prisma.cartItem.deleteMany({
    where: { userId, productId: { in: localOnlyIds } },
  });

  return { removed: count };
}
When default address changes, recalc locality and purge
(Adjust to your existing addresses router/handler.)

server/routes/addresses.ts

ts
Copy
Edit
addresses.put('/:id/default', async (req, res, next) => {
  try {
    const userId = req.session?.user?.id as string;
    if (!userId) return res.status(401).json({ ok:false, code:'AUTH_REQUIRED' });

    const addressId = req.params.id;

    // 1) Set this address as default for the user
    await prisma.$transaction([
      prisma.address.updateMany({ where: { userId }, data: { isDefault: false } }),
      prisma.address.update({ where: { id: addressId }, data: { isDefault: true } }),
    ]);

    // 2) Re-evaluate locality for the NEW default
    const addr = await prisma.address.findUnique({ where: { id: addressId } });
    const status = await evaluateLocalityFromAddress(addr); // returns { eligible: boolean }

    // 3) If now non-local, purge LOCAL_ONLY cart items
    let purged = 0;
    if (!status.eligible) {
      const r = await purgeLocalOnlyItemsIfIneligible(userId);
      purged = r.removed;
    }

    return res.json({ ok:true, defaultAddressId: addressId, locality: status, purgedLocalItems: purged });
  } catch (err) { next(err); }
});
Client: after you hit “Make Default” (or save), if the response includes purgedLocalItems > 0, show a toast like “Removed X local-only items that can’t be delivered to your new address.” and refetch /api/cart.

3) Block “Sell to Us” for non-local users (clear UI)
src/pages/sell-to-us.tsx

tsx
Copy
Edit
import { AlertTriangle } from "lucide-react";
import { Link } from "wouter";
import { useLocality } from "@/hooks/useLocality";
import { Button } from "@/components/ui/button";

export default function SellToUsPage() {
  const { locality } = useLocality(); // { eligible:boolean, zip?:string, source?:string }

  if (!locality?.eligible) {
    return (
      <div className="mx-auto max-w-3xl p-6">
        <div className="rounded-2xl border border-red-300/40 bg-red-50/50 p-6">
          <div className="flex items-start gap-3">
            <AlertTriangle className="mt-1 h-5 w-5" />
            <div>
              <h2 className="text-lg font-semibold">Unavailable in your area</h2>
              <p className="mt-1 text-sm text-muted-foreground">
                “Sell to Us” is only available for local pickup & delivery in our Asheville service area.
                Set a local default address to continue.
              </p>
              <div className="mt-4 flex gap-3">
                <Button asChild>
                  <Link href="/dashboard#addresses">Set a local address</Link>
                </Button>
                <Button variant="outline" asChild>
                  <Link href="/about">See service area</Link>
                </Button>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // ... existing form UI for eligible users
}
(Optionally also gray out/hide the “Sell” link in the navbar for non-local users, but the hard block above is the important part.)

4) Keep cart add path locality enforcement (already working)
Leave the cart POST guard in place:

ts
Copy
Edit
if (mode === 'LOCAL_ONLY' && !status.eligible) {
  return res.status(403).json({ ok:false, code:'LOCAL_ONLY_NOT_ELIGIBLE', ... });
}
This + the new purge on address change keeps the cart consistent at all times.

5) Ensure all errors are JSON
Make sure your JSON error middleware is the last app.use(...):

ts
Copy
Edit
app.use(jsonErrorHandler); // after all routers
That prevents the client from ever trying to res.json() an HTML error page.

6) Quick test script (what Replit should run)
Sign in, ensure default address is local → add LOCAL-ONLY item → remove it → ✅ removed: 1, disappears from cart.

Add LOCAL-ONLY item while local → change default address to a non-local ZIP → response returns purgedLocalItems: N → cart refetch shows it’s gone.

Visit /sell-to-us as non-local → see the red “Unavailable in your area” block and the form is not rendered.

Make any server route throw → client toast shows JSON message, no parse error.

