single, full-stack punch list for Replit that fixes the address/checkout/add-to-cart mess, removes legacy code, and hardens the flow end-to-end. I also call out what your server logs are telling us and where the current crashes come from.

What the logs + UI errors tell us (root causes)
Checkout crashes while reading addresses

Cannot destructure property 'defaultAddress' of 'useDefaultAddress(...)' as it is null

Cannot read properties of undefined (reading 'map')
→ Hook sometimes returns null / undefined before data is loaded. Components aren’t guarding initial “loading/empty” states.

Cart page crash

Cannot read properties of undefined (reading 'length') in cart.tsx:97
→ UI expects cart.items (or lineItems) but receives undefined. Needs safe defaults & an adapter.

“Add to cart” regression

“failed to find mutation” and the old green/hover-to-remove UX is gone.
→ Button is still importing a legacy hook/mutation key after we moved cart API. State not invalidated against the new cart query key.

Onboarding gate still blocks

Middleware: [MIDDLEWARE] Blocking incomplete profile access: ... path: '/api/orders' even after you set a default address.
→ Rules compute “complete” from stale fields; gate isn’t reading the SSOT address table.

Observability noise

/api/observability/errors 400 spam every few seconds.
→ Client sends a payload your endpoint doesn’t accept. Disable in dev or accept minimum payload.

Geoapify autocomplete not filling
→ Selection handler doesn’t map properties to our SSOT fields and it leaves city/state/zip blank.

Default address not obvious / not enforced

No “Default” badge, cannot delete, can’t set first address as default automatically, duplicate defaults possible.

Shipping options empty

No quote call after an address is selected, and distance calc needs miles not km.

Backend: database + API fixes (SSOT)
1) Enforce “one default per user”
SQL migration

sql
Copy
Edit
-- Add default flag
ALTER TABLE user_addresses
  ADD COLUMN IF NOT EXISTS is_default BOOLEAN NOT NULL DEFAULT FALSE;

-- At most one default per user
CREATE UNIQUE INDEX IF NOT EXISTS uniq_default_address_per_user
  ON user_addresses(user_id)
  WHERE is_default;

-- Backfill: make the earliest address default when a user has none
WITH firsts AS (
  SELECT DISTINCT ON (user_id) id
  FROM user_addresses
  ORDER BY user_id, created_at ASC
)
UPDATE user_addresses ua
SET is_default = TRUE
FROM firsts f
WHERE ua.id = f.id
  AND NOT EXISTS (
    SELECT 1 FROM user_addresses u2
    WHERE u2.user_id = ua.user_id AND u2.is_default = TRUE
  );
2) Address endpoints (authoritative contracts)
GET /api/addresses →

json
Copy
Edit
{ "addresses":[...], "defaultAddressId":"uuid-or-null" }
POST /api/addresses → creates an address; if user has none, set is_default = true.

POST /api/addresses/:id/default → in a transaction: set is_default=true for :id and false for all other addresses of this user. Return updated list.

DELETE /api/addresses/:id

If address is_default=true, 400: "Cannot delete default address".

Otherwise delete.

GET /api/user/locality (or compute inline)

Returns { isLocal: boolean, distanceMiles: number } for the current default address vs warehouse.

3) Shipping quotes (miles!)
POST /api/shipping/quote
Payload:

json
Copy
Edit
{ "addressId":"uuid" } // OR full address object if using "new address" path
Response examples:

json
Copy
Edit
{
  "methods":[
    {"code":"LOCAL", "label":"Local delivery (≤50 miles)", "cost":0, "eta":"24–48h"},
    {"code":"PICKUP", "label":"Pickup at warehouse", "cost":0}
  ]
}
or fallback:

json
Copy
Edit
{ "methods":[ {"code":"FREIGHT_TBD", "label":"Freight shipping (quoted after order)", "cost":null} ] }
Distance util (miles, not km):

ts
Copy
Edit
export function haversineMiles(a:{lat:number;lon:number}, b:{lat:number;lon:number}) {
  const R = 3958.7613; // miles
  const dLat = (b.lat - a.lat) * Math.PI/180;
  const dLon = (b.lon - a.lon) * Math.PI/180;
  const lat1 = a.lat * Math.PI/180;
  const lat2 = b.lat * Math.PI/180;
  const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(h));
}
4) Onboarding gate reads SSOT
Update the middleware to:

ts
Copy
Edit
const hasDefaultAddress = await db
  .select().from(user_addresses)
  .where({ user_id: req.user.id, is_default: true })
  .first();

req.user.profileComplete = Boolean(hasDefaultAddress); // plus any other required fields
Stop checking legacy user columns.

5) Accept error reports or disable in dev
Either:

Implement a tolerant dev handler:

ts
Copy
Edit
app.post('/api/observability/errors', (req,res)=> res.sendStatus(204));
or gate the client sender with if (NODE_ENV==='production').

Frontend: kill the legacy, wire the new
1) Replace all usages of old checkout/cart modules
Remove/rename legacy files:
src/pages/checkout.tsx, checkout-new.tsx, components/cart/* that aren’t used.
Route /checkout → src/pages/checkout-simple.tsx (the new one below).

Search & remove imports of old hooks (useDefaultAddress v1, old mutation keys, old cart selectors). One source of the “failed to find mutation” error is components still importing stale hooks.

2) Safe address hook (no more null destructures)
ts
Copy
Edit
// src/hooks/use-addresses.ts
import {useQuery, useMutation, useQueryClient} from '@tanstack/react-query';

export function useAddresses() {
  const qc = useQueryClient();

  const {data, isLoading, isFetching, error} = useQuery({
    queryKey: ['addresses'],
    queryFn: async () => (await fetch('/api/addresses')).json(),
    staleTime: 60_000,
  });

  const addresses = data?.addresses ?? [];
  const defaultAddress = addresses.find(a => a.is_default) ?? null;
  const defaultAddressId = data?.defaultAddressId ?? defaultAddress?.id ?? null;

  const setDefault = useMutation({
    mutationKey: ['addresses:setDefault'],
    mutationFn: async (id: string) => {
      const r = await fetch(`/api/addresses/${id}/default`, {method: 'POST'});
      if (!r.ok) throw new Error('Failed to set default address');
    },
    onSuccess: () => qc.invalidateQueries({queryKey: ['addresses']})
  });

  const remove = useMutation({
    mutationKey: ['addresses:remove'],
    mutationFn: async (id: string) => {
      const r = await fetch(`/api/addresses/${id}`, {method: 'DELETE'});
      if (!r.ok) throw new Error('Delete failed');
    },
    onSuccess: () => qc.invalidateQueries({queryKey: ['addresses']})
  });

  return {addresses, defaultAddress, defaultAddressId, isLoading, isFetching, error, setDefault, remove};
}
Usage: never destructure defaultAddress without null-checks.

3) Checkout page behavior (read-only for saved; editable for “new”)
Three modes: default (auto), saved, new.

On mount: load addresses; if a default exists → select it and lock the fields (read-only).

“Choose saved…” opens a dialog listing all saved addresses with a Default badge. Selecting one sets it as the shipping address (still read-only).

“Use new address” switches to the full AddressForm (editable). Submitting can optionally save to profile.

When a shipping address is selected/changed, call /api/shipping/quote and show methods.

Read-only block example

tsx
Copy
Edit
// src/components/checkout/AddressBlock.tsx
function AddressBlock({address, onChange, onManage}:{...}) {
  return (
    <div className="rounded-2xl border p-4 bg-gray-900/40">
      <div className="flex items-center gap-3">
        <span className="i-lucide-map-pin" />
        <div className="flex-1">
          <div className="font-semibold">{address.label ?? `${address.first_name} ${address.last_name}`}</div>
          <div className="text-sm opacity-80">
            {address.street}, {address.city}, {address.state} {address.zip} {address.country_code?.toUpperCase()}
          </div>
          {address.is_default && <span className="ml-1 rounded bg-blue-600/20 text-blue-300 text-xs px-2 py-0.5">Default</span>}
        </div>
        <button className="btn btn-ghost" onClick={onChange}>
          <span className="i-lucide-pencil" /> Change
        </button>
        <button className="btn btn-ghost" onClick={onManage}>Manage</button>
      </div>
    </div>
  );
}
4) Geoapify → form fill (all fields, miles)
ts
Copy
Edit
// src/components/ui/address-autocomplete.tsx (onSelect)
const p = feature.properties;
setValue('street', [p.housenumber, p.street].filter(Boolean).join(' ').trim());
setValue('city', p.city || p.town || p.village || p.county || '');
setValue('state', p.state_code || p.state || '');
setValue('zip', p.postcode || '');
setValue('country_code', (p.country_code || 'US').toUpperCase());
setValue('lat', p.lat);
setValue('lon', p.lon);
trigger(['street','city','state','zip']);
5) Add-to-Cart button (restore the green/hover-remove UX)
Single source of truth for cart keys

ts
Copy
Edit
// src/lib/cartKeys.ts
export const CART_QK = ['cart'];
export const ADD_MUTATION_KEY = ['cart:add'];
export const REMOVE_MUTATION_KEY = ['cart:remove'];
Button logic

tsx
Copy
Edit
// src/components/AddToCartButton.tsx
import {useQueryClient, useMutation} from '@tanstack/react-query';
import {CART_QK, ADD_MUTATION_KEY, REMOVE_MUTATION_KEY} from '@/lib/cartKeys';

export default function AddToCartButton({productId}:{productId:string}) {
  const qc = useQueryClient();
  const cart = (qc.getQueryData(CART_QK) as any) ?? {items: []};
  const inCart = !!cart.items?.some((i:any)=> i.productId === productId);

  const add = useMutation({
    mutationKey: ADD_MUTATION_KEY,
    mutationFn: async () => {
      const r = await fetch('/api/cart/items', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({productId, qty:1})});
      if (!r.ok) throw new Error('Add failed');
    },
    onSuccess: () => qc.invalidateQueries({queryKey: CART_QK})
  });

  const remove = useMutation({
    mutationKey: REMOVE_MUTATION_KEY,
    mutationFn: async () => {
      const r = await fetch(`/api/cart/items/${productId}`, {method:'DELETE'});
      if (!r.ok) throw new Error('Remove failed');
    },
    onSuccess: () => qc.invalidateQueries({queryKey: CART_QK})
  });

  if (inCart) {
    return (
      <div className="relative group">
        <button className="btn bg-green-600 hover:bg-green-700 w-full">In Cart</button>
        <button
          title="Remove from cart"
          onClick={() => remove.mutate()}
          className="absolute -right-2 -top-2 hidden group-hover:flex h-7 w-7 items-center justify-center rounded-full bg-red-600 text-white">
          ×
        </button>
      </div>
    );
  }
  return <button className="btn bg-blue-600 hover:bg-blue-700 w-full" onClick={()=>add.mutate()}>Add to Cart</button>;
}
Cart adapter + guard

ts
Copy
Edit
// src/api/cart.ts (client)
export function useCart() {
  return useQuery({
    queryKey: CART_QK,
    queryFn: async () => (await fetch('/api/cart')).json(),
    select: (raw:any) => {
      const items = raw?.items ?? raw?.lineItems ?? [];
      const subtotal = raw?.subtotal ?? items.reduce((s:any,i:any)=> s + (i.price||0)*(i.qty||1), 0);
      return {items, subtotal};
    }
  });
}
And in cart.tsx, ALWAYS const items = cart?.items ?? []; before .length.

6) Profile → addresses panel
Show a “Default” badge on the default card.

“Make Default” button calls POST /api/addresses/:id/default.

Delete icon only for non-default addresses; default shows disabled trash with tooltip “Cannot delete default address”.

After any action, invalidateQueries(['addresses']).

7) Checkout order summary always renders
Don’t depend on cart structure specifics. Use the useCart() select adapter above.

Render a skeleton while loading; render empty state if items.length===0.

8) Shipping options flow
When an address (saved or new) becomes “selected”, call /api/shipping/quote.

Show returned methods; if none, show “No options yet. Select an address to see shipping options.”

Local check is server-side (50 miles). If LOCAL present, preselect it.

Legacy cleanup (must-do)
Delete/rename any of these if they exist and are imported anywhere:

src/pages/checkout.tsx, src/pages/checkout-new.tsx, src/components/cart/legacy*, old useDefaultAddress*.

Search for mutation keys or query keys not in cartKeys.ts and replace.

Remove any “km” helpers; keep miles only.

Ensure routes:

/checkout → checkout-simple.tsx (the new one)

/dashboard?tab=addresses → uses useAddresses() above.

QA / acceptance checklist
 Adding first address auto-marks it Default (and shows badge).

 Only one default per user (DB constraint proves it).

 Cannot delete default; can delete any other. After delete, list refreshes.

 Checkout:

 Loads default address read-only; “Change” surfaces a list of saved addresses (with Default badge).

 “Use new address” switches to editable form; submit can save to profile.

 Selecting any address triggers /api/shipping/quote and shows methods; local delivery appears when ≤ 50 miles.

 Order summary lists items consistently; no $0.00 phantom values.

 No runtime errors in console.

 Add-to-Cart:

 Blue “Add to Cart” → green “In Cart”; hover shows red × to remove; removing returns to blue state.

 No “failed to find mutation”; cart count updates immediately.

 Onboarding gate:

 With a default address present, /api/orders does not 403.

 Dev logs are clean (no /api/observability/errors 400 spam).

Quick test commands (manual)
bash
Copy
Edit
# Set default
curl -i -X POST http://localhost:5000/api/addresses/<ID>/default

# Try deleting default (should 400)
curl -i -X DELETE http://localhost:5000/api/addresses/<DEFAULT_ID>

# Shipping quote (expect LOCAL when within 50 miles)
curl -s -X POST http://localhost:5000/api/shipping/quote \
  -H "Content-Type: application/json" \
  -d '{"addressId":"<DEFAULT_ID>"}'
Small polish (optional but nice)
Debounce Geoapify search (250ms) and show a “confidence” badge when a result is chosen.

Cache /api/addresses for 60s; invalidate on any create/update/delete/default change.

In Shipping Method box, show “Local delivery qualifies within 50 miles. Based on your default address: X miles.”

If Replit implements everything above, you’ll get: default address clearly labeled + enforced, delete/make default flows that work, checkout that prefills read-only from saved addresses (with a clean “Use new address” path), shipping options derived in miles, and add-to-cart restored with the classic blue/green/hover-remove UX — with all legacy code finally out of the way.









Ask ChatGPT
