FIX CLOUDINARY UPLOAD FAILURE

REPLIT INSTRUCTIONS:
markdown## DEBUG AND FIX IMAGE UPLOAD TO CLOUDINARY

### ISSUE:
- Signature endpoint works (200 OK)
- But actual Cloudinary upload fails
- Error: "Failed to upload 1.3.jpg"

---

### STEP 1: CHECK CLOUDINARY CONFIGURATION

FILE: `/server/routes/api.ts` or `/server/routes/cloudinary.ts`

VERIFY the signature endpoint returns ALL required fields:
```typescript
router.get('/api/cloudinary/signature', requireAuth, async (req, res) => {
  const timestamp = Math.round(new Date().getTime() / 1000);
  const folder = req.query.folder || 'equipment-submissions';
  
  // IMPORTANT: Don't use upload_preset with signed uploads
  const params = {
    timestamp,
    folder
  };
  
  const signature = cloudinary.utils.api_sign_request(
    params,
    process.env.CLOUDINARY_API_SECRET!
  );
  
  res.json({
    signature,
    timestamp,
    cloudName: process.env.CLOUDINARY_CLOUD_NAME,
    apiKey: process.env.CLOUDINARY_API_KEY,
    folder
  });
});

STEP 2: FIX FRONTEND UPLOAD FUNCTION
FILE: /client/src/pages/SellToUs.tsx (or wherever uploadToCloudinary is)
UPDATE the upload function with better error handling:
jsxconst uploadToCloudinary = async (file: File): Promise<string> => {
  try {
    // Get signature from backend
    const signatureResponse = await fetch(
      '/api/cloudinary/signature?folder=equipment-submissions',
      { credentials: 'include' }
    );
    
    if (!signatureResponse.ok) {
      throw new Error('Failed to get upload signature');
    }
    
    const { signature, timestamp, cloudName, apiKey, folder } = 
      await signatureResponse.json();
    
    // Create form data
    const formData = new FormData();
    formData.append('file', file);
    formData.append('api_key', apiKey);
    formData.append('timestamp', timestamp.toString());
    formData.append('signature', signature);
    formData.append('folder', folder);
    
    // Upload to Cloudinary
    const uploadResponse = await fetch(
      `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`,
      {
        method: 'POST',
        body: formData
      }
    );
    
    if (!uploadResponse.ok) {
      const errorData = await uploadResponse.text();
      console.error('Cloudinary error:', errorData);
      throw new Error(`Upload failed: ${uploadResponse.status}`);
    }
    
    const data = await uploadResponse.json();
    return data.secure_url;
    
  } catch (error) {
    console.error('Upload error:', error);
    throw error;
  }
};

STEP 3: ALTERNATIVE - USE UNSIGNED UPLOAD (SIMPLER)
If signed upload continues to fail, use UNSIGNED upload:
A. Create unsigned preset in Cloudinary Dashboard:

Go to Cloudinary Dashboard > Settings > Upload
Add upload preset
Set Signing Mode to "Unsigned"
Set folder to "equipment-submissions"
Save preset name (e.g., "equipment_unsigned")

B. Update frontend to use unsigned upload:
jsxconst uploadToCloudinary = async (file: File): Promise<string> => {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('upload_preset', 'equipment_unsigned'); // Your preset name
  formData.append('folder', 'equipment-submissions');
  
  try {
    const response = await fetch(
      `https://api.cloudinary.com/v1_1/${process.env.VITE_CLOUDINARY_CLOUD_NAME}/image/upload`,
      {
        method: 'POST',
        body: formData
      }
    );
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Cloudinary response:', errorText);
      throw new Error('Upload failed');
    }
    
    const data = await response.json();
    return data.secure_url;
  } catch (error) {
    console.error('Upload error:', error);
    throw error;
  }
};

STEP 4: ADD ENVIRONMENT VARIABLE TO FRONTEND
FILE: /client/.env or /client/.env.local
ADD:
envVITE_CLOUDINARY_CLOUD_NAME=your_cloud_name_here
Then use in code:
jsxconst cloudName = import.meta.env.VITE_CLOUDINARY_CLOUD_NAME;

STEP 5: DEBUG WITH CONSOLE LOGS
Add detailed logging to see what's failing:
jsxconst handleFiles = async (files: File[]) => {
  console.log('Starting upload for files:', files);
  
  for (const file of files) {
    console.log('Uploading file:', file.name, 'Size:', file.size);
    
    try {
      // Add size check
      if (file.size > 10 * 1024 * 1024) { // 10MB limit
        throw new Error('File too large');
      }
      
      const url = await uploadToCloudinary(file);
      console.log('Upload successful:', url);
      
    } catch (error) {
      console.error('Failed to upload:', file.name, error);
      
      // Show specific error to user
      toast({
        title: "Upload failed",
        description: `Failed to upload ${file.name}: ${error.message}`,
        variant: "destructive"
      });
    }
  }
};

STEP 6: CHECK BROWSER CONSOLE
Open browser DevTools and check:

Network tab - Is request to Cloudinary being made?
Console - What's the exact error?
Response - What does Cloudinary return?

Common issues:

401: API key wrong
403: Signature invalid
413: File too large
CORS: Need to check Cloudinary settings


STEP 7: SIMPLER TEST
Create a minimal test to isolate the issue:
jsx// Test button in your component
<button onClick={async () => {
  // Create tiny test image
  const canvas = document.createElement('canvas');
  canvas.width = 100;
  canvas.height = 100;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'red';
  ctx.fillRect(0, 0, 100, 100);
  
  canvas.toBlob(async (blob) => {
    const file = new File([blob], 'test.jpg', { type: 'image/jpeg' });
    
    try {
      const url = await uploadToCloudinary(file);
      console.log('Test upload success:', url);
      alert('Upload worked! URL: ' + url);
    } catch (error) {
      console.error('Test upload failed:', error);
      alert('Upload failed: ' + error.message);
    }
  });
}}>
  Test Upload
</button>

QUICK FIXES TO TRY:

Use unsigned upload (simplest solution)
Check Cloudinary cloud name is correct
Verify API keys in .env files
Try smaller image (under 1MB)
Check Cloudinary dashboard for errors
Remove transformations temporarily
Use Cloudinary widget as fallback

The issue is likely configuration-related since the signature endpoint works but Cloudinary rejects the upload.