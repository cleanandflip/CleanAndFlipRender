The error is happening in the Drizzle ORM when trying to fetch addresses. The error "Cannot convert undefined or null to object" at orderSelectedFields suggests that the query is trying to select fields that don't exist or the table structure is incorrect.
Looking at the error stack trace:

It's happening in the Drizzle ORM utils when trying to order selected fields
The API endpoint is /api/addresses?userId=...
It's returning a 500 error

This likely means:

There's a mismatch between the database schema and the Drizzle schema definition
The addresses table might not exist or has different columns than expected
There might be legacy code trying to access old column names

The user wants me to help remove legacy systems and fix this error.Fix Address Fetching Error - Drizzle ORM Schema Mismatch
The error indicates a Drizzle ORM schema issue when trying to fetch addresses. Let's fix this by ensuring proper schema alignment and removing legacy code.
1. Check Current Database Schema
First, let's see what tables and columns actually exist:
sql-- Check if addresses table exists
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public' 
AND table_name IN ('addresses', 'user_addresses');

-- Check users table columns
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'users' 
AND column_name LIKE '%address%' OR column_name LIKE '%city%' OR column_name LIKE '%state%' OR column_name LIKE '%zip%';
2. Fix Drizzle Schema Definition
Update your Drizzle schema to match the actual database:
typescript// server/db/schema.ts
import { pgTable, uuid, varchar, text, timestamp, boolean, decimal } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  password: text('password').notNull(),
  firstName: varchar('first_name', { length: 100 }),
  lastName: varchar('last_name', { length: 100 }),
  // Remove old fields
  // address: text('address'), // REMOVE
  // cityStateZip: varchar('city_state_zip'), // REMOVE
  
  // Add new fields
  street: varchar('street', { length: 255 }),
  city: varchar('city', { length: 100 }),
  state: varchar('state', { length: 2 }),
  zipCode: varchar('zip_code', { length: 10 }),
  latitude: decimal('latitude', { precision: 10, scale: 8 }),
  longitude: decimal('longitude', { precision: 11, scale: 8 }),
  isLocalCustomer: boolean('is_local_customer').default(false),
  
  // Other fields...
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow()
});

// If you have a separate addresses table, define it
export const addresses = pgTable('addresses', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').references(() => users.id).notNull(),
  street: varchar('street', { length: 255 }).notNull(),
  city: varchar('city', { length: 100 }).notNull(),
  state: varchar('state', { length: 2 }).notNull(),
  zipCode: varchar('zip_code', { length: 10 }).notNull(),
  latitude: decimal('latitude', { precision: 10, scale: 8 }),
  longitude: decimal('longitude', { precision: 11, scale: 8 }),
  isDefault: boolean('is_default').default(false),
  isLocal: boolean('is_local').default(false),
  createdAt: timestamp('created_at').defaultNow()
});
3. Fix the API Endpoint
The error shows it's trying to fetch with userId as a query param. Let's fix the endpoint:
typescript// server/routes/addresses.ts
import { db } from '../db';
import { users, addresses } from '../db/schema';
import { eq } from 'drizzle-orm';

// Fix: Remove the userId query param, use authenticated user
router.get('/addresses', requireAuth, async (req, res) => {
  try {
    const userId = req.user.id; // Get from auth, not query param
    
    // Option 1: If addresses are stored in users table
    const user = await db
      .select({
        street: users.street,
        city: users.city,
        state: users.state,
        zipCode: users.zipCode,
        isLocalCustomer: users.isLocalCustomer
      })
      .from(users)
      .where(eq(users.id, userId))
      .limit(1);
    
    if (user.length > 0 && user[0].street) {
      const addresses = [{
        id: userId,
        street: user[0].street,
        city: user[0].city,
        state: user[0].state,
        zipCode: user[0].zipCode,
        isLocal: user[0].isLocalCustomer,
        isDefault: true
      }];
      return res.json(addresses);
    }
    
    // Option 2: If you have a separate addresses table
    // const userAddresses = await db
    //   .select()
    //   .from(addresses)
    //   .where(eq(addresses.userId, userId));
    
    // return res.json(userAddresses);
    
    // No addresses found
    res.json([]);
    
  } catch (error) {
    console.error('Error fetching addresses:', error);
    res.status(500).json({ error: 'Failed to fetch addresses' });
  }
});
4. Update Frontend API Call
Remove the userId from the query parameter:
tsx// src/pages/dashboard.tsx - AddressesTab component
const { data: addresses, isLoading } = useQuery({
  queryKey: ['addresses'],
  queryFn: async () => {
    // Remove userId from URL
    const res = await fetch('/api/addresses', {
      credentials: 'include'
    });
    if (!res.ok) throw new Error('Failed to fetch addresses');
    return res.json();
  }
});
5. Migration Script to Clean Up
Run this to ensure data consistency:
sql-- Remove any legacy columns if they exist
ALTER TABLE users 
DROP COLUMN IF EXISTS address,
DROP COLUMN IF EXISTS cityStateZip,
DROP COLUMN IF EXISTS city_state_zip;

-- Ensure new columns exist
ALTER TABLE users
ADD COLUMN IF NOT EXISTS street VARCHAR(255),
ADD COLUMN IF NOT EXISTS city VARCHAR(100),
ADD COLUMN IF NOT EXISTS state VARCHAR(2),
ADD COLUMN IF NOT EXISTS zip_code VARCHAR(10),
ADD COLUMN IF NOT EXISTS latitude DECIMAL(10, 8),
ADD COLUMN IF NOT EXISTS longitude DECIMAL(11, 8),
ADD COLUMN IF NOT EXISTS is_local_customer BOOLEAN DEFAULT FALSE;

-- Create index for faster lookups
CREATE INDEX IF NOT EXISTS idx_users_zip_code ON users(zip_code);
6. Update User Registration/Profile Save
Ensure the save function matches the schema:
typescript// server/routes/auth.ts
router.post('/register', async (req, res) => {
  const { email, password, firstName, lastName, street, city, state, zipCode } = req.body;
  
  // Check if local
  const ashevilleZips = ['28801', '28802', '28803', '28804', '28805', '28806'];
  const isLocal = ashevilleZips.includes(zipCode);
  
  const newUser = await db.insert(users).values({
    email,
    password: hashedPassword,
    firstName,
    lastName,
    street,
    city,
    state,
    zipCode, // This will map to zip_code in DB
    isLocalCustomer: isLocal
  }).returning();
  
  res.json(newUser[0]);
});
7. Quick Debug Steps
Add logging to see what's happening:
typescript// In your API endpoint
console.log('Fetching addresses for user:', userId);
console.log('User type:', typeof userId);
console.log('Drizzle schema:', users);

// Try a simple query first
const testQuery = await db.select().from(users).limit(1);
console.log('Test query result:', testQuery);
Summary of Changes Needed

✅ Update Drizzle schema to match actual database columns
✅ Remove userId from query parameters (use auth instead)
✅ Ensure column names match (zipCode vs zip_code)
✅ Remove any legacy address/cityStateZip references
✅ Update frontend to not pass userId in URL
✅ Add proper error handling and logging

The main issue is likely a mismatch between your Drizzle schema definition and the actual database structure. Make sure they're perfectly aligned!