only edits to the current code, no new features/files.

0) The blocker right now
Error

javascript
Copy
Edit
SyntaxError: The requested module '/src/hooks/useWebSocketState.tsx'
does not provide an export named 'default'
Cause
useWebSocketState.tsx exports named symbols, but some files import it as a default.

Fix (surgical): change every default import of that hook to a named import.

Edit 1 — Users tab (the crash source)
File: src/pages/admin/UsersTab.tsx

diff
Copy
Edit
- import useWebSocketState from '@/hooks/useWebSocketState';
+ import { useWebSocketState } from '@/hooks/useWebSocketState';
If you render it, keep a safe guard:

diff
Copy
Edit
- <pre>{lastMessage.data}</pre>
+ <pre>{lastMessage ? JSON.stringify(lastMessage, null, 2) : '—'}</pre>
(Do not add new code; this only adjusts imports & null-guarding.)

1) Repo-wide sweep to use only the new WebSocket hook and purge legacy
We currently have both of these in use (per logs):

src/hooks/useSingletonSocket.tsx ← legacy

src/hooks/useWebSocket.ts ← legacy/utility

src/hooks/useWebSocketState.tsx ← new/canonical

We must standardize on useWebSocketState.tsx only.

Step A — Normalize imports (no new files)
Run these replacements:

bash
Copy
Edit
# Replace default imports of the new hook with named import
# (covers any file accidentally using default)
find src -type f -name "*.tsx" -o -name "*.ts" \
  -exec sed -i "s#import useWebSocketState from ['\"]@/hooks/useWebSocketState['\"];#import { useWebSocketState } from '@/hooks/useWebSocketState';#g" {} +

# Migrate legacy hooks to the new one
# 1) useSingletonSocket -> useWebSocketState
find src -type f -name "*.tsx" -o -name "*.ts" \
  -exec sed -i "s#import \{\\? *useSingletonSocket *\\?\}\\? from ['\"]@/hooks/useSingletonSocket['\"];#import { useWebSocketState } from '@/hooks/useWebSocketState';#g" {} +
find src -type f -name "*.tsx" -o -name "*.ts" \
  -exec sed -i "s#useSingletonSocket\\s*\\(#useWebSocketState(#g" {} +

# 2) useWebSocket -> useWebSocketState (if it returns the same shape)
find src -type f -name "*.tsx" -o -name "*.ts" \
  -exec sed -i "s#import \{\\? *useWebSocket *\\?\}\\? from ['\"]@/hooks/useWebSocket['\"];#import { useWebSocketState } from '@/hooks/useWebSocketState';#g" {} +
find src -type f -name "*.tsx" -o -name "*.ts" \
  -exec sed -i "s#useWebSocket\\s*\\(#useWebSocketState(#g" {} +
If a file imported both a hook and named helpers from a legacy file, move only the hook to the new source and keep other helpers where they are (no new code).

Step B — Remove legacy duplicates that conflict
After Step A builds clean:

Delete: src/hooks/useSingletonSocket.tsx

Delete: src/hooks/useWebSocket.ts (only if no remaining references)

These deletions remove multiple socket instances and stale state that can fight the new hook.

2) Purge other legacy duplicates that cause mixed imports
Logs show both ErrorBoundary.tsx and error-boundary.tsx being imported. Keep one.

Step C — Standardize ErrorBoundary
Pick the canonical file: src/components/ErrorBoundary.tsx.

Move any improvements from src/components/error-boundary.tsx into the canonical file only if different.

Update imports that use the hyphenated filename:

bash
Copy
Edit
find src -type f -name "*.tsx" -o -name "*.ts" \
  -exec sed -i "s#@/components/error-boundary#@/components/ErrorBoundary#g" {} +
Delete src/components/error-boundary.tsx.

3) Keep only “new” routes & patterns in use
You already updated /api/products/featured (the prior 500s came from passing undefined to db.select). Make sure all places use that corrected pattern.

Step D — Guard db.select() across the codebase
Search for any db.select( that passes a variable (could be undefined) and wrap it as below (do not add new functions):

ts
Copy
Edit
// BEFORE
const rows = await db.select(selectedFields).from(table)/* ... */

// AFTER (inline guard)
const rows = await (selectedFields ? db.select(selectedFields) : db.select())
  .from(table) /* ... */;
Focus files that touch: server/routes.ts, server/storage.ts, or any *products*.ts.

4) Verify fulfillment flags stick (no new endpoints)
You noted delivery/fulfillment toggles weren’t saving. You already got 200s + “Successfully synced product … to Stripe”, so the write path returns OK. Two small adjustments (not new code) keep things consistent:

Step E — Ensure the server maps the exact field names the modal sends
File: server/storage.ts (update/insert product)

Confirm the payload → DB mapping uses the current columns:

shippingOnly (boolean)

localOnly (boolean)

or a single enum fulfillmentMode ('local' | 'shipping' | 'both')

If your DB uses the enum/column names above, make the assignment explicit (no new properties):

diff
Copy
Edit
- shippingOnly: input.shippingOnly,
- localOnly: input.localOnly,
+ shipping_only: input.shippingOnly,
+ local_only: input.localOnly,
(or map to fulfillment_mode: input.fulfillmentMode if that’s the one in the table)

Also make sure the admin modal uses those same names on submit:
File: src/components/admin/modals/EnhancedProductModal.tsx

diff
Copy
Edit
- body: JSON.stringify({ ...values })
+ body: JSON.stringify({
+   ...values,
+   // ensure we send the exact API fields the server expects:
+   shippingOnly: values.shippingOnly,
+   localOnly: values.localOnly,
+   fulfillmentMode: values.fulfillmentMode,
+ })
This is just aligning names—no new logic.

5) Cart gating uses current code paths (no new routes)
We already have POST /api/cart/items. Add an inline guard in that existing handler so local-only items require a local user, while shipping items can be added by anyone (this keeps front-end and back-end consistent).

File: server/routes.ts (or wherever the cart POST lives)

diff
Copy
Edit
// After you fetch the product by id (existing code), add:
+ // Enforce fulfillment rules (adjust to your column names)
+ if (product.local_only && !req.locality?.isLocal) {
+   return res.status(403).json({ error: 'Local pickup only in your area' });
+ }
+ // shipping_only is always OK for everyone; 'both' is OK for everyone
Front-end button (already exists): src/components/AddToCartButton.tsx

diff
Copy
Edit
- // allow click blindly
+ // disable when local_only and user not local
+ const disabled = product.local_only && !locality?.isLocal;
+ <Button disabled={disabled} /* ... */ />
Again, these are only edits to current files.

6) Quick validation checklist (do this right after edits)
UsersTab loads without “Something went wrong” and no default-export SyntaxError.

Only one WebSocket hook file exists in imports: useWebSocketState.tsx.

/api/products/featured returns 200, no “Cannot convert undefined or null to object” in server logs.

Toggling fulfillment in the product modal, saving, then refreshing product list shows the same flags.

Try adding a local-only product while simulated non-local → button disabled; API returns 403 if forced.

Shipping products can be added by anyone.

TL;DR commands (safe to run)
bash
Copy
Edit
# 1) Fix the bad import that’s crashing Admin → Users
sed -i "s#import useWebSocketState from ['\"]@/hooks/useWebSocketState['\"];#import { useWebSocketState } from '@/hooks/useWebSocketState';#g" src/pages/admin/UsersTab.tsx

# 2) Normalize all imports to the new hook
find src -type f -name "*.tsx" -o -name "*.ts" \
  -exec sed -i "s#import useWebSocketState from ['\"]@/hooks/useWebSocketState['\"];#import { useWebSocketState } from '@/hooks/useWebSocketState';#g" {} +
find src -type f -name "*.tsx" -o -name "*.ts" \
  -exec sed -i "s#import \{\\? *useSingletonSocket *\\?\}\\? from ['\"]@/hooks/useSingletonSocket['\"];#import { useWebSocketState } from '@/hooks/useWebSocketState';#g" {} +
find src -type f -name "*.tsx" -o -name "*.ts" \
  -exec sed -i "s#import \{\\? *useWebSocket *\\?\}\\? from ['\"]@/hooks/useWebSocket['\"];#import { useWebSocketState } from '@/hooks/useWebSocketState';#g" {} +

# 3) Unify ErrorBoundary import path
find src -type f -name "*.tsx" -o -name "*.ts" \
  -exec sed -i "s#@/components/error-boundary#@/components/ErrorBoundary#g" {} +

# 4) (After build passes) remove legacy files
rm -f src/hooks/useSingletonSocket.tsx
# rm -f src/hooks/useWebSocket.ts  # only if unused after the search/replace
This keeps the codebase on only the new routes & hooks, removes conflicting legacy pieces, and fixes the exact SyntaxError you’re seeing.