here’s a single, soup-to-nuts set of instructions for Replit to fix the onboarding/cart/address flow, purge all vestiges of the legacy system, and wire everything to the SSOT address model. It’s organized so you can work top-down and verify each step as you go.

0) What to fix (from the symptoms & logs)
404 after onboarding step submit → the client is navigating to /onboarding/2 instead of /onboarding?step=2.

Geoapify autocomplete doesn’t fill fields → mapping from Geoapify result → form fields isn’t wired; setValue isn’t being called for all fields.

Cart still forces onboarding even when profile has an address → the gate is still checking legacy columns or the wrong flag. It must check users.profile_address_id (not users.street, etc.) and that the referenced address exists.

Login blows up: column "street" does not exist → server/storage.ts (and possibly auth) still selects legacy columns.

Miles vs KM → distance util must return miles, and “local” must be computed with a 50-mile threshold.

Onboarding step loop → onboarding_step/profile_complete flags not set on success; React Query cache not invalidated; server response not updating session.

Observability spam (400s) → dev client posts error payload that the server rejects; handle or disable in dev.

Slow CSS / hydration → not blocking, but keep an eye on it later.

1) Hard purge of legacy address code (code + DB)
1.1 Search & delete all legacy references
Run these from repo root and remove/replace everything found:

bash
Copy
Edit
# Anything still referencing old user columns or paths
rg -n --hidden -S "\b(street|street1|zipCode|zip_code|latitude|longitude|profileAddress|profile_address|profileAddressId|profile_address_id)\b" server client | sort
rg -n --hidden -S "/onboarding/" client/src | sort
rg -n --hidden -S "km\>|kilometer" server client
rg -n --hidden -S "GEOAPIFY.*quota|429" server
Delete legacy components/pages you no longer want rendered:

bash
Copy
Edit
client/src/pages/checkout_broken.tsx
client/src/pages/onboarding.(tsx|jsx)  # old single-file version
client/src/pages/dashboard/addresses-legacy.(tsx|jsx)
client/src/components/*address*(legacy)*.(tsx|jsx)
Remove legacy server routes/endpoints:

pgsql
Copy
Edit
server/routes.ts        # old addresses/user joins block (2269–2428 previously)
server/routes/addresses-legacy.ts
1.2 Storage/auth SELECTs must not touch removed columns
Fix the error column "street" does not exist:

In server/storage.ts::getUserByEmail and any other user getters, do not select street, city, state, zip_code, latitude, longitude.

If the API needs the user’s default/profile address, LEFT JOIN via users.profile_address_id → addresses.id and alias the joined columns (or return a nested object).

Example (Drizzle or SQL; pick your stack):

ts
Copy
Edit
// server/storage.ts
export async function getUserByEmail(email: string) {
  const sql = `
    SELECT u.id, u.email, u.name, u.phone,
           u.profile_address_id,
           u.onboarding_step, u.profile_complete,
           u.onboarding_completed_at,
           jsonb_build_object(
             'id', a.id,
             'firstName', a.first_name,
             'lastName', a.last_name,
             'street1', a.street1,
             'street2', a.street2,
             'city', a.city,
             'state', a.state,
             'postalCode', a.postal_code,
             'country', a.country,
             'latitude', a.latitude,
             'longitude', a.longitude,
             'isDefault', a.is_default,
             'isLocal', a.is_local
           ) AS profile_address
    FROM users u
    LEFT JOIN addresses a ON a.id = u.profile_address_id
    WHERE u.email = $1
    LIMIT 1;
  `;
  return db.oneOrNone(sql, [email]);
}
Do the same for any other “get current user” path(s). No legacy columns anywhere.

1.3 Database integrity helpers (optional but recommended)
Add two triggers so SSOT stays consistent regardless of which endpoint sets default:

sql
Copy
Edit
-- When an address is set default, update users.profile_address_id to that address
CREATE OR REPLACE FUNCTION set_profile_address_on_default()
RETURNS trigger AS $$
BEGIN
  IF NEW.is_default = true THEN
    UPDATE addresses SET is_default = false WHERE user_id = NEW.user_id AND id <> NEW.id;
    UPDATE users SET profile_address_id = NEW.id WHERE id = NEW.user_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_set_profile_address ON addresses;
CREATE TRIGGER trg_set_profile_address
AFTER INSERT OR UPDATE OF is_default ON addresses
FOR EACH ROW EXECUTE FUNCTION set_profile_address_on_default();

-- If a default address is deleted, null out profile_address_id
CREATE OR REPLACE FUNCTION clear_profile_address_on_delete()
RETURNS trigger AS $$
BEGIN
  UPDATE users
     SET profile_address_id = NULL
   WHERE id = OLD.user_id AND profile_address_id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_clear_profile_on_delete ON addresses;
CREATE TRIGGER trg_clear_profile_on_delete
AFTER DELETE ON addresses
FOR EACH ROW EXECUTE FUNCTION clear_profile_address_on_delete();
2) Server fixes (miles + onboarding + gating + observability)
2.1 Distance util → miles and 50-mile local rule
ts
Copy
Edit
// server/lib/distance.ts
export function milesBetween(lat1: number, lon1: number, lat2: number, lon2: number) {
  const toRad = (d: number) => (d * Math.PI) / 180;
  const R = 3958.8; // Earth radius in MILES
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

export function isLocalAddress(addrLat: number, addrLon: number) {
  const originLat = Number(process.env.CF_ORIGIN_LAT);
  const originLon = Number(process.env.CF_ORIGIN_LON);
  const dist = milesBetween(originLat, originLon, addrLat, addrLon);
  return { isLocal: dist <= 50, distanceMiles: dist };
}
When saving an address, compute and store is_local and (optionally) distance_miles.

2.2 Address save → set is_default and mark onboarding when needed
ts
Copy
Edit
// server/routes/addresses.ts (create/update)
router.post('/', requireAuth, async (req, res) => {
  const data = AddressSchema.parse(req.body); // zod
  // ... geocode/validate
  const { isLocal, distanceMiles } = isLocalAddress(data.latitude, data.longitude);

  const address = await repo.createAddress({
    ...data,
    isLocal,
    distanceMiles,
    isDefault: data.isDefault ?? false,
    userId: req.user!.id,
  });

  // if onboarding gate: mark progress when first address created
  await db.none(
    `UPDATE users SET
       profile_address_id = COALESCE(profile_address_id, $1),
       onboarding_step = GREATEST(COALESCE(onboarding_step, 0), 1)
     WHERE id = $2`,
    [address.id, req.user!.id]
  );

  res.status(201).json(toAddressDTO(address));
});
2.3 Onboarding API & session update
Ensure completion marks flags and returns fresh user:

ts
Copy
Edit
// server/routes/onboarding.ts
router.post('/complete', requireAuth, async (req, res) => {
  // Validate phone etc…
  await db.none(
    `UPDATE users
        SET profile_complete = TRUE,
            onboarding_step = 3,
            onboarding_completed_at = NOW()
      WHERE id = $1`,
    [req.user!.id]
  );

  // Refresh the session user (important for client gating)
  const user = await getUserById(req.user!.id);
  req.login(user, (err) => {
    if (err) return res.status(500).json({ message: 'Session update failed' });
    res.json({ ok: true, user });
  });
});
2.4 Cart gating must check SSOT only
ts
Copy
Edit
// server/routes/cart.ts (or middleware)
function requireProfileReady(req: Request, res: Response, next: NextFunction) {
  const u = req.user as any;
  if (!u) return res.status(401).end();

  const profileReady =
    !!u.profile_address_id && u.profile_complete === true;

  if (!profileReady) {
    return res.status(428).json({
      code: 'PROFILE_INCOMPLETE',
      redirect: '/onboarding?step=1&from=cart&required=true',
    });
  }
  next();
}
Remove any checks of users.street, users.zip_code, etc.

2.5 Observability endpoint in dev
Stop the 400 spam:

ts
Copy
Edit
// server/routes/observability.ts
router.post('/errors', (req, res) => {
  if (process.env.NODE_ENV !== 'production') return res.status(204).end();
  // …validate and store in prod
});
3) Client fixes (routing, Geoapify mapping, gating UX)
3.1 Routing bug (404)
All onboarding navigation must use the query parameter, not a path segment.

ts
Copy
Edit
// client/src/pages/onboarding/index.tsx
const go = (step: number) => navigate(`/onboarding?step=${step}${from ? `&from=${from}` : ''}`);

onSubmitAddressSuccess: () => go(2)
onSubmitPhoneSuccess:   () => go(3)
onCompleteSuccess:      () => navigate(from === 'cart' ? '/cart' : '/')
Find and remove any navigate('/onboarding/2') or similar.

3.2 Autocomplete → fill every field
ts
Copy
Edit
// client/src/components/ui/address-autocomplete.tsx
function mapGeoapifyToFields(item: any) {
  const p = item.properties ?? item; // server proxy may unwrap
  return {
    street1: [p.housenumber, p.street || p.street_name].filter(Boolean).join(' '),
    city: p.city || p.municipality || p.county || '',
    state: p.state_code || p.state || '',
    postalCode: p.postcode || p.zip || '',
    country: p.country_code?.toUpperCase() || 'US',
    latitude: p.lat ?? p.latitude,
    longitude: p.lon ?? p.longitude,
    geoapifyPlaceId: p.place_id || p.datasource?.raw?.place_id || '',
  };
}

// When a suggestion is selected:
const f = mapGeoapifyToFields(suggestion);
setValue('street1', f.street1, { shouldValidate: true, shouldDirty: true });
setValue('city', f.city, { shouldValidate: true });
setValue('state', f.state, { shouldValidate: true });
setValue('postalCode', f.postalCode, { shouldValidate: true });
setValue('country', f.country);
setValue('latitude', f.latitude);
setValue('longitude', f.longitude);
setValue('geoapifyPlaceId', f.geoapifyPlaceId);
trigger(['street1','city','state','postalCode']);
Also: debounce Geoapify calls and show an error for 429 quota; don’t crash.

3.3 Step validation
Phone: block Next until valid with libphonenumber-js.

Address: require firstName, lastName, street1, city, state, postalCode.

ts
Copy
Edit
const canContinue = formState.isValid && !isSubmitting;
<Button disabled={!canContinue} ...>
3.4 React Query cache invalidation & user refresh
After saving an address, invalidate user + addresses + cart and refetch session:

ts
Copy
Edit
await mutation.mutateAsync(payload);
await Promise.all([
  queryClient.invalidateQueries({ queryKey: ['user'] }),
  queryClient.invalidateQueries({ queryKey: ['addresses'] }),
  queryClient.invalidateQueries({ queryKey: ['cart'] }),
]);
3.5 Cart UX for gate
If /api/cart returns 428 PROFILE_INCOMPLETE, redirect to onboarding:

ts
Copy
Edit
// client/src/api/cart.ts
if (res.status === 428) {
  const { redirect } = await res.json();
  navigate(redirect ?? '/onboarding?step=1&from=cart&required=true');
  return { items: [] };
}
3.6 Remove SMS toggle
Delete SMS checkbox and any SMS state in onboarding summary.

Ensure only email notifications remain.

4) Dashboard “Addresses” tab — rebuild on SSOT
Replace the current tab with the shared components:

tsx
Copy
Edit
// client/src/pages/dashboard.tsx (Addresses tab panel)
<AddressList
  onMakeDefault={(id) => api.addresses.setDefault(id)}
  onEdit={(addr) => openModal(<AddressForm initial={addr} />)}
  onAddNew={() => openModal(<AddressForm />)}
/>
Ensure the list is sourced from GET /api/addresses and the “default” chip reflects isDefault === true. When a default is set, refetch ['user'] so the header/profile reflects it.

5) Cart/Checkout — always pull from SSOT
For checkout shipping, prefill from GET /api/addresses?default=true.

If no address: present the same AddressForm inline (no duplicate schema).

For local-only products, check user.isLocal (from default address) before add-to-cart:

ts
Copy
Edit
// server: add-to-cart guard
if (product.local_only && !user.defaultAddress?.is_local) {
  return res.status(403).json({ code: 'LOCAL_ONLY' });
}
6) QA — clean DB, seed, test matrix
6.1 Clean slate
sql
Copy
Edit
-- Wipe users & addresses (dev only)
TRUNCATE TABLE sessions RESTART IDENTITY CASCADE;
TRUNCATE TABLE addresses RESTART IDENTITY CASCADE;
TRUNCATE TABLE users RESTART IDENTITY CASCADE;
TRUNCATE TABLE carts RESTART IDENTITY CASCADE;
6.2 Create test accounts
Email/Password user A: Asheville, NC (local < 50 mi).

Google user B: Los Angeles, CA (non-local).

Guest: no address.

6.3 Flow checks
Onboarding step 1

Select “10 Magnolia Farms Dr, Asheville, NC 28806”

Verify all fields auto-fill; Save → navigates to ?step=2 (not /onboarding/2).

Step 2 (phone)

Invalid input should keep “Continue” disabled; valid US mobile enables it.

Step 3 (summary/complete)

Complete → users.profile_complete = true, onboarding_step = 3, profile_address_id set.

Client receives refreshed user with profile_address.

Cart gate

With default address present → cart opens.

Without address → 428 + redirect to onboarding.

Dashboard Addresses

Shows newly saved address; “Make Default” updates user and list.

Geoapify quota

If 429, UI shows “Too many requests—try again shortly” and keeps existing values.

7) Logging you should add (to prove it’s fixed)
After every address save: log {userId, addressId, isLocal, distanceMiles, isDefault}.

At cart gate: log {userId, profile_address_id, profile_complete, gatePassed}.

At onboarding transitions: log the fromStep -> toStep and flags updated.

8) Final acceptance checklist
 No references to users.street, zip_code, latitude, longitude in repo.

 /onboarding never generates path /onboarding/{n}; only ?step=n.

 Selecting a Geoapify suggestion fills street1, city, state, postalCode, country, lat/lon.

 isLocal computed in miles with a 50-mile threshold.

 GET /api/user returns { profile_address_id, profile_address, profile_complete }.

 Cart opens when a default address exists; otherwise redirects with 428.

 Dashboard → Addresses uses the new components; no legacy tab/components exist.

 Observability 400 spam gone in dev logs.

 Creating a new default address updates users.profile_address_id (trigger or code).

 React Query keys ['user'], ['addresses'], ['cart'] are invalidated after edits.

If you implement the above exactly, the 404, the “cart keeps asking for onboarding,” the autocomplete not filling fields, and the DB street column error will all go away, and every form (onboarding, dashboard, checkout) will be driven from the one SSOT (the addresses table + users.profile_address_id) with miles-based local checks.