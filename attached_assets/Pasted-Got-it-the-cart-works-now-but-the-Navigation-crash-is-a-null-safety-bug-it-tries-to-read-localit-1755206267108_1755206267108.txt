Got it — the cart works now, but the Navigation crash is a null-safety bug: it tries to read locality.eligible before useLocality() has data, so locality is undefined and React blows up.

Below is a tight patch set to make the locality object never undefined, fix the trailing ? URL, and guard all UI reads.

Replit — apply this patch
1) Make a single exported default value
File: shared/locality.ts

ts
Copy
Edit
// add or ensure this exists and is exported
export type LocalitySource = 'DEFAULT_ADDRESS' | 'ZIP' | 'IP' | 'NONE';

export type LocalityStatus = {
  eligible: boolean;
  source: LocalitySource;
  zip: string;      // '28806' | 'none'
  user?: string | null;
};

export const DEFAULT_LOCALITY: LocalityStatus = {
  eligible: false,
  source: 'NONE',
  zip: 'none',
  user: null,
};
2) Make the hook always return a non-null object and fix the URL
File: client/src/hooks/useLocality.ts

ts
Copy
Edit
import { useQuery } from '@tanstack/react-query';
import { DEFAULT_LOCALITY, LocalityStatus } from '../../shared/locality';

function buildLocalityUrl(zip?: string) {
  const base = '/api/locality/status';
  return zip ? `${base}?zip=${encodeURIComponent(zip)}` : base; // no stray '?'
}

async function fetchLocality(zip?: string): Promise<LocalityStatus> {
  const res = await fetch(buildLocalityUrl(zip), { credentials: 'include' });
  if (!res.ok) throw new Error(`Locality request failed: ${res.status}`);
  const data = (await res.json()) as LocalityStatus;
  // harden the shape to avoid undefined in the UI
  return {
    eligible: !!data.eligible,
    source: data.source ?? 'NONE',
    zip: data.zip ?? 'none',
    user: data.user ?? null,
  };
}

export function useLocality(zipOverride?: string) {
  const q = useQuery({
    queryKey: ['locality', zipOverride ?? null],
    queryFn: () => fetchLocality(zipOverride),
    placeholderData: DEFAULT_LOCALITY, // shows immediately
    staleTime: 5 * 60 * 1000,
    gcTime: 30 * 60 * 1000,
  });

  // ALWAYS return a concrete object
  return {
    ...q,
    data: (q.data ?? DEFAULT_LOCALITY) as LocalityStatus,
  };
}
3) Guard reads in Navigation (the crash site)
File: client/src/components/layout/navigation.tsx

tsx
Copy
Edit
import { useLocality } from '../../hooks/useLocality';
import { DEFAULT_LOCALITY } from '../../../shared/locality';

// ...
export function Navigation(/* props */) {
  const { data: locality, isLoading } = useLocality();
  const local = locality ?? DEFAULT_LOCALITY; // <-- never undefined

  // replace any direct uses like `locality.eligible`
  const isLocal = !!local.eligible;
  const localitySource = local.source;

  // example usage in profile dropdown / banner:
  // BEFORE: {locality.eligible ? '✅ Local delivery eligible' : '❌ Outside zone'}
  // AFTER:
  {isLocal ? '✅ Local delivery eligible' : '❌ Outside local delivery zone'}

  // if there’s conditional rendering, prefer optional chaining or the `local` object
  // ...
}
If line ~321 did something like locality.eligible && <Badge/>, change to local.eligible && <Badge/>.

4) Harden other components that read locality (quick, surgical)
File: client/src/components/fulfillment/DeliveryEligibilityBanner.tsx

tsx
Copy
Edit
import { DEFAULT_LOCALITY } from '../../../shared/locality';
// ...
const { data: locality } = useLocality();
const local = locality ?? DEFAULT_LOCALITY;
// use `local.eligible` going forward
File: client/src/components/locality/ProductAvailabilityChips.tsx

tsx
Copy
Edit
const { data: locality } = useLocality();
const local = locality ?? DEFAULT_LOCALITY;
// use local.eligible
File: client/src/components/fulfillment/FulfillmentBadge.tsx

If it receives locality as a prop, default it:

tsx
Copy
Edit
function FulfillmentBadge({ locality }: { locality?: LocalityStatus }) {
  const local = locality ?? DEFAULT_LOCALITY;
  // use local.eligible
}
5) (Nice to have) Normalize the server response shape
File: server/routes.ts (or your locality controller)
Make sure the JSON always includes these fields:

ts
Copy
Edit
res.json({
  eligible: !!status.eligible,
  source: status.source ?? 'NONE',
  zip: status.zip ?? 'none',
  user: userId ?? null,
});
6) Remove the stray ? calls in any other fetchers
Search the client for /api/locality/status? and replace with the buildLocalityUrl(zip) helper. That stops the GET /api/locality/status? variant and React Query cache fragmentation.

Why this fixes it
useLocality() now always returns a concrete object (via placeholderData and a final data ?? DEFAULT_LOCALITY), so locality.eligible can’t be undefined during the first render.

Navigation and other components read from a local variable that’s guaranteed to exist.

The endpoint URL generator avoids a trailing ?, preventing duplicate cache keys and weird racey states.

Quick QA
Hard refresh the app.

Confirm the console shows no “reading ‘eligible’ of undefined”.

In the profile dropdown banner, it should immediately show Outside zone then flip to Local delivery eligible within ~200ms when logged in with a default Asheville ZIP.

Add a LOCAL DELIVERY ONLY product — it should add successfully for a local user.

Search network tab for locality/status — ensure all calls are to /api/locality/status (no trailing ?).

If you still see a flash of the non-local state, bump placeholderData to initialData: DEFAULT_LOCALITY and keep staleTime as above.