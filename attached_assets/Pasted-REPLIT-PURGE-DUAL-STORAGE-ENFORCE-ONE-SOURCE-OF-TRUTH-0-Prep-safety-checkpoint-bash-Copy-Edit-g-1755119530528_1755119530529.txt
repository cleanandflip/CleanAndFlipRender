REPLIT: PURGE DUAL-STORAGE, ENFORCE ONE SOURCE OF TRUTH
0) Prep & safety checkpoint
bash
Copy
Edit
git add -A && git commit -m "checkpoint before storage purge" || true
1) Nuke legacy storage code & any callers
Run this block to delete the common legacy folders/files. If something isn’t present it’ll just skip.

bash
Copy
Edit
rm -rf \
  server/storage \
  server/services/*storage* \
  server/services/session* \
  server/repositories/legacy* \
  server/controllers/legacy* \
  server/routes/cart-legacy* \
  server/routes/addresses-legacy* \
  src/lib/*storage* \
  src/services/*storage* \
  src/hooks/*storage* \
  src/pages/onboarding \
  server/middleware/ensureProfileComplete* || true
Find any stragglers still importing legacy stuff (VERY IMPORTANT):

bash
Copy
Edit
grep -RIln -E "(storage|SessionCart|CartSession|LocalStorage|Legacy|ensureProfileComplete|/api/cart/remove|checkout-old|checkout-simple)" \
  server src || true
Anything that shows up in this grep: delete it or rewire it to use the new repository layer (below).

2) Lock the codebase to one storage path (DB repositories only)
Canonical repositories (DB only)
Create/ensure only these exist and are used:

bash
Copy
Edit
server/repositories/cartRepository.ts
server/repositories/addressRepository.ts
server/repositories/userRepository.ts
server/repositories/cartRepository.ts

ts
Copy
Edit
import db from "../db";

export const CartRepo = {
  async getCartByUser(userId: string) {
    return db.oneOrNone(
      `select c.id, json_agg(ci.*) filter (where ci.id is not null) as items
       from carts c
       left join cart_items ci on ci.cart_id = c.id
       where c.user_id = $1
       group by c.id`, [userId]
    );
  },

  async ensureCart(userId: string) {
    return db.one(
      `insert into carts (user_id)
       values ($1)
       on conflict (user_id) do update set user_id = excluded.user_id
       returning id`, [userId]
    );
  },

  async addItem(userId: string, productId: string, qty = 1) {
    const { id: cartId } = await this.ensureCart(userId);
    return db.one(
      `insert into cart_items (cart_id, product_id, qty)
       values ($1, $2, $3)
       on conflict (cart_id, product_id) do update set qty = cart_items.qty + $3
       returning *`, [cartId, productId, qty]
    );
  },

  async removeItem(userId: string, cartItemId: string) {
    return db.result(
      `delete from cart_items
       using carts
       where cart_items.id = $1
         and carts.id = cart_items.cart_id
         and carts.user_id = $2`, [cartItemId, userId]
    );
  },

  async validate(userId: string) {
    // compute totals server-side, return numbers only
    const cart = await this.getCartByUser(userId);
    const items = cart?.items ?? [];
    const subtotal = items.reduce((s: number, it: any) => s + Number(it.price ?? 0) * Number(it.qty ?? 0), 0);
    const shipping = items.length ? 25 : 0;
    const tax = Math.round(subtotal * 0.07 * 100) / 100;
    const total = subtotal + shipping + tax;
    return { items, totals: { subtotal, shipping, tax, total } };
  }
};
server/repositories/addressRepository.ts

ts
Copy
Edit
import db from "../db";

export const AddressRepo = {
  async list(userId: string) {
    return db.any(`select * from addresses where user_id = $1 order by is_default desc, created_at asc`, [userId]);
  },

  async create(userId: string, a: any) {
    const hasAny = await db.one(`select exists(select 1 from addresses where user_id = $1) as has`, [userId]);
    const isDefault = !hasAny.has;
    return db.one(
      `insert into addresses (user_id, first_name, last_name, street, city, state, zip, is_default)
       values ($1,$2,$3,$4,$5,$6,$7,$8) returning *`,
       [userId, a.firstName, a.lastName, a.street, a.city, a.state, a.zip, isDefault]
    );
  },

  async makeDefault(userId: string, id: string) {
    return db.tx(async t => {
      await t.none(`update addresses set is_default = false where user_id = $1`, [userId]);
      await t.none(`update addresses set is_default = true where id = $1 and user_id = $2`, [id, userId]);
    });
  },

  async remove(userId: string, id: string) {
    const row = await db.one(`select is_default from addresses where id=$1 and user_id=$2`, [id, userId]);
    if (row?.is_default) throw new Error("CANNOT_DELETE_DEFAULT");
    return db.result(`delete from addresses where id=$1 and user_id=$2`, [id, userId]);
  }
};
3) Make it impossible to call old storage code (Kill-Switch)
Create server/lib/legacy-guard.ts:

ts
Copy
Edit
export function LEGACY_KILL_SWITCH(moduleName: string): never {
  const msg = `[FATAL] Legacy module imported: ${moduleName}. Remove all references.`;
  console.error(msg);
  throw new Error(msg);
}
Replace contents of any remaining legacy files (don’t delete yet if you want a loud fail) with:

ts
Copy
Edit
import { LEGACY_KILL_SWITCH } from "../lib/legacy-guard";
LEGACY_KILL_SWITCH(__filename);
export default null as never;
If something still imports it, the server will crash immediately with a clear stack trace showing who imported it.

4) Server routes must call only repositories
Cart routes — keep only these paths:

ts
Copy
Edit
// server/routes/cart.ts
import { Router } from "express";
import { CartRepo } from "../repositories/cartRepository";
const router = Router();

router.get("/", async (req, res) => {
  if (!req.user?.id) return res.status(200).json({ items: [], totals: { subtotal:0, shipping:0, tax:0, total:0 }});
  const cart = await CartRepo.validate(req.user.id);
  res.json(cart);
});

router.post("/", async (req, res) => {
  const { productId, qty } = req.body;
  if (!req.user?.id) return res.status(401).json({ message: "Auth required" });
  await CartRepo.addItem(req.user.id, productId, qty ?? 1);
  res.status(200).json({ ok: true });
});

router.delete("/items/:id", async (req, res) => {
  if (!req.user?.id) return res.status(401).json({ message: "Auth required" });
  const r = await CartRepo.removeItem(req.user.id, req.params.id);
  res.status(200).json({ removed: r.rowCount ?? 0 });
});

router.post("/validate", async (req, res) => {
  if (!req.user?.id) return res.status(200).json({ items: [], totals: { subtotal:0, shipping:0, tax:0, total:0 }});
  const out = await CartRepo.validate(req.user.id);
  res.json(out);
});

export default router;
Delete ANY other cart route files (like /api/cart/remove/:id, /cart-legacy/*).

Addresses route must always return a plain array:

ts
Copy
Edit
// server/routes/addresses.ts
import { Router } from "express";
import { AddressRepo } from "../repositories/addressRepository";
const router = Router();

router.get("/", async (req, res) => {
  if (!req.user?.id) return res.json([]);
  const rows = await AddressRepo.list(req.user.id);
  res.json(rows); // <-- array, not {addresses:[]}
});
export default router;
5) Client: point every call at the canonical endpoints only
Create a single API client with cookies:

ts
Copy
Edit
// src/lib/api.ts
import axios from "axios";
export const api = axios.create({ baseURL: "/api", withCredentials: true });
Replace all cart/address calls:

Add to cart → POST /api/cart

Remove from cart → DELETE /api/cart/items/:id

Read cart (Cart & Checkout pages) → GET /api/cart

Validate totals → POST /api/cart/validate

Get addresses → GET /api/addresses (expects array)

Make default → POST /api/addresses/:id/default

Delete address → DELETE /api/addresses/:id (block if default on server)

Unify React Query keys (critical for the “cart & checkout mismatch”):

css
Copy
Edit
["user"], ["addresses"], ["cart"], ["cart-validate"], ["products", ...]
After any add/remove:

ts
Copy
Edit
queryClient.invalidateQueries({ queryKey: ["cart"] });
queryClient.invalidateQueries({ queryKey: ["cart-validate"] });
Normalize addresses on Checkout (fix addresses.find is not a function):

ts
Copy
Edit
const raw = addressesResp?.data;
const addresses: Address[] = Array.isArray(raw) ? raw : Array.isArray(raw?.addresses) ? raw.addresses : [];
const defaultAddr = addresses.find(a => a.isDefault) ?? addresses[0] ?? null;
6) Why rowCount: 0 happens & how this purge fixes it
Old code was writing to a session/legacy store (or alternate table) while the UI was reading from DB repo (or vice-versa) → DB updates report rowCount: 0 because the WHERE user_id never matched (wrong user, wrong cart, or wrong table).

With this purge:

All reads/writes go through CartRepo/AddressRepo (Postgres only).

Old “remove” path /api/cart/remove/:id is gone; only DELETE /api/cart/items/:id remains.

Client & server are in lockstep; checkout and cart use the same query key (["cart"]).

7) Make similar bugs impossible (lint + alias bans)
Add ESLint rule to ban legacy imports. In .eslintrc.*:

json
Copy
Edit
{
  "rules": {
    "no-restricted-imports": ["error", {
      "patterns": [
        "*storage*",
        "*SessionCart*",
        "*cart-legacy*",
        "*addresses-legacy*",
        "*checkout-old*",
        "*checkout-simple*",
        "*ensureProfileComplete*"
      ]
    }]
  }
}
Optionally, add a tsconfig path trap (redirect accidental imports to the kill-switch):

json
Copy
Edit
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "server/storage*": ["server/lib/legacy-guard.ts"]
    }
  }
}
8) Clean caches & rebuild (prevents “zombie” code)
bash
Copy
Edit
rm -rf node_modules .vite .cache dist build .turbo .next .parcel-cache || true
pnpm i || npm i
pnpm dev || npm run dev
9) Quick validation checklist (watch the server logs)
No occurrences of:

storage, SessionCart, cart-legacy, addresses-legacy, /api/cart/remove

Adding/removing items logs only:

POST /api/cart 200

DELETE /api/cart/items/:id 200

GET /api/cart 200

Checkout and Cart both show the same items and totals.

Creating first address auto-defaults; deleting default returns clear 409 CANNOT_DELETE_DEFAULT.

No more rowCount: 0 on cart/addresses writes (updates/inserts should be rowCount: 1).

No 401/403 on cart reads after login (client uses withCredentials: true).

10) Optional: tighten logging so you can prove only one path is used
Add structured logs inside repositories only:

ts
Copy
Edit
console.info("[CART] addItem", { userId, productId, qty });
console.info("[CART] removeItem", { userId, cartItemId });
console.info("[ADDR] list", { userId });
Delete similar logs anywhere else.

11) Commit the purge
bash
Copy
Edit
git add -A
git commit -m "Purge legacy storage, unify on DB repos, lock canonical endpoints"
TL;DR
Delete all legacy/session storage code & routes.

Fail fast if any legacy module is imported (kill-switch).

Use only DB repositories from all routes.

Unify client paths & React Query keys (["cart"] everywhere).

Normalize /api/addresses response to an array.

Rebuild to clear zombie bundles.

Run the steps above and the “storage method called but rowCount: 0” issue—and its cousins—will be gone for good.