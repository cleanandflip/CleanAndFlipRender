Here’s the best, cleanest way for Replit to implement it so the header search:

On Home (/): swaps the homepage sections with an inline products results view (no route change). Close “X” clears search and restores the homepage.

On Products (/products): uses the same header search (unified), keeps you on the products page, and “X” clears the query and restores the normal products view.

URL stays the source of truth (so deep links, refresh, and back/forward all work).

Architecture overview
One shared SearchBar (header) → writes/reads q to/from the URL.

Two routes, same contract:

/ (Home): if q exists ⇒ render InlineResults instead of homepage sections.

/products: always render products page; if q exists ⇒ filter results; if cleared ⇒ show default products view.

No separate header-search component on /products — header search is the only search.

Single results renderer: a ProductsResults component used both inline (home) and native (products).

URL contract (single source of truth)
Query param: q (search term).

Optional params on /products: category, sort, page.

Close (“X”) behavior:

On /: remove q param entirely → homepage sections reappear.

On /products: remove q (and reset page to 1) → default products list.

No route hops for home search. Route remains /. On products, route remains /products.

Files/Modules
swift
Copy
Edit
src/
  lib/
    searchService.ts          // URL helpers (get/set/subscribe)
  components/search/
    SearchBar.tsx             // shared header search (no styling here)
  components/products/
    ProductsResults.tsx       // results grid (accepts query+filters, SSR/CSR ready)
  pages/
    HomePage.tsx              // swaps sections <-> inline results based on q
    ProductsPage.tsx          // filters by q/category/etc, same SearchBar drives it
Step-by-step for Replit
1) Build a tiny URL-driven search service
searchService.ts

getQuery() → { q, category, sort, page } from window.location.search.

setQuery(patch, { replace = false } = {}):

Merge with current params; remove keys set to undefined or "".

Call history.pushState or replaceState with the new URL.

Emit a custom search:changed event (or use a simple subscriber list).

subscribe(fn) → listen to popstate + custom event; return unsubscribe.

This keeps both pages and the header in sync with back/forward and programmatic changes.

2) Shared header SearchBar
Controlled by q from getQuery().

Debounced 300ms writes via setQuery({ q }) (do not navigate).

“X/clear” button: setQuery({ q: undefined, page: 1 }).

Keyboard:

Enter: just commit debounced value immediately (flushDebounce()).

Esc: clear and blur.

Optional: global / shortcut to focus, but only when an input isn’t already focused.

Do not special-case home vs products here. The pages will react to the URL.

3) Home page: swap content when q exists
HomePage.tsx

Read { q } = searchService.getQuery().

If q truthy ⇒ render InlineResults:

A wrapper with the same grid component we use on products.

Include a small “Close” action that calls setQuery({ q: undefined, page: 1 }, { replace: false }).

If q falsy ⇒ render your standard home sections (hero, promos, etc.).

Subscribe to searchService.subscribe() for live updates (and cleanup on unmount).

This gives you the “search overlays the homepage without leaving /” behavior.

4) Products page: same search, no header duplication
ProductsPage.tsx

Remove legacy page search input. Use header SearchBar only.

Read { q, category, sort, page } from searchService.getQuery().

Fetch/filter products using those params (client-side or API).

When “X” (clear) is pressed in header search:

setQuery({ q: undefined, page: 1 }, { replace: false })

Products page re-renders with default list.

Category changes must preserve q and other params:

setQuery({ category: 'dumbbells', page: 1 })

Keep pagination tied to URL param page. Reset to 1 on any q/category/sort change.

5) Single results component used in both places
ProductsResults.tsx

Props: { q, category, sort, page }

Internally handles data load, empty states, and renders the standard product cards.

Emits analytics: search_changed, category_selected.

On page change, call setQuery({ page: n }).

Home uses it inline; /products uses it as the main body.

6) Remove redundancy in header
Delete the right-side “Shop” button entirely.

Keep one small Search icon if desired (optional):

On click: if current path ≠ /products, navigate('/products') without altering q. (But not required since header search works everywhere now.)

Keep Sign In and Cart.

7) Unify animations & a11y (brief)
All buttons/links use your shared Button; category tabs use the same motion tokens.

aria-current="page" for active nav link / active category.

aria-live="polite" on results container, so SRs announce list updates.

8) Kill legacy code
Remove page-level search inputs on /products.

Remove old header-search component(s).

Remove old filter panels + URL writers not in this contract.

Greps to go empty after removal:

nginx
Copy
Edit
rg -n "HeaderSearch|SearchInHeader|FiltersProvider|priceMin|priceMax|brand|condition|header search"
Edge cases & rules
Unknown category slug ⇒ treat as “All Categories” (don’t crash).

Empty q ⇒ no search mode.

Home: show sections.

Products: show default grid.

When route changes from / to /products with an active q:

Works seamlessly because both read the same q.

Back/forward:

Works naturally because q lives in the URL; both pages subscribe to popstate.

Acceptance checklist
 Typing in header search on Home shows inline results without routing.

 Clicking “X” in header search on Home clears results and restores the homepage.

 On Products, typing in header search filters products in place; no extra input on the page.

 “X” on Products clears q and resets the list (and page=1).

 Category switching preserves q, resets page=1, and updates results.

 Back/forward navigates between search states correctly on both routes.

 No leftover header or page search code/components (single SearchBar only).

