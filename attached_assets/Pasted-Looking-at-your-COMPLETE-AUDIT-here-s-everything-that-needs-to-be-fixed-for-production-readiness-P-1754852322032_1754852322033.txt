Looking at your COMPLETE AUDIT, here's everything that needs to be fixed for production readiness:
PRODUCTION READINESS CHECKLIST
ðŸ”´ CRITICAL - BLOCKING LAUNCH
1. PAYMENT PROCESSING COMPLETION
typescript// Stripe webhook verification is BROKEN (mentioned in audit)
// FILE: server/routes/stripe-routes.ts

// FIX webhook signature verification:
router.post('/api/stripe/webhook', 
  express.raw({ type: 'application/json' }), // CRITICAL: Use raw body
  async (req, res) => {
    const sig = req.headers['stripe-signature'];
    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
    
    try {
      const event = stripe.webhooks.constructEvent(
        req.body, // Must be raw body
        sig,
        webhookSecret
      );
      
      // Handle events
      switch (event.type) {
        case 'payment_intent.succeeded':
          // Update order status to confirmed
          const order = await storage.getOrderByPaymentIntentId(event.data.object.id);
          await storage.updateOrderStatus(order.id, 'confirmed');
          await emailService.sendOrderConfirmation(order);
          break;
          
        case 'payment_intent.payment_failed':
          // Handle failed payment
          const failedOrder = await storage.getOrderByPaymentIntentId(event.data.object.id);
          await storage.updateOrderStatus(failedOrder.id, 'payment_failed');
          // Restore inventory
          await restoreInventoryForOrder(failedOrder.id);
          break;
      }
      
      res.json({ received: true });
    } catch (err) {
      console.error('Webhook error:', err.message);
      res.status(400).send(`Webhook Error: ${err.message}`);
    }
  }
);

// Add missing Stripe webhook secret to .env:
STRIPE_WEBHOOK_SECRET=whsec_xxxxx // Get from Stripe Dashboard
2. EMAIL SYSTEM NOT WORKING
typescript// Resend email integration needs to be properly configured
// FILE: server/services/email.ts

import { Resend } from 'resend';

const resend = new Resend(process.env.RESEND_API_KEY);

export const emailService = {
  async sendOrderConfirmation(order) {
    const { data, error } = await resend.emails.send({
      from: 'Clean & Flip <noreply@cleanandflip.com>',
      to: order.user.email,
      subject: `Order Confirmed #${order.orderNumber}`,
      html: `
        <h1>Order Confirmed!</h1>
        <p>Thank you for your order.</p>
        <p>Order Number: ${order.orderNumber}</p>
        <p>Total: $${order.totalAmount}</p>
        <p>We'll notify you when it ships.</p>
      `
    });
    
    if (error) {
      console.error('Email send error:', error);
    }
  },
  
  async sendEquipmentOfferEmail(submission) {
    // Send offer to customer when you want to buy their equipment
  },
  
  async sendShippingNotification(order) {
    // Send when order ships
  }
};

// Verify Resend domain configuration at resend.com/domains
3. SEARCH IS BROKEN (245ms+ slow)
typescript// FILE: server/routes/products.ts
// Fix slow search with proper indexing and query optimization:

// First, add these indexes to database:
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_products_search_gin 
  ON products USING GIN(search_vector) 
  WHERE status = 'active';

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_products_filters 
  ON products(category_id, brand, condition, price) 
  WHERE status = 'active';

// Then optimize the search query:
router.get('/api/products/search', async (req, res) => {
  const { q, category, minPrice, maxPrice, availability } = req.query;
  
  // Use parameterized query for performance
  const query = `
    SELECT p.*, c.name as category_name,
           ts_rank(p.search_vector, query) as rank
    FROM products p
    LEFT JOIN categories c ON p.category_id = c.id,
    plainto_tsquery('english', $1) query
    WHERE p.status = 'active'
      AND p.search_vector @@ query
      ${category ? 'AND p.category_id = $2' : ''}
      ${minPrice ? 'AND p.price >= $3' : ''}
      ${maxPrice ? 'AND p.price <= $4' : ''}
    ORDER BY rank DESC, p.featured DESC
    LIMIT 20
  `;
  
  const results = await db.query(query, [q, category, minPrice, maxPrice].filter(Boolean));
  res.json(results.rows);
});
4. CART DOESN'T PERSIST FOR GUESTS
typescript// FILE: server/routes/cart.ts
// Fix guest cart persistence:

router.get('/api/cart', async (req, res) => {
  if (req.user) {
    const cart = await storage.getCartItems(req.user.id);
    res.json(cart);
  } else {
    // Initialize guest cart in session
    if (!req.session.guestCart) {
      req.session.guestCart = [];
    }
    
    // Return guest cart with product details
    const productIds = req.session.guestCart.map(item => item.productId);
    if (productIds.length > 0) {
      const products = await storage.getProductsByIds(productIds);
      const cartWithProducts = req.session.guestCart.map(item => ({
        ...item,
        product: products.find(p => p.id === item.productId)
      }));
      res.json(cartWithProducts);
    } else {
      res.json([]);
    }
  }
});

// Merge guest cart on login
router.post('/api/auth/login', async (req, res) => {
  // ... existing login logic ...
  
  // After successful login, merge guest cart
  if (req.session.guestCart && req.session.guestCart.length > 0) {
    for (const item of req.session.guestCart) {
      await storage.addToCart(user.id, item.productId, item.quantity);
    }
    delete req.session.guestCart;
  }
});
ðŸŸ¡ HIGH PRIORITY - NEEDED FOR LAUNCH
5. ADMIN DASHBOARD MISSING METRICS
typescript// FILE: server/routes/admin.ts
// Add comprehensive admin metrics:

router.get('/api/admin/metrics', requireAuth, requireRole('developer'), async (req, res) => {
  const metrics = {};
  
  // Today's metrics
  const today = await db.query(`
    SELECT 
      COUNT(*) FILTER (WHERE created_at::date = CURRENT_DATE) as orders_today,
      SUM(total_amount) FILTER (WHERE created_at::date = CURRENT_DATE) as revenue_today,
      COUNT(DISTINCT user_id) FILTER (WHERE created_at::date = CURRENT_DATE) as customers_today
    FROM orders WHERE status != 'cancelled'
  `);
  metrics.today = today.rows[0];
  
  // Inventory alerts
  const inventory = await db.query(`
    SELECT 
      COUNT(*) FILTER (WHERE stock_quantity = 0) as out_of_stock,
      COUNT(*) FILTER (WHERE stock_quantity BETWEEN 1 AND 5) as low_stock,
      COUNT(*) as total_products,
      SUM(price * stock_quantity) as inventory_value
    FROM products WHERE status = 'active'
  `);
  metrics.inventory = inventory.rows[0];
  
  // Equipment submissions pending
  const submissions = await db.query(`
    SELECT COUNT(*) as pending_review
    FROM equipment_submissions 
    WHERE status = 'pending'
  `);
  metrics.submissions = submissions.rows[0];
  
  // Top selling products
  const topProducts = await db.query(`
    SELECT p.name, p.id, COUNT(oi.id) as sold, SUM(oi.quantity * oi.price) as revenue
    FROM products p
    JOIN order_items oi ON p.id = oi.product_id
    JOIN orders o ON oi.order_id = o.id
    WHERE o.created_at >= NOW() - INTERVAL '30 days'
      AND o.status = 'delivered'
    GROUP BY p.id, p.name
    ORDER BY sold DESC
    LIMIT 5
  `);
  metrics.topProducts = topProducts.rows;
  
  res.json(metrics);
});
6. ORDER STATUS WORKFLOW BROKEN
typescript// FILE: server/routes/orders.ts
// Fix order status transitions:

const ORDER_STATUS_MACHINE = {
  'pending': ['confirmed', 'cancelled'],
  'confirmed': ['processing', 'cancelled'],
  'processing': ['shipped', 'cancelled'],
  'shipped': ['delivered', 'returned'],
  'delivered': ['returned'],
  'cancelled': [],
  'returned': ['refunded'],
  'refunded': []
};

router.put('/api/orders/:id/status', requireAuth, requireRole('developer'), async (req, res) => {
  const { status, trackingNumber, carrier, notes } = req.body;
  
  const order = await storage.getOrder(req.params.id);
  if (!order) return res.status(404).json({ error: 'Order not found' });
  
  // Validate status transition
  const allowedStatuses = ORDER_STATUS_MACHINE[order.status];
  if (!allowedStatuses.includes(status)) {
    return res.status(400).json({ 
      error: `Cannot change from ${order.status} to ${status}` 
    });
  }
  
  // Handle status-specific logic
  switch(status) {
    case 'cancelled':
    case 'returned':
      // Restore inventory
      const items = await storage.getOrderItems(order.id);
      for (const item of items) {
        await storage.incrementStock(item.productId, item.quantity);
      }
      break;
      
    case 'shipped':
      // Require tracking info
      if (!trackingNumber || !carrier) {
        return res.status(400).json({ error: 'Tracking info required' });
      }
      await storage.updateOrder(order.id, { trackingNumber, carrier });
      await emailService.sendShippingNotification(order);
      break;
      
    case 'refunded':
      // Process Stripe refund
      await stripe.refunds.create({
        payment_intent: order.stripePaymentIntentId,
        reason: 'requested_by_customer'
      });
      break;
  }
  
  await storage.updateOrderStatus(order.id, status, notes);
  res.json({ success: true });
});
7. IMAGE OPTIMIZATION MISSING
typescript// FILE: client/src/components/ProductImage.tsx
// Add lazy loading and optimization:

const ProductImage = ({ src, alt, className }) => {
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef(null);
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, []);
  
  // Cloudinary optimization parameters
  const optimizedSrc = src.replace('/upload/', '/upload/f_auto,q_auto,w_800/');
  const placeholderSrc = src.replace('/upload/', '/upload/f_auto,q_1,w_50,e_blur:1000/');
  
  return (
    <div ref={imgRef} className={className}>
      {isInView ? (
        <img
          src={optimizedSrc}
          alt={alt}
          loading="lazy"
          className="w-full h-full object-cover"
        />
      ) : (
        <img
          src={placeholderSrc}
          alt={alt}
          className="w-full h-full object-cover blur-lg"
        />
      )}
    </div>
  );
};
8. LOCAL PICKUP vs SHIPPING NOT IMPLEMENTED
typescript// FILE: client/src/pages/checkout.tsx
// Add delivery method selection:

const CheckoutPage = () => {
  const { cart } = useCart();
  const { user } = useAuth();
  const [deliveryMethod, setDeliveryMethod] = useState('shipping');
  
  const isLocalCustomer = user?.zipCode?.startsWith('287') || user?.zipCode?.startsWith('288');
  const shippingCost = deliveryMethod === 'pickup' ? 0 : 
    cart.reduce((sum, item) => sum + (item.product.shippingCost || 15), 0);
  
  return (
    <div>
      {isLocalCustomer && (
        <div className="bg-green-50 p-4 rounded-lg mb-6">
          <h3 className="font-semibold mb-3">Delivery Method</h3>
          <label className="flex items-center mb-2">
            <input
              type="radio"
              value="pickup"
              checked={deliveryMethod === 'pickup'}
              onChange={(e) => setDeliveryMethod(e.target.value)}
              className="mr-2"
            />
            <span>Free Local Pickup (Asheville) - Save ${shippingCost}</span>
          </label>
          <label className="flex items-center">
            <input
              type="radio"
              value="shipping"
              checked={deliveryMethod === 'shipping'}
              onChange={(e) => setDeliveryMethod(e.target.value)}
              className="mr-2"
            />
            <span>Ship to My Address (+${shippingCost})</span>
          </label>
        </div>
      )}
      
      {deliveryMethod === 'pickup' && (
        <div className="bg-blue-50 p-4 rounded-lg mb-6">
          <p className="font-semibold">Pickup Location:</p>
          <p>123 Main Street, Asheville, NC 28801</p>
          <p className="text-sm text-gray-600 mt-2">
            We'll email you when your order is ready (usually within 24 hours)
          </p>
        </div>
      )}
    </div>
  );
};
ðŸŸ¢ IMPORTANT BUT NOT BLOCKING
9. ERROR TRACKING (Use Built-in Instead of Sentry)
typescript// FILE: server/middleware/errorHandler.ts
// Simple error tracking without Sentry:

const errorLog = require('fs').createWriteStream('errors.log', { flags: 'a' });

app.use((err, req, res, next) => {
  const errorData = {
    timestamp: new Date().toISOString(),
    method: req.method,
    url: req.url,
    error: err.message,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,
    user: req.user?.id,
    ip: req.ip
  };
  
  // Log to file
  errorLog.write(JSON.stringify(errorData) + '\n');
  
  // Log to console in development
  if (process.env.NODE_ENV === 'development') {
    console.error(errorData);
  }
  
  // Send appropriate response
  res.status(err.status || 500).json({
    error: process.env.NODE_ENV === 'production' 
      ? 'An error occurred' 
      : err.message
  });
});
10. BASIC TESTING (Minimum for Launch)
bash# Just add basic API testing:
npm install -D jest supertest

# Create test/api.test.js:
const request = require('supertest');
const app = require('../server');

describe('API Tests', () => {
  test('GET /api/products returns products', async () => {
    const res = await request(app).get('/api/products');
    expect(res.statusCode).toBe(200);
    expect(Array.isArray(res.body)).toBe(true);
  });
  
  test('POST /api/auth/login works', async () => {
    const res = await request(app)
      .post('/api/auth/login')
      .send({ email: 'test@test.com', password: 'password' });
    expect(res.statusCode).toBe(200);
  });
});
11. BACKUP SCRIPT
bash# Create backup.sh:
#!/bin/bash
DATE=$(date +%Y%m%d_%H%M%S)
DATABASE_URL="your_database_url"

# Backup database
pg_dump $DATABASE_URL > backups/db_backup_$DATE.sql

# Upload to cloud storage (optional)
# aws s3 cp backups/db_backup_$DATE.sql s3://your-backup-bucket/

# Keep only last 7 days of local backups
find backups/ -name "*.sql" -mtime +7 -delete

# Add to cron for daily backups:
# 0 2 * * * /path/to/backup.sh
12. PERFORMANCE QUICK WINS
sql-- Add these indexes NOW for immediate performance boost:
CREATE INDEX CONCURRENTLY idx_products_active ON products(status) WHERE status = 'active';
CREATE INDEX CONCURRENTLY idx_orders_user_recent ON orders(user_id, created_at DESC);
CREATE INDEX CONCURRENTLY idx_cart_user ON cart_items(user_id);
CREATE INDEX CONCURRENTLY idx_submissions_pending ON equipment_submissions(status) WHERE status = 'pending';

-- Analyze tables for query planner:
ANALYZE products;
ANALYZE orders;
ANALYZE users;
LAUNCH READINESS CHECKLIST
Must Have Before Launch:

 Stripe webhooks working
 Email sending configured
 Search working properly
 Guest cart persistence
 Order status workflow
 Admin can see metrics
 Local pickup option works
 Basic error logging
 Database backups configured
 Performance indexes added

Can Add After Launch:

 Comprehensive testing
 Advanced caching (Redis)
 Advanced monitoring (Sentry)
 Reviews system
 Wishlist (nice to have)
 Advanced image optimization
 API documentation
 Rate limiting refinement

Quick Environment Check:
bash# Make sure these are ALL set in .env:
DATABASE_URL=
SESSION_SECRET=
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=  # GET THIS FROM STRIPE DASHBOARD
CLOUDINARY_CLOUD_NAME=
CLOUDINARY_API_KEY=
CLOUDINARY_API_SECRET=
RESEND_API_KEY=  # GET THIS FROM RESEND.COM
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
VITE_GEOAPIFY_API_KEY=
NODE_ENV=production
Your site can launch once the "Must Have" items are complete. The rest can be iterative improvements.