Complete Google OAuth Integration for Clean & Flip
Based on your codebase audit, you have a session-based auth system with Passport.js. Let's integrate Google OAuth seamlessly with your existing architecture.

PHASE 1: Google Cloud Setup & Secrets
Step 1: Configure Google OAuth Credentials
Instructions for Replit: Add these to your Secrets:
bash# Google OAuth
GOOGLE_CLIENT_ID = your-google-client-id.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET = your-google-client-secret
GOOGLE_CALLBACK_URL = https://your-app.replit.app/api/auth/google/callback

# For development
GOOGLE_CALLBACK_URL_DEV = https://your-repl-name.your-username.repl.co/api/auth/google/callback

# Session (update existing)
SESSION_SECRET = your-existing-secret-keep-this

PHASE 2: Install Required Packages
bashnpm install passport-google-oauth20 @types/passport-google-oauth20

PHASE 3: Database Schema Updates
Create Migration: server/db/migrations/add-google-auth.sql
sql-- Add Google OAuth fields to users table
ALTER TABLE users 
ADD COLUMN IF NOT EXISTS google_id VARCHAR(255) UNIQUE,
ADD COLUMN IF NOT EXISTS google_email VARCHAR(255),
ADD COLUMN IF NOT EXISTS google_picture TEXT,
ADD COLUMN IF NOT EXISTS auth_provider VARCHAR(50) DEFAULT 'local',
ADD COLUMN IF NOT EXISTS profile_complete BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS email_verified BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS onboarding_step INTEGER DEFAULT 0;

-- Create index for faster Google ID lookups
CREATE INDEX IF NOT EXISTS idx_users_google_id ON users(google_id);
CREATE INDEX IF NOT EXISTS idx_users_auth_provider ON users(auth_provider);

-- Create onboarding tracking table
CREATE TABLE IF NOT EXISTS user_onboarding (
  id VARCHAR(255) PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR(255) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  address_completed BOOLEAN DEFAULT false,
  phone_completed BOOLEAN DEFAULT false,
  preferences_completed BOOLEAN DEFAULT false,
  stripe_customer_created BOOLEAN DEFAULT false,
  welcome_email_sent BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id)
);
Update Schema: server/db/schema.ts
typescriptimport { pgTable, varchar, boolean, integer, timestamp, decimal, text, jsonb } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: varchar('id').primaryKey(),
  email: varchar('email').unique().notNull(),
  password: varchar('password'), // Now nullable for Google users
  firstName: varchar('first_name'),
  lastName: varchar('last_name'),
  phone: varchar('phone'),
  
  // Address fields
  street: varchar('street'),
  city: varchar('city'),
  state: varchar('state'),
  zipCode: varchar('zip_code'),
  latitude: decimal('latitude', { precision: 10, scale: 8 }),
  longitude: decimal('longitude', { precision: 11, scale: 8 }),
  
  // Google OAuth fields
  googleId: varchar('google_id').unique(),
  googleEmail: varchar('google_email'),
  googlePicture: text('google_picture'),
  authProvider: varchar('auth_provider').default('local'),
  emailVerified: boolean('email_verified').default(false),
  profileComplete: boolean('profile_complete').default(false),
  onboardingStep: integer('onboarding_step').default(0),
  
  // Existing fields
  role: varchar('role').default('user'),
  stripeCustomerId: varchar('stripe_customer_id'),
  stripeSubscriptionId: varchar('stripe_subscription_id'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow()
});

export const userOnboarding = pgTable('user_onboarding', {
  id: varchar('id').primaryKey(),
  userId: varchar('user_id').notNull().unique(),
  addressCompleted: boolean('address_completed').default(false),
  phoneCompleted: boolean('phone_completed').default(false),
  preferencesCompleted: boolean('preferences_completed').default(false),
  stripeCustomerCreated: boolean('stripe_customer_created').default(false),
  welcomeEmailSent: boolean('welcome_email_sent').default(false),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow()
});

PHASE 4: Google OAuth Strategy Implementation
Create: server/auth/google-strategy.ts
typescriptimport passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import { db } from '../db';
import { users, userOnboarding } from '../db/schema';
import { eq } from 'drizzle-orm';
import { v4 as uuidv4 } from 'uuid';

const GOOGLE_CONFIG = {
  clientID: process.env.GOOGLE_CLIENT_ID!,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
  callbackURL: process.env.NODE_ENV === 'production' 
    ? process.env.GOOGLE_CALLBACK_URL!
    : process.env.GOOGLE_CALLBACK_URL_DEV!,
  scope: ['profile', 'email']
};

export function initializeGoogleAuth() {
  passport.use(new GoogleStrategy(
    GOOGLE_CONFIG,
    async (accessToken, refreshToken, profile, done) => {
      try {
        console.log('[AUTH] Google authentication for:', profile.emails?.[0]?.value);
        
        // Extract user info from Google profile
        const googleId = profile.id;
        const email = profile.emails?.[0]?.value;
        const firstName = profile.name?.givenName || '';
        const lastName = profile.name?.familyName || '';
        const picture = profile.photos?.[0]?.value;
        
        if (!email) {
          return done(new Error('No email from Google'), null);
        }
        
        // Check if user exists by Google ID
        let [existingUser] = await db
          .select()
          .from(users)
          .where(eq(users.googleId, googleId))
          .limit(1);
        
        if (existingUser) {
          // Existing Google user - update last login
          await db.update(users)
            .set({ 
              updatedAt: new Date(),
              googlePicture: picture // Update picture in case it changed
            })
            .where(eq(users.id, existingUser.id));
          
          console.log('[AUTH] Existing Google user logged in:', email);
          return done(null, existingUser);
        }
        
        // Check if user exists by email (might be converting from email/password)
        [existingUser] = await db
          .select()
          .from(users)
          .where(eq(users.email, email))
          .limit(1);
        
        if (existingUser) {
          // User exists with email/password - link Google account
          await db.update(users)
            .set({
              googleId,
              googleEmail: email,
              googlePicture: picture,
              authProvider: 'google',
              emailVerified: true,
              updatedAt: new Date()
            })
            .where(eq(users.id, existingUser.id));
          
          console.log('[AUTH] Linked Google to existing account:', email);
          return done(null, { ...existingUser, googleId });
        }
        
        // New user - create account
        const newUserId = uuidv4();
        
        const [newUser] = await db.insert(users)
          .values({
            id: newUserId,
            email,
            googleId,
            googleEmail: email,
            googlePicture: picture,
            firstName,
            lastName,
            authProvider: 'google',
            emailVerified: true,
            profileComplete: false,
            onboardingStep: 1,
            role: 'user'
          })
          .returning();
        
        // Create onboarding record
        await db.insert(userOnboarding)
          .values({
            id: uuidv4(),
            userId: newUserId,
            addressCompleted: false,
            phoneCompleted: false,
            preferencesCompleted: false,
            stripeCustomerCreated: false,
            welcomeEmailSent: false
          });
        
        console.log('[AUTH] New Google user created:', email);
        return done(null, newUser);
        
      } catch (error) {
        console.error('[AUTH] Google strategy error:', error);
        return done(error as Error, null);
      }
    }
  ));
}

PHASE 5: Update Authentication System
Update: server/auth.ts
typescriptimport passport from 'passport';
import { db } from './db';
import { users } from './db/schema';
import { eq } from 'drizzle-orm';
import { initializeGoogleAuth } from './auth/google-strategy';

// Initialize strategies
initializeGoogleAuth();

// Existing local strategy remains...
// Add this to your existing auth.ts

passport.serializeUser((user: any, done) => {
  done(null, user.id);
});

passport.deserializeUser(async (id: string, done) => {
  try {
    const [user] = await db
      .select()
      .from(users)
      .where(eq(users.id, id))
      .limit(1);
    
    done(null, user || null);
  } catch (error) {
    done(error, null);
  }
});

// Middleware to check profile completion
export function requireCompleteProfile(req: any, res: any, next: any) {
  if (!req.user) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  
  if (!req.user.profileComplete) {
    return res.status(403).json({ 
      error: 'Profile incomplete',
      onboardingStep: req.user.onboardingStep,
      redirect: '/onboarding'
    });
  }
  
  next();
}

PHASE 6: API Routes for Google Auth
Update: server/routes/auth.ts
typescriptimport { Router } from 'express';
import passport from 'passport';
import { db } from '../db';
import { users, userOnboarding } from '../db/schema';
import { eq } from 'drizzle-orm';

const router = Router();

// Existing routes remain...

// Google OAuth routes
router.get('/google',
  passport.authenticate('google', { scope: ['profile', 'email'] })
);

router.get('/google/callback',
  passport.authenticate('google', { failureRedirect: '/login?error=google_auth_failed' }),
  async (req, res) => {
    const user = req.user as any;
    
    // Check if profile is complete
    if (!user.profileComplete) {
      // Redirect to onboarding
      res.redirect('/onboarding?step=' + (user.onboardingStep || 1));
    } else {
      // Redirect to dashboard or original destination
      const returnTo = req.session.returnTo || '/dashboard';
      delete req.session.returnTo;
      res.redirect(returnTo);
    }
  }
);

// Onboarding endpoints
router.post('/onboarding/address', async (req, res) => {
  if (!req.user) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  
  const { street, city, state, zipCode, phone } = req.body;
  const userId = (req.user as any).id;
  
  try {
    // Update user address and phone
    await db.update(users)
      .set({
        street,
        city,
        state,
        zipCode,
        phone,
        onboardingStep: 2,
        updatedAt: new Date()
      })
      .where(eq(users.id, userId));
    
    // Update onboarding tracking
    await db.update(userOnboarding)
      .set({
        addressCompleted: true,
        phoneCompleted: !!phone,
        updatedAt: new Date()
      })
      .where(eq(userOnboarding.userId, userId));
    
    res.json({ success: true, nextStep: 2 });
  } catch (error) {
    console.error('[ONBOARDING] Address update error:', error);
    res.status(500).json({ error: 'Failed to update address' });
  }
});

router.post('/onboarding/complete', async (req, res) => {
  if (!req.user) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  
  const userId = (req.user as any).id;
  
  try {
    // Create Stripe customer if needed
    const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
    const [user] = await db.select().from(users).where(eq(users.id, userId));
    
    if (!user.stripeCustomerId) {
      const customer = await stripe.customers.create({
        email: user.email,
        name: `${user.firstName} ${user.lastName}`,
        metadata: { userId }
      });
      
      await db.update(users)
        .set({ 
          stripeCustomerId: customer.id,
          profileComplete: true,
          onboardingStep: 0,
          updatedAt: new Date()
        })
        .where(eq(users.id, userId));
    } else {
      await db.update(users)
        .set({ 
          profileComplete: true,
          onboardingStep: 0,
          updatedAt: new Date()
        })
        .where(eq(users.id, userId));
    }
    
    // Mark onboarding complete
    await db.update(userOnboarding)
      .set({
        stripeCustomerCreated: true,
        updatedAt: new Date()
      })
      .where(eq(userOnboarding.userId, userId));
    
    res.json({ success: true, redirect: '/dashboard' });
  } catch (error) {
    console.error('[ONBOARDING] Completion error:', error);
    res.status(500).json({ error: 'Failed to complete onboarding' });
  }
});

// Check auth status
router.get('/status', (req, res) => {
  if (req.user) {
    const user = req.user as any;
    res.json({
      authenticated: true,
      user: {
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        profileComplete: user.profileComplete,
        onboardingStep: user.onboardingStep,
        authProvider: user.authProvider,
        role: user.role
      }
    });
  } else {
    res.json({ authenticated: false });
  }
});

export default router;

PHASE 7: Frontend Components
Create: client/src/components/auth/GoogleSignInButton.tsx
typescriptimport { Button } from '../ui/button';
import { Chrome } from 'lucide-react';

export function GoogleSignInButton({ 
  action = 'signin',
  className = '' 
}: { 
  action?: 'signin' | 'signup';
  className?: string;
}) {
  const handleGoogleAuth = () => {
    // Store current location to return after auth
    sessionStorage.setItem('authReturnTo', window.location.pathname);
    window.location.href = '/api/auth/google';
  };
  
  return (
    <Button
      onClick={handleGoogleAuth}
      className={`w-full bg-white text-gray-700 border border-gray-300 hover:bg-gray-50 ${className}`}
      type="button"
    >
      <Chrome className="w-5 h-5 mr-2" />
      {action === 'signup' ? 'Sign up with Google' : 'Sign in with Google'}
    </Button>
  );
}
Create: client/src/pages/Onboarding.tsx
typescriptimport { useState, useEffect } from 'react';
import { useLocation, useRoute } from 'wouter';
import { Card } from '../components/ui/card';
import { Button } from '../components/ui/button';
import { Input } from '../components/ui/input';
import { Label } from '../components/ui/label';
import { Progress } from '../components/ui/progress';
import { useAuth } from '../hooks/useAuth';

export function Onboarding() {
  const [, setLocation] = useLocation();
  const [, params] = useRoute('/onboarding');
  const { user, refetch } = useAuth();
  const [step, setStep] = useState(1);
  const [loading, setLoading] = useState(false);
  
  const [formData, setFormData] = useState({
    street: '',
    city: '',
    state: '',
    zipCode: '',
    phone: ''
  });
  
  useEffect(() => {
    if (user?.profileComplete) {
      setLocation('/dashboard');
    }
    if (user?.onboardingStep) {
      setStep(user.onboardingStep);
    }
  }, [user]);
  
  const handleAddressSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    
    try {
      const response = await fetch('/api/auth/onboarding/address', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
        credentials: 'include'
      });
      
      if (response.ok) {
        setStep(2);
        refetch();
      }
    } catch (error) {
      console.error('Address update failed:', error);
    } finally {
      setLoading(false);
    }
  };
  
  const completeOnboarding = async () => {
    setLoading(true);
    
    try {
      const response = await fetch('/api/auth/onboarding/complete', {
        method: 'POST',
        credentials: 'include'
      });
      
      if (response.ok) {
        const data = await response.json();
        setLocation(data.redirect || '/dashboard');
      }
    } catch (error) {
      console.error('Onboarding completion failed:', error);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 py-12">
      <div className="max-w-2xl mx-auto px-4">
        <Card className="p-8">
          <div className="mb-6">
            <h1 className="text-2xl font-bold mb-2">
              Welcome to Clean & Flip, {user?.firstName}!
            </h1>
            <p className="text-gray-600">
              Let's complete your profile to get started
            </p>
            <Progress value={(step / 2) * 100} className="mt-4" />
          </div>
          
          {step === 1 && (
            <form onSubmit={handleAddressSubmit} className="space-y-4">
              <h2 className="text-lg font-semibold mb-4">Shipping Address</h2>
              
              <div>
                <Label htmlFor="street">Street Address</Label>
                <Input
                  id="street"
                  required
                  value={formData.street}
                  onChange={(e) => setFormData({...formData, street: e.target.value})}
                  placeholder="123 Main St"
                />
              </div>
              
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="city">City</Label>
                  <Input
                    id="city"
                    required
                    value={formData.city}
                    onChange={(e) => setFormData({...formData, city: e.target.value})}
                    placeholder="Asheville"
                  />
                </div>
                
                <div>
                  <Label htmlFor="state">State</Label>
                  <Input
                    id="state"
                    required
                    maxLength={2}
                    value={formData.state}
                    onChange={(e) => setFormData({...formData, state: e.target.value.toUpperCase()})}
                    placeholder="NC"
                  />
                </div>
              </div>
              
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="zipCode">ZIP Code</Label>
                  <Input
                    id="zipCode"
                    required
                    pattern="[0-9]{5}"
                    value={formData.zipCode}
                    onChange={(e) => setFormData({...formData, zipCode: e.target.value})}
                    placeholder="28801"
                  />
                </div>
                
                <div>
                  <Label htmlFor="phone">Phone (Optional)</Label>
                  <Input
                    id="phone"
                    type="tel"
                    value={formData.phone}
                    onChange={(e) => setFormData({...formData, phone: e.target.value})}
                    placeholder="(555) 123-4567"
                  />
                </div>
              </div>
              
              <Button type="submit" disabled={loading} className="w-full">
                {loading ? 'Saving...' : 'Continue'}
              </Button>
            </form>
          )}
          
          {step === 2 && (
            <div className="space-y-6">
              <div className="text-center py-8">
                <div className="w-20 h-20 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-4">
                  <svg className="w-10 h-10 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                  </svg>
                </div>
                <h2 className="text-xl font-semibold mb-2">You're All Set!</h2>
                <p className="text-gray-600 mb-6">
                  Your profile is complete. Start browsing our premium fitness equipment.
                </p>
                <Button onClick={completeOnboarding} disabled={loading} size="lg">
                  {loading ? 'Setting up...' : 'Go to Dashboard'}
                </Button>
              </div>
            </div>
          )}
        </Card>
      </div>
    </div>
  );
}
Update: client/src/components/auth/LoginForm.tsx
typescriptimport { GoogleSignInButton } from './GoogleSignInButton';
// ... existing imports

export function LoginForm() {
  // ... existing code
  
  return (
    <Card>
      <CardHeader>
        <CardTitle>Sign In</CardTitle>
      </CardHeader>
      <CardContent>
        {/* Google Sign In - Primary */}
        <GoogleSignInButton action="signin" />
        
        <div className="relative my-6">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t border-gray-300"></div>
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-2 bg-white text-gray-500">Or continue with email</span>
          </div>
        </div>
        
        {/* Existing email/password form */}
        <form onSubmit={handleSubmit}>
          {/* ... existing form fields */}
        </form>
      </CardContent>
    </Card>
  );
}

PHASE 8: Protected Route Updates
Update: client/src/hooks/useAuth.ts
typescriptimport { useQuery } from '@tanstack/react-query';

export function useAuth() {
  const { data, isLoading, refetch } = useQuery({
    queryKey: ['auth-status'],
    queryFn: async () => {
      const response = await fetch('/api/auth/status', {
        credentials: 'include'
      });
      return response.json();
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
  
  return {
    user: data?.user,
    isAuthenticated: data?.authenticated,
    isLoading,
    profileComplete: data?.user?.profileComplete,
    needsOnboarding: data?.authenticated && !data?.user?.profileComplete,
    refetch
  };
}
Update: client/src/App.tsx
typescriptimport { Onboarding } from './pages/Onboarding';
import { useAuth } from './hooks/useAuth';
import { useLocation } from 'wouter';

function App() {
  const { user, needsOnboarding } = useAuth();
  const [location, setLocation] = useLocation();
  
  // Redirect to onboarding if needed
  useEffect(() => {
    if (needsOnboarding && !location.includes('/onboarding')) {
      setLocation('/onboarding');
    }
  }, [needsOnboarding, location]);
  
  return (
    <Routes>
      {/* ... existing routes */}
      <Route path="/onboarding" component={Onboarding} />
    </Routes>
  );
}

PHASE 9: Session & Security Updates
Update: server/index.ts
typescript// Ensure session is configured before passport
app.use(session({
  secret: process.env.SESSION_SECRET!,
  resave: false,
  saveUninitialized: false,
  store: new PgSession({
    pool: sessionPool,
    tableName: 'sessions'
  }),
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
    sameSite: 'lax'
  }
}));

app.use(passport.initialize());
app.use(passport.session());

// Protected route middleware
app.use('/api/cart', requireAuth);
app.use('/api/orders', requireAuth);
app.use('/api/checkout', requireAuth, requireCompleteProfile);

PHASE 10: Testing & Verification
Create: scripts/test-google-auth.ts
typescript#!/usr/bin/env node

async function testGoogleAuth() {
  console.log('üîç Google OAuth Configuration Test\n');
  
  // Check environment variables
  const required = [
    'GOOGLE_CLIENT_ID',
    'GOOGLE_CLIENT_SECRET',
    'GOOGLE_CALLBACK_URL',
    'SESSION_SECRET'
  ];
  
  const missing = required.filter(key => !process.env[key]);
  
  if (missing.length > 0) {
    console.error('‚ùå Missing required secrets:');
    missing.forEach(key => console.error(`   - ${key}`));
    process.exit(1);
  }
  
  console.log('‚úÖ All Google OAuth secrets configured');
  
  // Test database fields exist
  const { db } = require('../server/db');
  try {
    await db.raw`SELECT google_id, auth_provider, profile_complete FROM users LIMIT 1`;
    console.log('‚úÖ Database has Google OAuth fields');
  } catch (error) {
    console.error('‚ùå Database missing Google OAuth fields');
    console.error('   Run: npm run db:migrate');
  }
}

testGoogleAuth();

DEPLOYMENT CHECKLIST

Run database migration: npm run db:migrate
Set Google OAuth secrets in Replit
Update Google Cloud Console:

Add https://your-app.replit.app/api/auth/google/callback to authorized redirects


Test locally: npm run dev
Deploy and test production OAuth flow


SUCCESS INDICATORS
‚úÖ Users can click "Sign in with Google"
‚úÖ New users are redirected to onboarding
‚úÖ Address collection works after Google auth
‚úÖ Existing email users can link Google account
‚úÖ Sessions persist across page refreshes
‚úÖ Protected routes check profile completion
‚úÖ Stripe customer created after onboarding
‚úÖ Cart, checkout, orders work with Google users
This comprehensive implementation ensures Google OAuth works flawlessly with your existing Clean & Flip architecture!