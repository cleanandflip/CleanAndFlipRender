Here's a prompt for Replit:

FIX: Cart Page Using Cached Images - Need Real-Time Product Sync
Issue: Cart page shows old/cached product images and data. When products are updated in admin, cart doesn't reflect changes.
Required Fixes:
1. Update Cart API to Join Fresh Product Data:
javascript// In cart GET endpoint - always fetch fresh product data
app.get('/api/cart', async (req, res) => {
  const userId = req.user?.id || null;
  const sessionId = req.sessionID;
  
  try {
    // Get cart items
    const cartItems = await storage.getCart(userId, sessionId);
    
    // Join with FRESH product data - don't rely on stored cart data
    const cartWithProducts = await Promise.all(
      cartItems.map(async (item) => {
        const freshProduct = await storage.getProduct(item.productId);
        
        // If product deleted or not available
        if (!freshProduct || freshProduct.status !== 'active') {
          // Optionally remove from cart
          await storage.removeFromCart(item.id);
          return null;
        }
        
        // Return cart item with FRESH product data
        return {
          ...item,
          product: {
            id: freshProduct.id,
            name: freshProduct.name,
            price: freshProduct.price,
            images: freshProduct.images, // Fresh images!
            brand: freshProduct.brand,
            stock: freshProduct.stock,
            status: freshProduct.status
          }
        };
      })
    );
    
    // Filter out null items (deleted products)
    const validCartItems = cartWithProducts.filter(item => item !== null);
    
    res.json(validCartItems);
  } catch (error) {
    console.error('Get cart error:', error);
    res.status(500).json({ error: 'Failed to fetch cart' });
  }
});
2. Frontend Cart Component - No Image Caching:
javascript// components/CartItem.jsx
const CartItem = ({ item, onUpdate, onRemove }) => {
  // Always use fresh product data from API
  const { product } = item;
  
  // Force fresh images by adding timestamp
  const getImageUrl = (url) => {
    if (!url) return null;
    // Add cache-busting parameter
    return `${url}?t=${Date.now()}`;
  };
  
  return (
    <div className="flex items-center gap-4 p-4 bg-gray-800/50 rounded-lg">
      {/* Product Image - No caching */}
      <div className="w-24 h-24 bg-gray-900 rounded-lg overflow-hidden">
        {product.images?.length > 0 ? (
          <img 
            src={getImageUrl(product.images[0])}
            alt={product.name}
            className="w-full h-full object-cover"
            // Force reload
            key={`${product.id}-${Date.now()}`}
          />
        ) : (
          <div className="flex items-center justify-center h-full">
            <Package className="w-12 h-12 text-gray-600" />
          </div>
        )}
      </div>
      
      {/* Product Info - Always fresh */}
      <div className="flex-1">
        <h3 className="font-medium text-white">{product.name}</h3>
        <p className="text-gray-400 text-sm">{product.brand}</p>
        
        {/* Stock warning if low */}
        {product.stock === 1 && (
          <p className="text-red-400 text-sm mt-1">Only 1 left in stock</p>
        )}
        {product.stock === 0 && (
          <p className="text-red-600 text-sm mt-1">Out of stock</p>
        )}
      </div>
      
      {/* Quantity Controls */}
      <div className="flex items-center gap-2">
        <button 
          onClick={() => onUpdate(item.id, Math.max(1, item.quantity - 1))}
          className="w-8 h-8 rounded bg-gray-700 hover:bg-gray-600"
          disabled={product.stock === 0}
        >
          -
        </button>
        <span className="w-8 text-center">{item.quantity}</span>
        <button 
          onClick={() => onUpdate(item.id, Math.min(product.stock, item.quantity + 1))}
          className="w-8 h-8 rounded bg-gray-700 hover:bg-gray-600"
          disabled={item.quantity >= product.stock}
        >
          +
        </button>
      </div>
      
      {/* Price - Fresh from product */}
      <div className="text-right">
        <p className="text-xl font-bold text-white">${product.price}</p>
        <p className="text-gray-500 text-sm">${product.price} each</p>
      </div>
      
      {/* Remove button */}
      <button
        onClick={() => onRemove(item.id)}
        className="p-2 text-gray-400 hover:text-red-400"
      >
        <Trash2 className="w-5 h-5" />
      </button>
    </div>
  );
};
3. Add Real-Time Cart Updates:
javascript// Cart page component
const CartPage = () => {
  const { data: cartItems, refetch } = useQuery({
    queryKey: ['cart'],
    queryFn: fetchCart,
    staleTime: 0, // Always fetch fresh
    cacheTime: 0, // No caching
    refetchOnMount: 'always',
    refetchOnWindowFocus: true
  });
  
  // Listen for product updates
  useEffect(() => {
    const handleProductUpdate = (event) => {
      // Refetch cart when products change
      refetch();
    };
    
    window.addEventListener('productUpdated', handleProductUpdate);
    window.addEventListener('productDeleted', handleProductUpdate);
    
    return () => {
      window.removeEventListener('productUpdated', handleProductUpdate);
      window.removeEventListener('productDeleted', handleProductUpdate);
    };
  }, [refetch]);
  
  // Validate cart on mount
  useEffect(() => {
    validateCart();
  }, []);
  
  const validateCart = async () => {
    // Check if all cart items are still valid
    try {
      await fetch('/api/cart/validate', {
        method: 'POST',
        credentials: 'include'
      });
      refetch();
    } catch (error) {
      console.error('Cart validation error:', error);
    }
  };
  
  return (
    // Cart UI
  );
};
4. Add Cart Validation Endpoint:
javascript// Validate and clean cart
app.post('/api/cart/validate', async (req, res) => {
  const userId = req.user?.id || null;
  const sessionId = req.sessionID;
  
  const cartItems = await storage.getCart(userId, sessionId);
  const updates = [];
  
  for (const item of cartItems) {
    const product = await storage.getProduct(item.productId);
    
    // Remove if product deleted
    if (!product || product.status !== 'active') {
      await storage.removeFromCart(item.id);
      updates.push({ action: 'removed', itemId: item.id });
      continue;
    }
    
    // Adjust quantity if stock changed
    if (item.quantity > product.stock) {
      await storage.updateCartItem(item.id, { 
        quantity: product.stock 
      });
      updates.push({ 
        action: 'adjusted', 
        itemId: item.id, 
        newQuantity: product.stock 
      });
    }
  }
  
  res.json({ updates });
});
5. No CDN Caching for Product Images:
javascript// When serving images or using Cloudinary
const imageUrl = cloudinary.url(publicId, {
  version: Date.now(), // Force fresh version
  transformation: [...],
  sign_url: true // Prevent caching
});
KEY FIXES:

✅ Cart always fetches fresh product data
✅ No image caching with timestamp parameters
✅ Real-time sync when products update
✅ Auto-remove deleted products from cart
✅ Validate stock levels on cart load
✅ Listen for product update events

This ensures the cart always shows current product info and images!