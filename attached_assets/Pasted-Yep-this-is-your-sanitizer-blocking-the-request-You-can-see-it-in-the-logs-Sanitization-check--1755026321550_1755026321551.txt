Yep—this is your sanitizer blocking the request. You can see it in the logs:

“Sanitization check – path: /cart” (legacy endpoint still firing)

400 with { "error": "Invalid input data", "message": "Request contains potentially unsafe content" }

Fix = 3 parts: (1) kill legacy /cart, (2) whitelist /api/cart or correct the sanitizer, (3) validate the JSON body and return a useful error.

1) Client: stop hitting /cart forever
Search and remove all legacy calls:

bash
Copy
Edit
rg -n "\"/cart\"" src
There should be zero occurrences after this.

Centralize one helper and use it everywhere:

ts
Copy
Edit
// src/api/cart.ts
export async function addToCart({ productId, variantId, quantity = 1 }:{
  productId: string; variantId?: string; quantity?: number;
}) {
  const res = await fetch("/api/cart", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    credentials: "include",
    body: JSON.stringify({ productId, variantId, quantity }), // only these keys
  });
  const text = await res.text();
  if (!res.ok) throw new Error(`Add to cart failed ${res.status}: ${text}`);
  return text ? JSON.parse(text) : {};
}
Wire the button to this helper only. Confirm in the Network tab: one request → POST /api/cart.

2) Server: fix or bypass the sanitizer for /api/cart
Your sanitizer is throwing the 400. Make it safe and narrow:

Only inspect string fields (ignore numbers/booleans)

Apply to known user-input routes, not backend-only IDs

Add /api/cart to the allowlist; or update rules so { productId, variantId, quantity } always pass

Example middleware (replace your current “potentially unsafe content” logic):

ts
Copy
Edit
// middleware/sanitize.ts
const FORBIDDEN = /(<|>|script:|javascript:|data:|on\w+=)/i;

export function sanitizeRequest(req, res, next) {
  const url = req.path;

  // Allowlist backend JSON endpoints we trust/validate separately
  const allow = [
    /^\/api\/cart$/,
    /^\/api\/user$/,
    /^\/api\/products$/,
    /^\/api\/track-activity$/,
  ];
  if (allow.some(rx => rx.test(url))) return next();

  // Only scan string fields (ignore numbers/arrays/objects recursively)
  const scan = (val): boolean => {
    if (typeof val === "string") return FORBIDDEN.test(val);
    if (val && typeof val === "object") return Object.values(val).some(scan);
    return false;
  };

  if (scan(req.body) || scan(req.query) || scan(req.params)) {
    return res.status(400).json({
      error: "Invalid input data",
      message: "Request contains potentially unsafe content",
    });
  }
  next();
}
Mount after express.json() and before your routes:

ts
Copy
Edit
app.use(express.json());
app.use(sanitizeRequest);
If you want to keep scanning /api/cart, that’s fine—productId may contain hyphens or hex; the regex above will not flag it. The old sanitizer likely flagged because it scanned numbers/IDs or matched too broadly.

3) /api/cart validation & clear errors
Keep strict schema so you still block bad data (but with actionable messages):

ts
Copy
Edit
import { z } from "zod";

const AddSchema = z.object({
  productId: z.string().min(1),          // Mongo/ObjectId/UUID all ok
  variantId: z.string().optional(),
  quantity: z.number().int().positive().default(1),
});

app.post("/api/cart", async (req, res) => {
  console.info("POST /api/cart body:", req.body); // TEMP debugging
  const parse = AddSchema.safeParse(req.body);
  if (!parse.success) {
    return res.status(400).json({ error: "Invalid input", details: parse.error.flatten() });
  }
  const { productId, variantId, quantity } = parse.data;

  const cartId = await getOrCreateCartId(req, res);
  const product = await db.products.findById(productId);
  if (!product) return res.status(404).json({ error: "Product not found" });
  if (product.stock <= 0) return res.status(409).json({ error: "Out of stock" });

  const updated = await carts.addItem({ cartId, productId, variantId, quantity });
  return res.status(200).json(updated);
});
Guest cart cookie helper (if userId is undefined):

ts
Copy
Edit
function getOrCreateCartId(req, res) {
  let { cartId } = req.cookies || {};
  if (!cartId) {
    cartId = crypto.randomUUID();
    res.cookie("cartId", cartId, {
      httpOnly: true, sameSite: "Lax",
      secure: process.env.NODE_ENV === "production",
      path: "/", maxAge: 1000*60*60*24*30
    });
    carts.create(cartId);
  }
  return cartId;
}
4) Delete or hard-redirect the legacy endpoint
Remove the route entirely. If you must keep it for a day:

ts
Copy
Edit
app.post("/cart", (_req, res) => res.redirect(308, "/api/cart"));
But please delete it after confirming all clients use /api/cart.

5) Quick verification
Console log in handler should show:

css
Copy
Edit
POST /api/cart body: { productId: "abc123", quantity: 1 }
Logs should not show POST /cart anymore.

Add an item → POST /api/cart 200 and mini-cart updates.

Try a bad request (missing productId) → you get structured Zod errors, not “potentially unsafe content”.

6) If it still 400s
Paste the request body your server logs for /api/cart and the sanitizer code it’s using. I’ll identify the exact condition triggering the false positive and give you the one-line change.








Ask ChatGPT
