Ultimate Comprehensive Codebase Documentation Prompt
markdown
Please perform an EXHAUSTIVE analysis of my entire codebase, leaving absolutely nothing undocumented. I need you to examine EVERY file, EVERY function, EVERY variable, and EVERY configuration. Create a complete technical bible that documents:

## PRELIMINARY DEEP SCAN INSTRUCTIONS
Before documenting, perform these checks:
1. Scan ALL directories including hidden folders (.git, .vscode, etc.)
2. Read EVERY file including .env.example, .gitignore, README, licenses
3. Check package-lock.json for exact dependency versions
4. Examine all comments, TODO notes, and FIXME markers
5. Identify all console.log statements and debug code
6. Find all hardcoded values and magic numbers
7. Detect all unused imports and dead code
8. Map all import/export relationships between files

## 1. COMPLETE FILE SYSTEM FORENSICS
For EVERY file in the project:

Exact file path and name
File size in bytes
Last modified timestamp
Purpose and responsibility
Dependencies it imports
What exports from it
Who/what consumes it
Language/framework (TS, TSX, JS, CSS, etc.)
Line count
TODO/FIXME comments within
Deprecated status
Test coverage status

## 2. ONBOARDING SYSTEM DEEP DIVE
Document the COMPLETE onboarding flow:

### User Onboarding Journey
- First-time user detection logic
- Welcome screens/modals sequence
- Profile completion steps (exact order)
- Required vs optional fields at each step
- Validation at each step
- Progress indicators and state persistence
- Skip/back button logic
- Incomplete profile redirects
- Onboarding completion triggers
- Post-onboarding actions
- A/B testing variants (if any)
- Analytics events fired
- Default values set during onboarding
- Email verification within onboarding
- Phone verification process
- Address validation and local customer detection
- Terms acceptance flow
- Tutorial/tour implementations

### Google OAuth Onboarding Specifics
- New vs existing user detection
- Profile data mapping from Google
- Missing data collection steps
- Forced onboarding for OAuth users
- Session handling during OAuth onboarding

### Code Locations
- All onboarding components
- Onboarding hooks and contexts
- Onboarding API endpoints
- Database fields tracking onboarding

## 3. ROUTING MATRIX (COMPLETE)
### Frontend Routes
Path | Component | Guards | Params | Query Strings | State Required | Redirects | Analytics | SEO Meta


### API Endpoints
Method | Path | Auth | Role | Rate Limit | Validation | Cache | Timeout | Retry Logic | Error Codes


### Redirect Logic Map
- All redirect conditions
- Redirect priorities
- Circular redirect prevention
- Deep link handling
- 404 handling
- Authentication redirects
- Role-based redirects

## 4. DATABASE ARCHITECTURE
### Every Table Structure
```sql
-- Include actual CREATE TABLE statements
-- All indexes (including compound)
-- Triggers and their logic
-- Views and materialized views
-- Stored procedures
-- Foreign key relationships
-- Check constraints
-- Default values and their logic
-- Auto-increment sequences
-- Partitioning strategy
Data Flow Patterns
CRUD operation paths
Transaction boundaries
Cascade behaviors
Soft delete implementations
Audit trail mechanisms
Database connection pooling
Query optimization hints
Backup triggers
5. COMPONENT DEEP ANALYSIS
For EVERY component, document:

typescript
// Component signature
interface Props {
  // Every prop with exact type
  // Optional vs required
  // Default values
  // Validation rules
}

// State Management
- useState declarations (all)
- useReducer patterns
- useRef usage
- Context consumption
- Redux/Zustand connections

// Lifecycle
- Mount behavior
- Update triggers
- Cleanup functions
- Memory leak prevention

// Performance
- Memo usage
- useCallback patterns
- useMemo implementations
- Re-render triggers
- Bundle size impact

// Side Effects
- API calls timing
- Event listener attachments
- Subscription patterns
- WebSocket connections
- Timer/interval usage
6. AUTHENTICATION MATRIX
Session Lifecycle
Session creation exact flow
Cookie attributes (all)
Token structure and claims
Refresh token mechanism
Session storage location
Expiry handling
Concurrent session policy
Device fingerprinting
Remember me implementation
Logout propagation
Permission System
Resource | Anonymous | User | Admin | Developer | Conditions | Exceptions
Security Checkpoints
Every auth check location
Bypass conditions (if any)
Fallback behaviors
Auth state synchronization
Cross-tab authentication
7. STATE MANAGEMENT MICROSCOPE
Global State Architecture
typescript
// Document entire state tree structure
{
  auth: {
    user: { /* all fields */ },
    session: { /* all fields */ },
    // ... complete structure
  },
  cart: {
    // ... complete structure
  },
  // ... all slices
}
State Mutations
Every action/mutation
Trigger conditions
Side effects
Subscriptions
Persistence rules
Optimistic updates
Rollback mechanisms
Cache Invalidation Matrix
Action | Invalidates | Refetches | Optimistic | Rollback | Retry
8. BUSINESS LOGIC DOCUMENTATION
Every Algorithm
typescript
// For each business logic function:
- Mathematical formulas used
- Edge cases handled
- Boundary conditions
- Null/undefined handling
- Error scenarios
- Performance complexity (O notation)
- Test coverage
Pricing Engine
Base price calculation
Discount application order
Tax calculation (by region)
Shipping calculation matrix
Currency conversion
Rounding rules
Promotional logic
Bundle pricing
Minimum order values
Maximum order limits
Inventory System
Stock tracking method
Reserved vs available
Low stock thresholds
Automatic reorder points
Stock synchronization
Oversell prevention
Backorder handling
9. THIRD-PARTY INTEGRATION DETAILS
For EACH external service:

yaml
Service: [Name]
Credentials:
  - Environment variables used
  - API keys location
  - Secret rotation policy
Endpoints:
  - Every endpoint called
  - Request format
  - Response format
  - Error responses
Rate Limits:
  - Requests per second/minute/hour
  - Burst allowances
  - Retry strategies
Webhooks:
  - Webhook URLs
  - Verification method
  - Payload structures
  - Retry behavior
  - Failed webhook handling
Fallbacks:
  - Service unavailable handling
  - Timeout behaviors
  - Circuit breaker patterns
  - Cache strategies
Testing:
  - Sandbox environments
  - Test credentials
  - Mock responses
10. UI/UX IMPLEMENTATION SPECS
Design System Audit
css
/* Document every: */
- CSS variable
- Tailwind class used
- Custom CSS rule
- Media query
- Animation keyframe
- Transition timing
- Z-index layer
- Font stack
- Icon library usage
- SVG implementations
Component States
For every interactive element:

Default state
Hover state
Active state
Disabled state
Loading state
Error state
Success state
Focus state (keyboard nav)
Touch states (mobile)
Responsive Behavior
Component | Mobile | Tablet | Desktop | Wide | Breakpoint Overrides
11. FORM ECOSYSTEM
Every Form Field
typescript
Field | Type | Validation | Sanitization | Error Messages | Dependent Fields | API Mapping
Form Behaviors
Auto-save logic
Draft persistence
Multi-step state management
Progress calculation
Validation timing (onChange/onBlur/onSubmit)
Error display strategy
Success feedback
Reset mechanisms
Dirty state tracking
12. SECURITY AUDIT CHECKLIST
Document presence/absence of:

 HTTPS enforcement
 Security headers (all)
 Content Security Policy
 CORS configuration (exact)
 Rate limiting (per endpoint)
 Input sanitization (per field)
 SQL injection prevention
 XSS protection
 CSRF tokens
 File upload validation
 Path traversal prevention
 Dependency vulnerabilities
 Secrets in code
 API key exposure
 Session fixation protection
 Clickjacking prevention
 Man-in-the-middle protection
13. PERFORMANCE PROFILING
Load Time Analysis
Resource | Size | Load Time | Critical Path | Lazy Loaded | Cached
Runtime Performance
React DevTools profiler results
Component render times
Expensive operations
Memory leaks locations
Bundle size per route
Code splitting boundaries
Dynamic import points
Service worker strategy
CDN usage
Image optimization
Font loading strategy
14. ERROR TRACKING
Error Boundary Coverage
Component | Has Boundary | Fallback UI | Error Logging | Recovery Method
Error Scenarios
For each possible error:

Error trigger condition
Error message shown to user
Technical error logged
Stack trace handling
User recovery options
Automatic recovery attempts
Support contact triggered?
Analytics event fired?
15. WEBSOCKET ARCHITECTURE
Event Catalog
typescript
// For every WebSocket event:
{
  eventName: string,
  direction: 'client->server' | 'server->client' | 'bidirectional',
  payload: { /* exact structure */ },
  triggerConditions: string[],
  handlers: string[], // file:function references
  acknowledgment: boolean,
  timeout: number,
  retryPolicy: { /* retry configuration */ }
}
Connection Lifecycle
Connection establishment
Authentication flow
Heartbeat mechanism
Reconnection strategy (exact algorithm)
Exponential backoff parameters
Max retry attempts
Connection pooling
Room/channel management
Broadcasting rules
16. BUILD & DEPLOYMENT PIPELINE
Build Process
bash
# Document every build step
1. Pre-build hooks
2. Environment variable injection
3. TypeScript compilation settings
4. Bundle generation
5. Optimization passes
6. Asset processing
7. Source map generation
8. Post-build hooks
Environment Matrix
Variable | Dev Value | Staging Value | Prod Value | Required | Default | Validation
Deployment Checklist
 Database migrations run?
 Environment variables set?
 SSL certificates valid?
 CDN cache purged?
 Monitoring alerts configured?
 Backup verified?
 Rollback plan ready?
 Feature flags set?
 A/B tests configured?
 Analytics verified?
17. TESTING INFRASTRUCTURE
Test Coverage Map
File | Lines | Branches | Functions | Statements | Uncovered Lines
Test Scenarios
Unit test locations
Integration test flows
E2E test scripts
Performance benchmarks
Security test suites
Accessibility audits
Visual regression tests
API contract tests
Load test configurations
18. CODEBASE METRICS
Code Quality Metrics
Cyclomatic complexity per function
Code duplication percentage
Technical debt locations
Code smell inventory
Dependency depth
Coupling metrics
Cohesion analysis
Lines of code per file
Comment-to-code ratio
Test-to-code ratio
Dependency Analysis
Package | Version | Direct/Transitive | Usage Count | Security Issues | License | Size
19. CONFIGURATION DEEP DIVE
For EVERY config file, provide:

Complete file contents
Every setting explained
Default vs custom values
Override mechanisms
Environment-specific overrides
Runtime vs build-time configs
Hot-reload capabilities
Validation rules
Dependencies on other configs
20. USER JOURNEY MAPS
Every Possible User Path
mermaid
graph TD
    Start --> [Every Decision Point]
    [Every Decision Point] --> [Outcomes]
Document:

Entry points
Decision trees
Exit points
Abandoned flow recovery
Analytics funnel events
Conversion bottlenecks
Alternative paths
Error recovery flows
Support intervention points
21. DATA FLOW TRACKING
Every Data Transformation
Source | Transformation | Destination | Validation | Error Handling | Audit Trail
API Data Flow
Request transformation
Response transformation
DTO mappings
Serialization rules
Deserialization rules
Null handling
Type coercion
Date/timezone handling
22. SMALL BUT CRITICAL DETAILS
Document ALL of these often-missed items:

Hidden Configurations
Service worker scopes
Manifest.json settings
Robot.txt rules
Sitemap generation
.npmrc settings
Git hooks
Pre-commit rules
CI/CD variables
Docker configurations
Kubernetes manifests
Developer Experience
Available npm scripts (all)
Debugging commands
Environment setup steps
Common troubleshooting
Local development proxies
Mock data locations
Seed data scripts
Database reset procedures
Cache clearing methods
Business Rules
Email templates (all)
SMS templates
Push notification templates
Cron job schedules
Background job queues
Scheduled maintenance windows
Feature flag configurations
A/B test variations
Analytics event taxonomy
Custom metrics definitions
Edge Cases & Gotchas
Browser-specific workarounds
Third-party SDK quirks
Race condition handlers
Timezone considerations
Locale-specific logic
Currency precision rules
Character encoding issues
File system limitations
Memory constraints
Connection pool limits
Support & Operations
Admin panel capabilities
Super admin functions
Support tool integrations
Monitoring dashboards
Alert configurations
Log retention policies
Backup schedules
Disaster recovery procedures
Incident response protocols
Customer data export/import
FINAL VERIFICATION CHECKLIST
After documentation, confirm:

 Every file in the project is documented
 Every function has its purpose explained
 Every API endpoint is mapped
 Every database field is defined
 Every environment variable is listed
 Every user action is traced
 Every error scenario is covered
 Every third-party integration is detailed
 Every configuration option is explained
 Every TODO/FIXME is catalogued
 Every deprecated feature is marked
 Every security measure is verified
 Every performance optimization is noted
 Every business rule is documented
 Every edge case is identified
Provide this documentation in a structured format with:

Clear section numbering
Searchable headings
Code examples for everything
Actual values (not placeholders)
File location references
Cross-references between related sections
Visual diagrams where helpful
Decision trees for complex logic
A comprehensive index
A glossary of terms
This documentation should be so complete that:

A new developer can understand the entire system
The application can be rebuilt from scratch
All business logic is preserved
No implementation detail is lost
Every "why" behind the code is explained

This enhanced prompt ensures absolutely nothing is missed, including:
- Complete onboarding system documentation
- Small but critical details like cron jobs, email templates
- Hidden configurations and developer tools
- Edge cases and gotchas
- Support and operational procedures
- Cross-references and relationships
- Business rules and compliance requirements
- Performance bottlenecks and optimization opportunities

The prompt now instructs the AI to perform a preliminary deep scan before documenting, ensuring even commented-out code, TODOs, and debug statements are captured.




