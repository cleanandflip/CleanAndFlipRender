Here’s a tight, end-to-end fix plan Replit can apply so the checkout always prefills the user’s DEFAULT address, lets the user switch to another saved address (or enter a one-off), and keeps the Local Customer checks accurate everywhere (miles only).

1) Server: enforce SSOT + “local” in miles
1.1 Add/verify these contracts
GET /api/user → must include:

ts
Copy
Edit
{
  id: string,
  email: string,
  firstName: string,
  lastName: string,
  profile_address_id: string | null,
  profileAddress?: AddressDTO | null,   // join on profile_address_id
  isLocalUser?: boolean                 // derived from profileAddress.is_local (see 1.3)
}
GET /api/addresses → returns { addresses: AddressDTO[] } sorted default-first.

GET /api/addresses?default=true → returns { address: AddressDTO | null }.

PATCH /api/addresses/:id/default → atomically:

UPDATE addresses SET is_default=false WHERE user_id=$userId;

UPDATE addresses SET is_default=true WHERE id=$id AND user_id=$userId;

UPDATE users SET profile_address_id=$id WHERE id=$userId;

Recompute and persist addresses.is_local for that row (see 1.2) and expose computed isLocalUser (1.3).

Return the new default row.

DELETE /api/addresses/:id → 400 if is_default=true.

1.2 Local delivery = 50 miles
In server/lib/addressCanonicalizer.ts (or wherever distance is computed), replace KM with miles:

ts
Copy
Edit
const EARTH_RADIUS_MI = 3958.7613;

export function haversineMiles(a: {lat:number, lng:number}, b: {lat:number, lng:number}) {
  const toRad = (n:number) => (n * Math.PI) / 180;
  const dLat = toRad(b.lat - a.lat);
  const dLng = toRad(b.lng - a.lng);
  const lat1 = toRad(a.lat);
  const lat2 = toRad(b.lat);
  const h =
    Math.sin(dLat/2)**2 +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng/2)**2;
  return 2 * EARTH_RADIUS_MI * Math.asin(Math.sqrt(h));
}
When creating/updating an address or toggling default, set:

ts
Copy
Edit
address.is_local = haversineMiles(address, WAREHOUSE_COORDS) <= 50;
1.3 Single source of truth for “local”
Do not store users.is_local. Instead, compute and return it off the default/profile address:

ts
Copy
Edit
// in /api/user response builder
const profileAddress = row.profile_address_id ? getAddress(row.profile_address_id) : null;
const isLocalUser = !!profileAddress?.is_local;
return { ...user, profileAddress, isLocalUser };
2) Client: reliable default prefill + chooser + live “local” updates
2.1 A tiny, reusable default selector
Create client/src/hooks/useDefaultAddress.ts:

ts
Copy
Edit
import { useMemo } from "react";

export function useDefaultAddress(user:any, addresses:any[]) {
  const pid = user?.profile_address_id ?? user?.profileAddress?.id ?? null;
  return useMemo(() => {
    const list = Array.isArray(addresses) ? addresses : [];
    return (pid && list.find(a => a.id === pid))
        || list.find(a => a.is_default)
        || user?.profileAddress
        || null;
  }, [pid, addresses, user?.profileAddress]);
}
2.2 Make checkout prefill from SSOT (and never race)
In client/src/pages/checkout.tsx:

ts
Copy
Edit
const qc = useQueryClient();

const { data: userResp }       = useQuery(["user"], api.getUser);
const { data: addrResp }       = useQuery(["addresses"], api.getAddresses, { staleTime: 30_000 });
const addresses = addrResp?.addresses ?? [];
const user = userResp ?? null;

const defaultAddr = useDefaultAddress(user, addresses);

const prefilledRef = useRef(false);
useEffect(() => {
  if (!prefilledRef.current && defaultAddr) {
    form.reset({
      firstName: user?.firstName ?? "",
      lastName:  user?.lastName  ?? "",
      email:     user?.email     ?? "",
      phone:     user?.phone     ?? "",
      street:    defaultAddr.street ?? "",
      address2:  defaultAddr.address2 ?? "",
      city:      defaultAddr.city ?? "",
      state:     defaultAddr.state ?? "",
      zipCode:   defaultAddr.zipCode ?? "",
      country:   defaultAddr.country ?? "US",
      geoapify_place_id: defaultAddr.geoapify_place_id ?? "",
      latitude:  defaultAddr.latitude ?? null,
      longitude: defaultAddr.longitude ?? null,
      saveToProfile: false,
      deliveryInstructions: "",
    });
    setUsingSavedAddressId(defaultAddr.id);
    prefilledRef.current = true;
  }
}, [defaultAddr, user]);
This waits for both queries to resolve and only resets once, so user typing isn’t blown away.

2.3 Give the user a proper address switcher
Add client/src/components/addresses/AddressPicker.tsx (simple modal/radio list). On select:

tsx
Copy
Edit
<AddressPicker
  addresses={addresses}
  currentId={usingSavedAddressId ?? defaultAddr?.id ?? null}
  onPick={(id) => {
    // promote selection to default server-side to keep SSOT clean
    mutateDefaultAddress.mutate(id, {
      onSuccess: () => {
        setUsingSavedAddressId(id);
        prefilledRef.current = false; // allow one more form reset from new default
        qc.invalidateQueries({ queryKey: ["user"] });
        qc.invalidateQueries({ queryKey: ["addresses"] });
        qc.invalidateQueries({ queryKey: ["shipping:quotes"] });
      }
    });
  }}
/>
The button row near the checkbox could read:

sql
Copy
Edit
Using: Default address (Change)
and switches to “Saved address” if the chosen one isn’t default yet (but our mutation makes it default immediately).

2.4 Geoapify autocomplete must populate all fields
In client/src/components/ui/address-autocomplete.tsx, normalize the selection:

ts
Copy
Edit
function geoapifyToForm(s:any){
  // Handles both "street + housenumber" and componentized results
  const street =
    s.properties?.address_line1 ??
    [s.properties?.housenumber, s.properties?.street].filter(Boolean).join(" ");

  return {
    street,
    address2: s.properties?.unit ?? "",
    city: s.properties?.city || s.properties?.town || s.properties?.village || "",
    state: s.properties?.state_code || s.properties?.state || "",
    zipCode: s.properties?.postcode || "",
    country: s.properties?.country_code?.toUpperCase() || "US",
    geoapify_place_id: s.properties?.place_id || s.properties?.datasource?.raw?.place_id || "",
    latitude: s.properties?.lat ?? s.properties?.lat || s.geometry?.coordinates?.[1] ?? null,
    longitude: s.properties?.lon ?? s.properties?.lng || s.geometry?.coordinates?.[0] ?? null,
  };
}

onSuggestionSelect = (s) => {
  const v = geoapifyToForm(s);
  form.setValue("street", v.street, { shouldDirty:true });
  form.setValue("address2", v.address2 ?? "");
  form.setValue("city", v.city ?? "");
  form.setValue("state", v.state ?? "");
  form.setValue("zipCode", v.zipCode ?? "");
  form.setValue("country", v.country ?? "US");
  form.setValue("geoapify_place_id", v.geoapify_place_id ?? "");
  form.setValue("latitude", v.latitude ?? null);
  form.setValue("longitude", v.longitude ?? null);
};
2.5 “Local Customer” checks everywhere (client)
Create client/src/hooks/useLocalCustomer.ts:

ts
Copy
Edit
export function useLocalCustomer() {
  const { data: user } = useQuery(["user"], api.getUser);
  const { data: defaultResp } = useQuery(["addresses","default"], api.getDefaultAddress, { enabled: !!user });
  const addr = defaultResp?.address ?? user?.profileAddress ?? null;
  return !!addr?.is_local; // SSOT: derived from default address
}
Use this in:

Checkout (to choose shipping methods)

Cart drawer CTA (to show “Local delivery available”)

Dashboard banners

When user changes default via AddressPicker, we already invalidate ["user"] & ["addresses"], so useLocalCustomer() re-runs automatically.

3) Dashboard “Addresses” tab — clear default & delete behavior
Show a “Default” pill next to the default card title.

“Make Default” button hits PATCH /api/addresses/:id/default and then invalidates ["user"] + ["addresses"].

Show Delete only when !is_default. On delete success, invalidate ["addresses"].

If the user deletes every address, the checkout should start blank but still function (unsaved address path).

4) Checkout totals & guardrails (fix the $0 issue and crashes)
In checkout summary, never assume arrays exist:

ts
Copy
Edit
const items = Array.isArray(cart?.items) ? cart.items : [];
Line total fallback:

ts
Copy
Edit
const lineTotal = toCents(line.total ?? (line.unit && line.qty ? line.unit * line.qty : 0));
Disable Continue to Payment until:

ts
Copy
Edit
const formOK = form.formState.isValid;
const hasItems = items.length > 0;
const addressOK = !!form.getValues("street") && !!form.getValues("city") && !!form.getValues("state") && !!form.getValues("zipCode");
const shippingOK = !!selectedQuoteId || !requiresShipping; // depending on your rules
// Button disabled={!formOK || !hasItems || !addressOK || !shippingOK}
5) Remove lingering legacy gating that blocks checkout
Anywhere you redirect to onboarding because “no address”:

Replace with soft gating inside checkout:

If no default address → prefill from user name/email, leave address empty, show banner:
“Add your shipping address or Choose saved address”.

Delete old guards such as if (!user.profileComplete) navigate("/onboarding?...").

6) What likely caused your current “no prefill” bug (fix now)
Race: the form reset ran before addresses loaded. ✅ Solved by 2.2.

Field name mismatch (zip_code vs zipCode, address2 vs apartment): ensure your server DTO uses camelCase and the form uses the same keys. If needed, normalize in the mapper that builds AddressDTO.

profile_address_id not returned from /api/user or not respected client-side. ✅ We use it in useDefaultAddress.

Address toggle didn’t update users.profile_address_id. ✅ Enforced in 1.1 PATCH route.

Locality still in KM → caused “No options yet” for shipping. ✅ 1.2 switches to miles.

7) Quick manual test checklist (do all 6)
User with two addresses (A default local, B non-local).

Open /checkout → prefilled with A, “Using: Default address”.

Shipping methods show Local delivery (within 50 miles).

Click Change saved address → pick B.

Form repopulates with B.

Default pill on Dashboard flips to B after refresh.

useLocalCustomer() flips to false; local options disappear.

Enter an unsaved address in the form (don’t check “Save to profile”).

Quotes compute off this unsaved address.

“Using: Unsaved address”.

Go to Dashboard → cannot delete the Default address, can delete the other.

Make the other default → now you can delete the previous one.

Cart/Checkout never crashes: no .length/.map errors with empty data.

Geoapify pick fills all fields (street/city/state/zip/country + lat/lng + place_id).

If Replit applies the snippets exactly (server contracts + the three small hooks and the AddressPicker), the checkout will always prefill from the default address, users can switch or enter another address, and the Local Customer status will follow the default address automatically across the whole app.









Ask ChatGPT
