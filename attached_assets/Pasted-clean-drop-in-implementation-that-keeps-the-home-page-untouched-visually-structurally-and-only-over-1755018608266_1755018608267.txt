clean, drop-in implementation that keeps the home page untouched visually/structurally and only overlays results when the user types in the nav search. Clearing (X) restores home. On /products, the same header search filters in place; no duplicate page search.

I’m giving you minimal, framework-agnostic React/TS code (no styling) so Replit can skin it with your theme.

1) URL search service (single source of truth)
src/lib/searchService.ts

ts
Copy
Edit
// Tiny URL state helper for q/category/sort/page
type Query = { q: string; category: string; sort: string; page: number };

const parse = (): Query => {
  const sp = new URLSearchParams(window.location.search);
  const q         = (sp.get("q") ?? "");
  const category  = (sp.get("category") ?? "");
  const sort      = (sp.get("sort") ?? "");
  const pageRaw   = Number(sp.get("page") ?? "1");
  const page      = Number.isFinite(pageRaw) && pageRaw > 0 ? pageRaw : 1;
  return { q, category, sort, page };
};

const write = (next: Partial<Query>, opts: { replace?: boolean } = {}) => {
  const sp = new URLSearchParams(window.location.search);
  for (const [k, v] of Object.entries(next)) {
    if (v === undefined || v === null || v === "") sp.delete(k);
    else sp.set(k, String(v));
  }
  const url = `${window.location.pathname}${sp.toString() ? "?" + sp.toString() : ""}`;
  (opts.replace ? history.replaceState : history.pushState).call(history, null, "", url);
  // notify listeners
  window.dispatchEvent(new PopStateEvent("popstate"));
};

type Unsub = () => void;
const subs = new Set<() => void>();
const subscribe = (fn: () => void): Unsub => {
  subs.add(fn);
  const handler = () => fn();
  window.addEventListener("popstate", handler);
  return () => { subs.delete(fn); window.removeEventListener("popstate", handler); };
};

export const searchService = {
  getQuery: parse,
  setQuery: write,
  subscribe,
};
2) Shared header search (no page-specific code here)
src/components/search/SearchBar.tsx

tsx
Copy
Edit
import * as React from "react";
import { searchService } from "@/lib/searchService";

type Props = {
  placeholder?: string;
  autoFocus?: boolean;
  id?: string;
};

export default function SearchBar({ placeholder = "Search equipment...", autoFocus, id }: Props) {
  const [value, setValue] = React.useState<string>(searchService.getQuery().q);
  const flushRef = React.useRef<number | null>(null);

  React.useEffect(() => {
    // keep input in sync with URL (back/forward, programmatic changes)
    return searchService.subscribe(() => setValue(searchService.getQuery().q));
  }, []);

  const commit = React.useCallback((next: string) => {
    // When clearing, also reset page to 1
    searchService.setQuery({ q: next, page: 1 });
  }, []);

  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const next = e.currentTarget.value ?? "";
    setValue(next);
    // debounce 300ms
    if (flushRef.current) window.clearTimeout(flushRef.current);
    flushRef.current = window.setTimeout(() => commit(next), 300);
  };

  const onKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      if (flushRef.current) { window.clearTimeout(flushRef.current); flushRef.current = null; }
      commit(value);
    }
    if (e.key === "Escape") {
      setValue("");
      commit("");
      (e.currentTarget as HTMLInputElement).blur();
    }
  };

  const clear = () => { setValue(""); commit(""); };

  return (
    <div role="search">
      <input
        id={id}
        type="search"
        value={value}
        onChange={onChange}
        onKeyDown={onKeyDown}
        placeholder={placeholder}
        autoFocus={autoFocus}
        aria-label="Search products"
      />
      {/* Replit: style & place this clear control in the input as an 'X' */}
      {value && <button type="button" onClick={clear} aria-label="Clear search">×</button>}
    </div>
  );
}
This component only reads/writes q in the URL. Pages decide what to render based on q.

3) Results renderer used by both Home (inline) and Products
src/components/products/ProductsResults.tsx

tsx
Copy
Edit
import * as React from "react";
import { searchService } from "@/lib/searchService";

export type Product = {
  id: string;
  name?: string;
  brand?: string;
  category?: string; // slug
  price?: number;
  imageUrl?: string;
};

type Props = {
  // If you already use RTK Query/SWR, replace this with your fetch hook.
  fetchProducts: (args: { q: string; category: string; sort: string; page: number }) => {
    data: Product[] | undefined;
    total?: number;
    loading: boolean;
    error?: unknown;
  };
  header?: React.ReactNode; // slot (optional)
  emptyState?: React.ReactNode; // slot (optional)
};

export default function ProductsResults({ fetchProducts, header, emptyState }: Props) {
  const { q, category, sort, page } = searchService.getQuery();
  const { data, loading, error } = fetchProducts({ q, category, sort, page });

  // re-render on URL updates
  React.useEffect(() => {
    return searchService.subscribe(() => {
      // This component will re-render because we read from getQuery() at render time,
      // but we can force update if needed by setting state.
    });
  }, []);

  if (error) return <div role="alert">Something went wrong.</div>;

  return (
    <section aria-live="polite">
      {header}
      {loading && <div>Loading…</div>}
      {!loading && (data?.length ?? 0) === 0 && (emptyState ?? <div>No results.</div>)}
      <div>
        {(data ?? []).map(p => (
          <article key={p.id}>
            {/* Replit: render your ProductCard here */}
            <div>{p.name}</div>
          </article>
        ))}
      </div>
      {/* Replit: wire your pagination UI; update page via searchService.setQuery({ page: n }) */}
    </section>
  );
}
4) Home page: do not alter your existing sections—just add an overlay switch
src/pages/HomePage.tsx

tsx
Copy
Edit
import * as React from "react";
import { searchService } from "@/lib/searchService";
import ProductsResults from "@/components/products/ProductsResults";
// import useFetchProducts or your existing data hook
import { useFetchProducts } from "@/queries/products"; // example

function HomeSections() {
  // ✅ your original homepage markup here untouched (hero, tiles, promos, etc.)
  return <>{/* ... */}</>;
}

export default function HomePage() {
  const [q, setQ] = React.useState(searchService.getQuery().q);

  React.useEffect(() => searchService.subscribe(() => setQ(searchService.getQuery().q)), []);

  // If no query -> render original home. Query present -> render inline results.
  if (!q) return <HomeSections />;

  const clear = () => searchService.setQuery({ q: "", page: 1 });

  return (
    <div>
      {/* Inline "search mode" header (optional): show current query and an X to exit */}
      <div>
        <span>Results for “{q}”</span>
        <button type="button" onClick={clear} aria-label="Clear search">×</button>
      </div>

      <ProductsResults
        fetchProducts={useFetchProducts}
        emptyState={<div>No matches. Clear or try another term.</div>}
      />
    </div>
  );
}
Result: typing in the nav SearchBar sets ?q=…; home swaps to results view. Clicking the X (in the SearchBar or here) clears q and immediately restores your original home sections.

5) Products page: use the same header search; remove page search
src/pages/ProductsPage.tsx

tsx
Copy
Edit
import * as React from "react";
import ProductsResults from "@/components/products/ProductsResults";
import { useFetchProducts } from "@/queries/products"; // example
import { searchService } from "@/lib/searchService";

export default function ProductsPage() {
  // No extra search input here. Header SearchBar drives q.
  // Reset page to 1 whenever q/category/sort changes (optional: put in fetch hook).
  React.useEffect(() => {
    return searchService.subscribe(() => {
      // if you keep page in URL, your results component will pick it up automatically
    });
  }, []);

  return (
    <ProductsResults
      fetchProducts={useFetchProducts}
      emptyState={<div>No products found. Try another query.</div>}
    />
  );
}
6) Header: keep your layout, just swap in the shared SearchBar
src/components/layout/Header.tsx

tsx
Copy
Edit
import SearchBar from "@/components/search/SearchBar";

export default function Header() {
  return (
    <header>
      {/* left: logo + nav links */}
      <nav>{/* Shop | Sell | About | Contact */}</nav>

      {/* right: unified SearchBar + Sign In + Cart */}
      <div>
        <SearchBar />
        {/* <Button>Sign In</Button>  <CartIconButton /> */}
      </div>
    </header>
  );
}
Remove any old header-search code/components.

No special routing here—SearchBar writes q to the URL; pages react.

7) Guard your product filtering (avoid the .trim() crash)
If you use a useProducts client-side filter, make sure it’s null-safe:

ts
Copy
Edit
// src/hooks/useProducts.ts
const safe = (v: unknown) => (typeof v === "string" ? v.toLowerCase() : v == null ? "" : String(v).toLowerCase());
const getQ = (sp: URLSearchParams) => { const x = sp.get("q"); return typeof x === "string" ? x.trim().toLowerCase() : ""; };
Always default to "" before .trim().

8) Behavior checklist (what you asked for)
Home /:

Typing in header search shows results inline (no route change).

Clicking “X” in header search (or inline header) clears results and restores original homepage.

Products /products:

Same header search filters products in place.

“X” clears q and shows default grid.

Both routes:

URL is the single source of truth (?q=…).

Back/forward navigates between search states correctly.

No duplicate page search on /products.

That’s it—copy these files in, wire your existing fetcher into ProductsResults, and adapt useFetchProducts to your API contract next.