deep, implementation-ready instructions for Replit to replace the filter panel on /products with a simple, left-side Category Tabs navigation. No UI/color code—just structure, logic, routing, and data flow. Replit can skin it with your theme.

High-Level Objective
Remove the existing multi-filter sidebar.

Add a left column containing a vertical list of categories (names only, no counts).

Clicking a category:

Updates the URL (/products?category=<slug>, omit the param for “All Categories”).

Filters products (client-side or server query).

Preserves the current search term (?q=...) so search + category combine.

Works on page load via deep links (reads ?category).

Accessible (keyboard focus, aria-current on active category).

Mobile: same categories but the component can collapse/stack—Replit handles styling.

File/Module Plan
swift
Copy
Edit
src/
  lib/
    categories.ts             // canonical labels + slug helpers
  components/products/
    CategoryTabs.tsx          // left nav (logic only, no styling)
  hooks/
    useProducts.ts            // data layer: pulls from API or filters in memory
  pages/
    ProductsPage.tsx          // wire-up: layout + search + tabs + grid
1) Canonical Categories + Slug Helpers
src/lib/categories.ts

ts
Copy
Edit
export const CATEGORY_LABELS = [
  "All Categories",
  "Dumbbells",
  "Kettlebells",
  "Weight Plates",
  "Barbells",
  "Adjustable Dumbbells",
  "Resistance & Bands",
  "Medicine Balls",
  "Mats & Accessories",
] as const;

export type CategoryLabel = (typeof CATEGORY_LABELS)[number];

export function toSlug(label: string): string {
  if (/^all categories$/i.test(label)) return ""; // represent "All" as absent
  return label
    .toLowerCase()
    .replace(/&/g, "and")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "");
}

export function fromSlug(slug: string | null): CategoryLabel {
  if (!slug) return "All Categories";
  const match = CATEGORY_LABELS.find((l) => toSlug(l) === slug.toLowerCase());
  return match ?? "All Categories";
}
Acceptance:

toSlug("Weight Plates") -> "weight-plates"

toSlug("Resistance & Bands") -> "resistance-and-bands"

fromSlug(null) -> "All Categories"

fromSlug("unknown") -> "All Categories"

2) Category Tabs Component (logic only)
src/components/products/CategoryTabs.tsx

tsx
Copy
Edit
import React from "react";
import { useNavigate, useSearchParams } from "react-router-dom";
import { CATEGORY_LABELS, CategoryLabel, fromSlug, toSlug } from "@/lib/categories";

export default function CategoryTabs() {
  const [params] = useSearchParams();
  const navigate = useNavigate();

  const current: CategoryLabel = fromSlug(params.get("category"));

  const select = (label: CategoryLabel) => {
    const next = new URLSearchParams(params);
    const slug = toSlug(label);
    if (slug) next.set("category", slug);
    else next.delete("category"); // All -> remove param

    // Keep existing search term and other params intact:
    const query = next.toString();
    navigate(`/products${query ? `?${query}` : ""}`, { replace: false });
  };

  // Render list of buttons/links. Replit: style to your theme.
  return (
    <nav aria-label="Product Categories">
      <ul>
        {CATEGORY_LABELS.map((label) => {
          const active = label === current;
          return (
            <li key={label}>
              <button
                type="button"
                onClick={() => select(label)}
                aria-current={active ? "page" : undefined}
              >
                {label}
              </button>
            </li>
          );
        })}
      </ul>
    </nav>
  );
}
Notes

No counts rendered. Names only.

aria-current="page" on the active tab for a11y.

Replit: apply layout/spacing/hover/active styles to match your theme.

3) Data Layer: Use Search Params to Filter
You likely already have a data hook. Ensure it reacts to q and category:

Option A — Client-side filtering (all products loaded)
src/hooks/useProducts.ts

ts
Copy
Edit
import { useMemo } from "react";
import { useSearchParams } from "react-router-dom";
import { fromSlug, toSlug } from "@/lib/categories";

export type Product = {
  id: string;
  name: string;
  category?: string; // store as slug, e.g., "dumbbells"
  price?: number;
  // ...other fields
};

export function useProducts(allProducts: Product[]) {
  const [params] = useSearchParams();
  const q = (params.get("q") || "").trim().toLowerCase();
  const categoryLabel = fromSlug(params.get("category"));
  const categorySlug = toSlug(categoryLabel); // "" when "All Categories"

  const filtered = useMemo(() => {
    let list = allProducts;

    if (categorySlug) {
      list = list.filter((p) => (p.category || "") === categorySlug);
    }

    if (q) {
      list = list.filter((p) =>
        [p.name, p.category].filter(Boolean).join(" ").toLowerCase().includes(q)
      );
    }

    return list;
  }, [allProducts, q, categorySlug]);

  return { products: filtered, q, categoryLabel, categorySlug };
}
Option B — Server/API filtering
Ensure the backend supports the same query params: GET /api/products?q=..&category=..

If category missing → return all categories.

If category present but no matches → return [] with 200.

Generic backend logic (pseudo)

ts
Copy
Edit
// Express, pseudo:
app.get("/api/products", async (req, res) => {
  const q = (req.query.q as string | undefined) ?? "";
  const category = (req.query.category as string | undefined) ?? "";

  // Validate category against allowed slugs if needed

  // Example SQL:
  // SELECT * FROM products
  // WHERE (category = :category OR :category = '')
  //   AND (LOWER(name) LIKE :q OR :q = '')

  // Example Mongo:
  // const where: any = {};
  // if (category) where.category = category;
  // if (q) where.name = { $regex: q, $options: "i" };

  // return res.json(results);
});
4) Wire Up /products Page
src/pages/ProductsPage.tsx (structure only; Replit adds layout/styling)

tsx
Copy
Edit
import React from "react";
import { useSearchParams } from "react-router-dom";
import CategoryTabs from "@/components/products/CategoryTabs";
import { useProducts } from "@/hooks/useProducts";

export default function ProductsPage() {
  // 1) Load all products (however your app does it)
  // Example: const { data: allProducts, isLoading, error } = useAllProductsQuery();
  const allProducts: any[] = []; // replace with real source

  // 2) Derive filtered list from params (client-side)
  const { products } = useProducts(allProducts);

  // 3) Render:
  return (
    <div role="main">
      {/* TOP: keep your existing search input (it writes ?q=...) */}

      <div>
        {/* LEFT: Category Tabs */}
        <aside>
          <CategoryTabs />
        </aside>

        {/* RIGHT: Products grid */}
        <section aria-live="polite">
          {/* Replit: render product cards using your existing component */}
          {/* Example:
              {products.map((p) => <ProductCard key={p.id} product={p} />)}
          */}
        </section>
      </div>
    </div>
  );
}
Key behaviors

Page reads ?category + ?q on mount and shows correct results.

Changing tabs updates the URL and the list.

Search continues to work within the selected category.

5) Remove Legacy Filters
Delete or disable the old Filter panel (Sort, Category tree, Price range, Condition, Brand).

Remove any dead state/context/hooks used by the old filters.

Keep your existing sort options only if you want them; otherwise remove for simplicity.

If you keep “Sort”, ensure it uses the same querystring convention (?sort=) and that CategoryTabs preserves it.

6) Edge Cases & Behavior Rules
Unknown category slug in URL: treat as “All Categories”.

Zero results: show your standard “No products found” state; do not show (0) in the nav.

Kettlebells = 0 items: still display the “Kettlebells” tab as clickable; it should just show “No products found” in the grid.

Deep link: /products?category=barbells&q=rogue should load filtered to Barbells + search “rogue”.

Back/Forward navigation: relies on query params, so browser history works.

7) Accessibility Requirements
Use a semantic <nav aria-label="Product Categories"> with a <ul> and focusable <button> or <a>.

Apply aria-current="page" on the active category item.

Ensure keyboard navigation (Tab/Shift+Tab) reaches each tab and they are clickable via Enter/Space.

Announce updates: products region should include aria-live="polite" (already shown above) so screen readers are informed when the list changes.

8) SEO / Analytics (optional but recommended)
Update document title when category changes (e.g., “Shop — Dumbbells | Clean & Flip”).

Fire an analytics event on tab change:

event: category_selected

properties: { category: <slug>, query: <q> }

9) QA / Acceptance Checklist
Sidebar shows only the category names listed in CATEGORY_LABELS.

Clicking a category updates the URL query category=<slug> (absent for “All”).

Reloading the page with a category slug shows the correct products.

Search input writes ?q= and filters within the chosen category.

Changing category preserves q and any other query params.

No item counts appear anywhere in the sidebar.

Unknown category in the URL gracefully falls back to “All Categories”.

Empty results show your “no results” UI, not counts.

Keyboard-only navigation works; active item has aria-current="page".

Performance: switching tabs is instant (client) or reasonably fast (API).

10) Minimal Unit Tests (suggested)
categories.ts

toSlug() and fromSlug() round-trip for each label.

Unknown slug → “All Categories”.

CategoryTabs

When clicking an item, navigate is called with expected querystring (preserving q).

useProducts

Given params category=barbells&q=rogue, returns only rogue barbells.

