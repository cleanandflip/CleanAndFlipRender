“Universal Environment System + Checker” you can paste into your repo.
It guarantees dev and prod behave identically (same code path, same routes, same cookies), while keeping data and webhooks cleanly separated.

It includes:

A single typed config loader used everywhere.

Boot guards that refuse to start on cross-env mixups.

Webhook isolation (different prefixes + secrets per env).

DB, CORS, session middlewares that adapt to the env.

A full repo checker that scans code for dangerous patterns (hardcoded URLs, raw process.env, missing credentials, wrong cookie flags, etc.) and fails the deployment if anything is off.

A health endpoint and headers to make the active environment visible.

NPM scripts for dev/prod start, doctor, and CI checks.

You can copy these files as-is. Tailor the few TODOs for your domain/providers.

0) File map
/src/config/env.ts                  # typed config (one place to read env)
/src/config/guards.ts               # boot-time hard checks
/src/db/pool.ts                     # pooled pg client (singleton)
/src/middleware/cors.ts             # env-scoped CORS
/src/middleware/session.ts          # env-scoped express-session
/src/middleware/envHeaders.ts       # exposes X-App-Env/X-Db-Host
/src/webhooks/router.ts             # env-prefixed webhooks + signature checks
/src/routes/health.ts               # /api/healthz for visibility
/scripts/env-checker.ts             # repo-wide static checker (fails on issues)
/scripts/env-doctor.ts              # prints live resolved config


Add the imports to your server entry (shown in §6), and run the checker before starting the app.

1) .env.example (copy to .env and fill)
# ---- Environment selection ----
APP_ENV=development                 # or production
NODE_ENV=development                # production in deploy

# ---- Databases (use pooled DSNs) ----
DEV_DATABASE_URL=postgresql://user:pass@ep-DEV-host-pooler.../neondb?sslmode=require
PROD_DATABASE_URL=postgresql://user:pass@ep-PROD-host-pooler.../neondb?sslmode=require

# Optional: extra guard (comma-separated prod hosts)
KNOWN_PROD_HOSTS=ep-PROD-host-pooler.c-2.us-east-2.aws.neon.tech

# ---- Cookie / CORS ----
SESSION_SECRET=change-me
SESSION_COOKIE_DOMAIN=.your-prod-domain.com        # ONLY in production
CORS_ORIGINS_DEV=http://localhost:3000,https://*.repl.co
CORS_ORIGINS_PROD=https://your-prod-domain.com

# ---- Webhooks (separate by env; add more providers if needed) ----
# Stripe (example)
STRIPE_WEBHOOK_SECRET_DEV=whsec_xxx
STRIPE_WEBHOOK_SECRET_PROD=whsec_yyy
# Generic HMAC provider example
GENERIC_WEBHOOK_SECRET_DEV=devsecret
GENERIC_WEBHOOK_SECRET_PROD=prodsecret

# ---- Frontend (optional absolute API base; relative is recommended) ----
VITE_API_BASE_URL=


If any DSN/password was pasted publicly, rotate it in Neon.

2) Typed config (one source of truth) — src/config/env.ts
import * as process from "node:process";

export type AppEnv = "development" | "production" | "preview" | "staging";

export const APP_ENV: AppEnv =
  (process.env.APP_ENV as AppEnv) ||
  (process.env.NODE_ENV === "production" ? "production" : "development");

function must(name: string): string {
  const v = process.env[name];
  if (!v || !v.trim()) throw new Error(`Missing env: ${name}`);
  return v.trim();
}
function opt(name: string, def = ""): string {
  const v = process.env[name]; return (v ?? def).trim();
}
export function hostOf(u: string): string {
  try { return new URL(u).host; } catch {
    const s = u.replace(/^postgres(ql)?:\/\//, "");
    const afterAt = s.split("@").pop() || s;
    return afterAt.split("/")[0].split("?")[0];
  }
}

export const DEV_DATABASE_URL = must("DEV_DATABASE_URL");
export const PROD_DATABASE_URL = must("PROD_DATABASE_URL");
export const DATABASE_URL = APP_ENV === "production" ? PROD_DATABASE_URL : DEV_DATABASE_URL;

export const DB_HOST = hostOf(DATABASE_URL);
export const DEV_DB_HOST = hostOf(DEV_DATABASE_URL);
export const PROD_DB_HOST = hostOf(PROD_DATABASE_URL);

export const KNOWN_PROD_HOSTS = opt("KNOWN_PROD_HOSTS")
  .split(",").map(s => s.trim()).filter(Boolean);

export const SESSION_SECRET = must("SESSION_SECRET");
export const SESSION_COOKIE_DOMAIN = APP_ENV === "production" ? opt("SESSION_COOKIE_DOMAIN") : undefined;

export const CORS_ORIGINS =
  APP_ENV === "production"
    ? opt("CORS_ORIGINS_PROD").split(",").map(s=>s.trim()).filter(Boolean)
    : opt("CORS_ORIGINS_DEV").split(",").map(s=>s.trim()).filter(Boolean);

// Webhook prefix is visible and different per env
export const WEBHOOK_PREFIX = APP_ENV === "production" ? "/wh/prod" : "/wh/dev";

// Provider secrets (extend as you add providers)
export const WEBHOOKS = {
  stripe: {
    secret: APP_ENV === "production" ? must("STRIPE_WEBHOOK_SECRET_PROD") : must("STRIPE_WEBHOOK_SECRET_DEV"),
  },
  generic: {
    secret: APP_ENV === "production" ? must("GENERIC_WEBHOOK_SECRET_PROD") : must("GENERIC_WEBHOOK_SECRET_DEV"),
    signatureHeader: "x-signature", // HMAC-SHA256 of raw body
  },
};

export const ENV_BANNER =
  `[ENV] app=${APP_ENV} node=${process.env.NODE_ENV} dbHost=${DB_HOST}`;

3) Boot guards (hard stops on cross-env mistakes) — src/config/guards.ts
import { APP_ENV, DB_HOST, DEV_DB_HOST, PROD_DB_HOST, KNOWN_PROD_HOSTS, ENV_BANNER } from "./env";

export function assertEnvGuards() {
  console.log(ENV_BANNER);

  // 1) The database host must match the selected APP_ENV
  const expected = APP_ENV === "production" ? PROD_DB_HOST : DEV_DB_HOST;
  if (expected && DB_HOST !== expected) {
    throw new Error(`ENV_GUARD: APP_ENV=${APP_ENV} but DATABASE_URL host=${DB_HOST} != expected=${expected}`);
  }

  // 2) Belt-and-suspenders: prevent dev from writing to known prod hosts even if misconfigured
  if (APP_ENV !== "production" && KNOWN_PROD_HOSTS.includes(DB_HOST)) {
    throw new Error(`ENV_GUARD: ${APP_ENV} cannot run against known PROD host ${DB_HOST}`);
  }

  console.log("✅ ENV_GUARD: ok");
}

4) DB pool — src/db/pool.ts
import { Pool } from "pg";
import { DATABASE_URL } from "../config/env";

declare global { var __pgPool: Pool | undefined; }

export const pool = global.__pgPool ?? new Pool({
  connectionString: DATABASE_URL,
  ssl: { rejectUnauthorized: false },
  max: 10,
  idleTimeoutMillis: 30_000,
  keepAlive: true,
});

if (process.env.NODE_ENV !== "production") global.__pgPool = pool;

5) CORS / Session / Env headers

src/middleware/cors.ts

import cors from "cors";
import { CORS_ORIGINS } from "../config/env";

export const corsMiddleware = cors({
  origin: CORS_ORIGINS.length ? CORS_ORIGINS : true,
  credentials: true,
});


src/middleware/session.ts

import session from "express-session";
import PgSimple from "connect-pg-simple";
import { pool } from "../db/pool";
import { APP_ENV, SESSION_SECRET, SESSION_COOKIE_DOMAIN } from "../config/env";

const PgSession = PgSimple(session);
const isProd = APP_ENV === "production";

export const sessionMiddleware = session({
  store: new PgSession({
    pool,
    tableName: "sessions",
    createTableIfMissing: true,
    ttl: 7*24*60*60,
    pruneSessionInterval: 60*60,
  }),
  secret: SESSION_SECRET,
  name: "cf.sid",
  resave: false,
  saveUninitialized: false,
  cookie: {
    path: "/",
    httpOnly: true,
    secure: isProd,
    sameSite: isProd ? "none" : "lax",
    domain: SESSION_COOKIE_DOMAIN,      // undefined in dev → hostOnly
    maxAge: 7*24*60*60*1000,
  },
});


src/middleware/envHeaders.ts

import { RequestHandler } from "express";
import { APP_ENV, DB_HOST } from "../config/env";

export const envHeaders: RequestHandler = (_req, res, next) => {
  res.setHeader("X-App-Env", APP_ENV);
  res.setHeader("X-Db-Host", DB_HOST);
  next();
};

6) Webhooks (env-prefixed, signed) — src/webhooks/router.ts
import { Router } from "express";
import crypto from "node:crypto";
import { json, raw } from "express";
import { WEBHOOK_PREFIX, WEBHOOKS } from "../config/env";

/**
 * Mounts webhooks at:
 *   /wh/dev/stripe
 *   /wh/prod/stripe
 *   /wh/dev/generic
 *   /wh/prod/generic
 *
 * Each provider verifies the signature using its env-specific secret.
 * Add your providers below (or adapt Stripe to use official SDK if preferred).
 */
export function mountWebhooks(app: import("express").Express) {
  const r = Router();

  // Stripe (uses their "t=...,v1=..." header; lightweight verifier)
  r.post("/stripe", raw({ type: "*/*" }), (req, res) => {
    const secret = WEBHOOKS.stripe.secret;
    const sig = String(req.headers["stripe-signature"] || "");
    const timestamp = sig.match(/t=([^,]+)/)?.[1];
    const v1 = sig.match(/v1=([^,]+)/)?.[1];
    if (!timestamp || !v1) return res.status(400).send("Bad Stripe signature");

    const payload = `${timestamp}.${req.body.toString("utf8")}`;
    const expected = crypto.createHmac("sha256", secret).update(payload).digest("hex");

    if (!timingSafeEqual(v1, expected)) return res.status(400).send("Invalid Stripe signature");
    // TODO: handle event safely
    res.json({ ok: true });
  });

  // Generic HMAC provider (x-signature: hex(hmac_sha256(body)))
  r.post("/generic", raw({ type: "*/*" }), (req, res) => {
    const secret = WEBHOOKS.generic.secret;
    const header = String(req.headers[WEBHOOKS.generic.signatureHeader] || "");
    const expected = crypto.createHmac("sha256", secret).update(req.body as Buffer).digest("hex");
    if (!timingSafeEqual(header, expected)) return res.status(400).send("Invalid signature");
    // TODO: handle event safely
    res.json({ ok: true });
  });

  app.use(WEBHOOK_PREFIX, r);           // env-scoped prefix
  app.use(json());                      // return to normal parsers
}

function timingSafeEqual(a: string, b: string) {
  const A = Buffer.from(a); const B = Buffer.from(b);
  if (A.length !== B.length) return false;
  return crypto.timingSafeEqual(A, B);
}


If you prefer Stripe’s official verification, swap the Stripe part for stripe.webhooks.constructEvent using stripe SDK. The env prefix stays as-is.

7) Health route — src/routes/health.ts
import { Router } from "express";
import { APP_ENV, DB_HOST } from "../config/env";
import { pool } from "../db/pool";

export const health = Router();

health.get("/api/healthz", async (_req, res) => {
  const r = await pool.query(`select current_database() as db, current_user as role`);
  res.json({ env: APP_ENV, dbHost: DB_HOST, database: r.rows[0]?.db, role: r.rows[0]?.role });
});

8) Server entry (wire it up)

In your main server file (e.g. src/index.ts):

import express from "express";
import cookieParser from "cookie-parser";
import { assertEnvGuards } from "./config/guards";
import { corsMiddleware } from "./middleware/cors";
import { sessionMiddleware } from "./middleware/session";
import { envHeaders } from "./middleware/envHeaders";
import { health } from "./routes/health";
import { mountWebhooks } from "./webhooks/router";

assertEnvGuards();                       // 🔒 hard stop on bad env

const app = express();
app.set("trust proxy", 1);
app.use(cookieParser());
app.use(corsMiddleware);
app.use(envHeaders);
app.use(sessionMiddleware);

// Mount env-scoped webhooks FIRST (they need raw body)
mountWebhooks(app);

// Your normal JSON & routes
app.use(express.json());

// Example user endpoint (unauth → 401)
app.get("/api/user", async (req, res) => {
  if (!req.session?.userId) return res.status(401).json({ error: "Not authenticated" });
  // ... fetch and return user by req.session.userId
  res.json({ id: req.session.userId, email: req.session.email });
});

app.use(health);

const port = Number(process.env.PORT) || 5000;
app.listen(port, () => console.log(`HTTP on :${port}`));

9) Frontend helper (keeps dev/prod identical)

Prefer relative API calls. If you really need absolute, use VITE_API_BASE_URL.

/client/src/lib/apiBase.ts

export function apiUrl(path: string) {
  const base = (import.meta as any).env?.VITE_API_BASE_URL?.trim() || "";
  const p = path.startsWith("/") ? path : `/${path}`;
  return base ? `${base.replace(/\/$/, "")}${p}` : p;
}


Usage:

const res = await fetch(apiUrl("/api/user"), { credentials: "include" });

10) Repo-wide static checker — scripts/env-checker.ts

This script fails the build if it finds risky patterns (hardcoded prod URLs, raw process.env, wrong cookie flags, missing secrets, etc.). Run it locally and in your deploy pipeline.

/* eslint-disable no-console */
import { readdirSync, readFileSync } from "node:fs";
import { join, extname } from "node:path";
import "dotenv/config";
import { APP_ENV, DB_HOST, DEV_DB_HOST, PROD_DB_HOST, WEBHOOK_PREFIX } from "../src/config/env";

type Issue = { file: string; line: number; msg: string; };

const ROOT = process.cwd();
const SRC_DIRS = ["src", "client", "server"].map(d => join(ROOT, d));
const ALLOW_ENV_DIRECT = new Set<string>([
  // allowlist any files that are permitted to read process.env directly
  "src/config/env.ts",
]);

const issues: Issue[] = [];

function scanFile(file: string) {
  const text = readFileSync(file, "utf8");
  const lines = text.split(/\r?\n/);

  lines.forEach((ln, i) => {
    const line = i + 1;

    // 1) raw process.env usage (must import from config/env.ts)
    if (/process\.env\./.test(ln) && !ALLOW_ENV_DIRECT.has(rel(file))) {
      issues.push({ file, line, msg: "Use src/config/env.ts; do not read process.env directly." });
    }

    // 2) hardcoded http(s):// URLs in client code (prefer relative)
    if (/\bhttps?:\/\/[a-z0-9\.\-]/i.test(ln) && file.includes("client")) {
      issues.push({ file, line, msg: "Hardcoded absolute URL in client; prefer apiUrl(relative) or VITE_API_BASE_URL." });
    }

    // 3) webhook routes must use WEBHOOK_PREFIX
    if (/app\.post\(\s*["'`]\/webhooks?\//.test(ln)) {
      issues.push({ file, line, msg: `Webhook route found without ${WEBHOOK_PREFIX}. Use mountWebhooks() from src/webhooks/router.ts.` });
    }

    // 4) session cookie flags must be env-aware (very rough guard)
    if (/sameSite\s*:\s*['"]none['"]/.test(ln) && !/APP_ENV/.test(text)) {
      issues.push({ file, line, msg: "Cookie sameSite='none' must be conditional on production (see src/middleware/session.ts)." });
    }

    // 5) fetch without credentials (client)
    if (file.includes("client") && /\bfetch\(/.test(ln) && !/credentials\s*:\s*['"]include['"]/.test(ln)) {
      issues.push({ file, line, msg: "fetch without credentials. Add { credentials: 'include' } for session APIs." });
    }
  });
}

function rel(p: string) { return p.replace(`${ROOT}/`, ""); }
function walk(dir: string) {
  for (const entry of readdirSync(dir, { withFileTypes: true })) {
    if (entry.name.startsWith(".")) continue;
    const p = join(dir, entry.name);
    if (entry.isDirectory()) walk(p);
    else if ([".ts", ".tsx", ".js", ".jsx"].includes(extname(p))) scanFile(p);
  }
}

console.log(`[ENV-CHECK] app=${APP_ENV} dbHost=${DB_HOST} (dev=${DEV_DB_HOST} prod=${PROD_DB_HOST})`);
SRC_DIRS.forEach(d => { try { walk(d); } catch {} });

if (issues.length) {
  console.error("\n❌ Environment checker found issues:");
  for (const it of issues) console.error(` - ${rel(it.file)}:${it.line}  ${it.msg}`);
  process.exit(1);
}
console.log("✅ Environment checker passed");

11) Doctor (quick visibility) — scripts/env-doctor.ts
import "dotenv/config";
import { APP_ENV, DB_HOST, DEV_DB_HOST, PROD_DB_HOST, WEBHOOK_PREFIX, CORS_ORIGINS } from "../src/config/env";
console.log({
  APP_ENV,
  DB_HOST,
  expected: APP_ENV === "production" ? PROD_DB_HOST : DEV_DB_HOST,
  WEBHOOK_PREFIX,
  CORS_ORIGINS,
});

12) package.json scripts
{
  "scripts": {
    "env:doctor": "tsx scripts/env-doctor.ts",
    "env:check": "tsx scripts/env-checker.ts",

    "start:dev": "APP_ENV=development node dist/index.js",
    "start:prod": "APP_ENV=production NODE_ENV=production node dist/index.js",

    "prestart": "npm run env:check && npm run env:doctor"
  },
  "devDependencies": {
    "tsx": "^4.15.5",
    "@types/node": "^22.5.4",
    "typescript": "^5.6.2"
  },
  "dependencies": {
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "connect-pg-simple": "^9.0.0",
    "express-session": "^1.17.3",
    "pg": "^8.12.0",
    "pg-cursor": "^2.10.5"
  }
}


Replit: add npm run env:check to your deploy build/run hook so broken configs never ship.

How this meets your requirements

“Both environments should function the exact same”
The code path is identical. All differences are pulled from src/config/env.ts (DB URL, CORS, cookie flags, webhook secrets, prefix).

“Webhook and data should be separated”

Data: chosen by DATABASE_URL (dev vs prod), enforced by guards.

Webhooks: mounted under env-specific prefixes (/wh/dev/*, /wh/prod/*) and validated with env-specific secrets.

“Comprehensive checker”
scripts/env-checker.ts scans your repo for unsafe patterns and fails the build. It’s opinionated but practical: forces imports from the env module, bans hardcoded URLs, ensures webhook prefixing, and nudges correct cookie & fetch usage.

Replit-friendly
Minimal dependencies, pure Node/Express. Works locally and in Replit preview/deploy with the same code.

What Replit should do now

Add all files above.

Wire server entry exactly like §8.

Set deployment secrets:

Preview/dev: APP_ENV=development, DEV_DATABASE_URL=... (and no prod DSN).

Production: APP_ENV=production, PROD_DATABASE_URL=..., SESSION_COOKIE_DOMAIN=.your-prod-domain.com.

Add the webhook secrets for both envs.

Ensure the deploy flow runs: npm run env:check before start.

Verify:

/api/healthz returns { env, dbHost } as expected.

Webhooks available at /wh/dev/... in dev, /wh/prod/... in prod.

Client uses apiUrl() (or relative URLs) and credentials: 'include'.