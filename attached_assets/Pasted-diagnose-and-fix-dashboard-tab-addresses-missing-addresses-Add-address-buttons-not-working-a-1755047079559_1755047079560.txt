diagnose and fix /dashboard?tab=addresses (missing addresses + “Add address” buttons not working), and to confirm nothing got reset.

🔎 Urgent Investigation: /dashboard?tab=addresses
Symptoms

Addresses not showing on the Dashboard (user entered one previously).

“Add address” buttons don’t do anything.

We need to confirm whether addresses were reset, or if UI/API is out of sync.

1) Verify we’re looking at the right database (no silent resets)
Why: In earlier sessions we saw addresses coming back for user 256d97cb-fcd7-4dda-ba00-9ead28f5ac15. If the app pointed to a different DB/branch or a dev reset ran, the Dashboard would look empty.

Log DB target at boot (redact secrets):

Print process.env.DATABASE_URL, DB name, schema, and migration version at startup.

psql sanity checks

sql
Copy
Edit
-- Confirm database + schema
SELECT current_database() AS db, current_schema() AS schema;
-- Addresses present at all?
SELECT COUNT(*) FROM addresses;
-- Do we still have the user?
SELECT id, email FROM users ORDER BY created_at DESC LIMIT 5;
-- Addresses for the current signed-in user (replace with the session user id from logs)
SELECT * FROM addresses WHERE user_id = '256d97cb-fcd7-4dda-ba00-9ead28f5ac15' ORDER BY updated_at DESC;
-- Is their default set?
SELECT default_address_id, is_local_customer FROM users WHERE id = '256d97cb-fcd7-4dda-ba00-9ead28f5ac15';
-- Any recent truncates/drops? (if you keep an audit table, check it; else grep code per §2)
If the above returns 0 rows for addresses but you’re sure they existed:

Check if we switched envs (e.g., a different Neon branch/local docker), or a reset/seed ran on boot.

2) Ensure no code is wiping addresses on startup
Why: Some dev scripts nuke tables in dev.

Grep the repo for destructive ops:

TRUNCATE addresses / DELETE FROM addresses / DROP TABLE addresses

ORM sync with force: sequelize.sync({ force: true }) / knex.migrate:rollback / custom “reset DB” utilities

Any seed that clears addresses

Check any boot banner/tasks (we print “CLEAN & FLIP - SERVER READY 🏋️”). Make sure it doesn’t include data cleanup outside of temp tables.

Action: Remove any destructive boot step. If you need a reset, put it behind an explicit env flag (default off) and log when it executes.

3) API contract check: is /api/addresses returning data for the Dashboard?
Why: We saw earlier server logs showing /api/addresses returning a formatted address. The Dashboard may be hitting a different shape or not calling the endpoint at all.

Reproduce in browser with a signed-in user and open DevTools → Network:

Confirm a request to GET /api/addresses fires when loading /dashboard?tab=addresses.

Capture the response payload. We expect something like:

json
Copy
Edit
[
  {
    "id":"…",
    "street":"10 Magnolia Farms Drive",
    "city":"Asheville",
    "state":"NC",
    "zipCode":"28806",        // note: camelCase here if that’s our API shape
    "latitude":35.6233424,
    "longitude":-82.6163413,
    "isLocal":true,
    "isDefault":true
  }
]
If the array isn’t empty but the list renders “not found”, the UI is likely expecting different field names (e.g., postal_code vs zipCode, is_default vs isDefault).

Fix any shape mismatch:

Pick one canonical shape for the public API (recommend camelCase for JSON: postalCode, isDefault, isLocal).

Normalize the server response in one place (DTO mapper) and update the Dashboard component to use that shape.

Add a types/shared AddressDTO so all pages compile-fail if fields drift.

Auth gotcha: If Dashboard loads before auth hydrates, GET /api/addresses may be skipped or 401’d. Wrap the tab in a ProtectedRoute/RequireAuth, and only query when session.status === 'authenticated'.

4) “Add Address” buttons don’t work (front-end)
Why: Common causes are dead onClick, a modal that never opens, or a disabled Button due to asChild misuse.

DevTools → Console: click the button — any React error?

DevTools → Network: click the button — do you see POST /api/addresses? If no request goes out, the handler isn’t firing.

Check the component:

If using shadcn Dialog/Sheet, ensure it’s controlled:

tsx
Copy
Edit
const [open, setOpen] = useState(false);
<Dialog open={open} onOpenChange={setOpen}>
  <DialogTrigger asChild>
    <Button onClick={() => setOpen(true)}>Add address</Button>
  </DialogTrigger>
  <DialogContent>…</DialogContent>
</Dialog>
Don’t stack onClick on the DialogTrigger and the Button in conflicting ways.

If Button asChild wraps a Link, your click may be navigating instead of opening the modal. Use a plain Button for modal open.

Ensure the modal’s form actually submits:

tsx
Copy
Edit
<form onSubmit={handleSubmit}>
  <Button type="submit" disabled={isSaving || !isValid}>Save</Button>
</form>
After successful create/update call:

Invalidate queries so the Dashboard refreshes:

ts
Copy
Edit
await api.post('/api/addresses', payload); // server upserts + can setDefault
queryClient.invalidateQueries({ queryKey: ['addresses'] });
queryClient.invalidateQueries({ queryKey: ['user'] });
setOpen(false);
toast.success('Address saved');
If no invalidate happens, the list may look “stuck empty” even though the server has data.

5) Server: validate the add-address flow end-to-end
Why: If the client is clicking but the server rejects silently (400), it can look like the button “does nothing.”

Tail the server logs while clicking “Add address”:

Expect POST /api/addresses with body keys matching server Zod schema.

If you see 400s, log the validation errors and surface them to the UI.

Confirm the server uses one repository function (upsert) that:

Canonicalizes + fingerprints to avoid duplicates.

Optionally sets default and updates users.default_address_id and users.is_local_customer.

Returns the created/updated row in the canonical DTO shape.

If the same address is being “re-added”, server will upsert the existing row. That’s OK — just make sure the UI still shows success and refreshes the list.

6) Cross-page sync sanity (Dashboard vs Profile vs Checkout)
Why: You might be seeing the address on one page but not on /dashboard?tab=addresses due to inconsistent query keys or multiple stores.

Ensure a single AddressStore/React Query source is used everywhere:

Query key for list: ['addresses']

Query key for user: ['user'] (includes defaultAddress and isLocal).

All pages select from those, not from their own duplicated local state.

After any create/update/default-toggle, always invalidate the two keys above.

7) If addresses truly vanished: recovery + prevention
If DB shows nothing for that user now:

Check for any startup reset per §2; remove it.

Restore from last backup if available (Neon point-in-time, etc).

Add a guard: require RESET_DB_ON_STARTUP=true to run any destructive dev scripts, log loudly when it runs, and never set it in shared environments.

8) Quick regression test plan (manual)
Sign in → Visit /dashboard?tab=addresses

Expect to see your existing address.

Click Add address → modal opens → submit a new address

Expect toast success and list refresh (no duplicates).

Set one as Default → list updates; /api/user shows defaultAddress + isLocalCustomer.

Go to Checkout → address prefilled; click Change → modal opens with the same AddressFields and saving updates Dashboard after returning.

Reload the app → data persists (no reset).

9) What to change if you find mismatches
API → UI field names: normalize to camelCase (postalCode, isDefault, isLocal) at the server boundary and update the Dashboard component typings to that DTO.

Buttons: convert to controlled dialog with a plain Button (no asChild Link), ensure onSubmit fires, and run invalidateQueries on success.

Auth timing: gate the tab behind auth; only run queries when session is ready.

Env/DB: pin to the intended database/branch; remove any destructive dev resets.

Hand-back
A screenshot of Network tab showing GET /api/addresses payload on the Dashboard.

The component fix for the “Add address” click (or a note proving it was a schema mismatch).

A one-liner confirming which DB we’re on and the SELECT COUNT(*) FROM addresses WHERE user_id = ….

A short note confirming destructive resets are removed/guarded.

Please run the steps above and wire fixes accordingly. If anything blocks you, capture the console + network traces for the click and the exact JSON payload returned by /api/addresses so we can lock the DTO shape everywhere.