You’re local and the v2 handler is being hit, but it’s crashing:

swift
Copy
Edit
[CART ENFORCE V2] Error: TypeError: storage.getProductById is not a function
… server/routes/cart.v2.ts:17:35
→ POST /api/cart/items → 500
That’s a bad import / wrong repo API. The new route is calling storage.getProductById(...), but your actual product store/repo exposes a different method (e.g., products.getById or Prisma). Fix the repo call and add null-safe handling so the route never 500s.

Replit, apply this exact patch
1) Fix the cart route to use the real product repo API
Open server/routes/cart.v2.ts and replace the product lookup + logs block.

ts
Copy
Edit
// BEFORE (wrong)
import { storage } from '../stores/storage';
// ...
const product = await storage.getProductById(productId); // ❌ undefined function

// AFTER (choose ONE of the two options below)
Option A — if you already have server/stores/products.ts

ts
Copy
Edit
import { products } from '../stores/products';
// ...
const product = await products.getById(productId); // ✅ correct call
if (!product) return res.status(404).json({ message: 'Product not found' });

// Ensure booleans exist for modeFromProduct
product.isLocalDeliveryAvailable = !!product.isLocalDeliveryAvailable;
product.isShippingAvailable = !!product.isShippingAvailable;
Option B — if you use Prisma directly

ts
Copy
Edit
import { prisma } from '../db';
// ...
const p = await prisma.product.findUnique({ where: { id: productId } });
if (!p) return res.status(404).json({ message: 'Product not found' });

const product = {
  ...p,
  isLocalDeliveryAvailable: !!p.isLocalDeliveryAvailable,
  isShippingAvailable: !!p.isShippingAvailable,
};
Then keep the enforcement logic:

ts
Copy
Edit
import { modeFromProduct } from '../../shared/fulfillment';
import { getLocalityForRequest } from '../locality/getLocalityForRequest';
import { carts } from '../stores/carts'; // or your cart repo
import { getUserIdFromReq } from '../utils/auth';

console.log('[CART ENFORCE V2]', {
  user: getUserIdFromReq(req) || 'guest',
  productId,
  mode: modeFromProduct(product),
  // you can add locality fields after fetching them
});
2) Keep the server-side enforcement, but never throw 500 on business rules
Right after you compute mode and locality:

ts
Copy
Edit
const mode = modeFromProduct(product);
const locality = await getLocalityForRequest(req);

if (mode === 'LOCAL_ONLY' && !locality.eligible) {
  return res.status(403).json({
    code: 'LOCAL_ONLY_NOT_ELIGIBLE',
    message: 'This item is local delivery only and not available in your area.',
    resolution: 'Set a default local address in Asheville ZIPs (28801, 28803, 28804, 28805, 28806, 28808) or enter a local ZIP.',
  });
}
Keep the try/catch and next(err) for unexpected errors, but business denials must return 403, not throw.

3) Make sure the cart add actually writes
Call the correct cart repo:

ts
Copy
Edit
const item = await carts.addItem({
  userId: getUserIdFromReq(req) || null,
  sessionId: req.sessionID,
  productId,
  quantity: Number(quantity) || 1,
});
return res.status(200).json(item);
4) Remove the bogus DELETE rollback on 403 (client)
In client/src/hooks/useCart.tsx (or wherever you add to cart):

ts
Copy
Edit
try {
  await apiJson('/api/cart/items', {
    method: 'POST',
    body: JSON.stringify({ productId, quantity }),
  });
} catch (e: any) {
  if (e?.status === 403 && e?.body?.code === 'LOCAL_ONLY_NOT_ELIGIBLE') {
    toast({ title: 'Not available in your area', description: 'Set a local default address to order.', variant: 'destructive' });
    return; // <- do not issue DELETE; add never happened
  }
  throw e;
}
5) Quick sanity checks (what logs should show)
On page load (logged-in, default ZIP 28806):

bash
Copy
Edit
[LOCALITY] /status { eligible: true, source: 'DEFAULT_ADDRESS', zip: '28806', user: '...' }
When adding a LOCAL_ONLY product:

csharp
Copy
Edit
[CART ENFORCE V2] { user: '...', productId: '...', mode: 'LOCAL_ONLY', eligible: true, ... }
→ 200
No TypeError: storage.getProductById and no follow-up DELETE … 404.

Optional (perf warnings in your logs)
You’re seeing 3–4s responses on /api/products/featured and /api/categories?active=true. Add DB indexes and (if available) Redis:

Indexes:

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_products_featured ON products(featured);

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_categories_active ON categories(active);

If you enable Redis later, cache featured and active=true lists for 60–120s.

Once the repo call is corrected and null-checked, local users (28806) will be able to add LOCAL DELIVERY ONLY items without hitting 500s.