super-charge the Developer Dashboard across every tab, with the data model, APIs, SQL, and UI wiring you’ll need. It keeps prod/dev isolated (uses the same env module you already have) and adds full visibility (auth method, Google vs password, IPs, sessions, orders, Stripe, etc.) with proper role-based access and masking.

0) Guardrails (important)

PII access (full IPs, user-agents, email logs) must be Developer-only behind RBAC.

Show masked IPs to non-dev roles (e.g., 203.0.113.xxx).

Add a Just-In-Time reveal (eye icon) that requires a second confirmation for full PII.

Keep raw login_events ≤ 90 days; retain hashed/truncated after.

1) Database upgrades (Postgres/Neon)

Create one SQL migration and run it in dev (lucky-poetry) and prod (muddy-moon).

-- 001_dashboard_foundation.sql

-- 1) Users enrichments
ALTER TABLE public.users
  ADD COLUMN IF NOT EXISTS auth_provider           text,            -- 'password' | 'google' | 'both'
  ADD COLUMN IF NOT EXISTS email_verified_at       timestamptz,
  ADD COLUMN IF NOT EXISTS last_login_at           timestamptz,
  ADD COLUMN IF NOT EXISTS last_ip                 inet,
  ADD COLUMN IF NOT EXISTS last_user_agent         text,
  ADD COLUMN IF NOT EXISTS mfa_enabled             boolean DEFAULT false,
  ADD COLUMN IF NOT EXISTS role                    text DEFAULT 'user',  -- 'user'|'support'|'developer'
  ADD COLUMN IF NOT EXISTS status                  text DEFAULT 'active',
  ADD COLUMN IF NOT EXISTS stripe_customer_id      text,
  ADD COLUMN IF NOT EXISTS marketing_opt_in        boolean DEFAULT false,
  ADD COLUMN IF NOT EXISTS picture_url             text;

CREATE INDEX IF NOT EXISTS idx_users_email               ON public.users (email);
CREATE INDEX IF NOT EXISTS idx_users_last_login          ON public.users (last_login_at DESC);
CREATE INDEX IF NOT EXISTS idx_users_role                ON public.users (role);

-- 2) OAuth identity linker (Google, etc.)
CREATE TABLE IF NOT EXISTS public.user_identities (
  id                 uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id            uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  provider           text NOT NULL,             -- 'google'
  provider_user_id   text NOT NULL,             -- Google sub
  email              text,
  created_at         timestamptz NOT NULL DEFAULT now(),
  UNIQUE (provider, provider_user_id)
);
CREATE INDEX IF NOT EXISTS idx_user_identities_user ON public.user_identities (user_id);

-- 3) Login events (auditable, queryable)
CREATE TABLE IF NOT EXISTS public.login_events (
  id           bigserial PRIMARY KEY,
  user_id      uuid NULL REFERENCES public.users(id) ON DELETE SET NULL,
  email        text NULL,
  provider     text NOT NULL,        -- 'password' | 'google'
  method       text NOT NULL,        -- 'signin' | 'signup' | 'refresh'
  success      boolean NOT NULL,
  error_code   text NULL,
  ip           inet NULL,
  user_agent   text NULL,
  country      text NULL,
  region       text NULL,
  city         text NULL,
  risk_score   int  NULL DEFAULT 0,
  session_id   text NULL,
  created_at   timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_login_events_user_time ON public.login_events (user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_login_events_time      ON public.login_events (created_at DESC);

-- 4) Session introspection (connect-pg-simple compatible, add columns if you own the table)
ALTER TABLE public.sessions
  ADD COLUMN IF NOT EXISTS user_id       uuid,
  ADD COLUMN IF NOT EXISTS ip            inet,
  ADD COLUMN IF NOT EXISTS user_agent    text,
  ADD COLUMN IF NOT EXISTS last_seen_at  timestamptz DEFAULT now();

CREATE INDEX IF NOT EXISTS idx_sessions_user_seen ON public.sessions (user_id, last_seen_at DESC);

-- 5) Products safety column you were missing (idempotent)
ALTER TABLE public.products
  ADD COLUMN IF NOT EXISTS continue_selling_when_out_of_stock boolean NOT NULL DEFAULT false;

-- 6) Useful aggregates (materialized view for Users tab “at a glance”)
CREATE MATERIALIZED VIEW IF NOT EXISTS public.user_aggregate AS
SELECT
  u.id,
  count(DISTINCT o.id)                       AS orders_count,
  coalesce(sum(oi.quantity * oi.unit_price), 0)::numeric(12,2) AS lifetime_value,
  max(o.created_at)                          AS last_order_at,
  max(le.created_at) FILTER (WHERE le.success) AS last_success_login_at
FROM public.users u
LEFT JOIN public.orders o           ON o.user_id = u.id
LEFT JOIN public.order_items oi     ON oi.order_id = o.id
LEFT JOIN public.login_events le    ON le.user_id = u.id
GROUP BY u.id;

CREATE UNIQUE INDEX IF NOT EXISTS idx_user_aggregate_id ON public.user_aggregate (id);

-- 7) Retention policy idea (manual cron/job): 
-- DELETE FROM public.login_events WHERE created_at < now() - interval '90 days';


Replit: run this migration in both DBs. Then refresh the materialized view after deploy:

REFRESH MATERIALIZED VIEW CONCURRENTLY public.user_aggregate;

2) Backend APIs (admin-only)

All routes below require role in ('developer','support'). Add requireDeveloper middleware that checks req.session.role.

A) Users listing (rich)

GET /api/admin/users?query=&provider=&role=&status=&page=1&pageSize=25&sort=last_login_at:desc

Returns condensed rows for the table.

// SQL (fast, uses MV + users)
SELECT u.id, u.email, u.first_name, u.last_name, u.role, u.status,
       u.auth_provider,
       (SELECT array_agg(provider) FROM user_identities ui WHERE ui.user_id=u.id) AS providers,
       u.email_verified_at,
       u.last_login_at, u.last_ip, u.mfa_enabled,
       ua.orders_count, ua.lifetime_value, ua.last_order_at
FROM users u
LEFT JOIN user_aggregate ua ON ua.id = u.id
WHERE
  ($1::text IS NULL OR u.email ILIKE '%'||$1||'%' OR u.first_name ILIKE '%'||$1||'%' OR u.last_name ILIKE '%'||$1||'%')
  AND ($2::text IS NULL OR u.auth_provider = $2)
  AND ($3::text IS NULL OR u.role = $3)
  AND ($4::text IS NULL OR u.status = $4)
ORDER BY u.last_login_at DESC
LIMIT $5 OFFSET $6;


Mask IPs here unless role==='developer'.

B) User 360° detail

GET /api/admin/users/:id

Sections: account, auth & security, activity, commerce, addresses, email logs, sessions.

// fetch user + identities + aggregate
// fetch recent login_events (limit 50)
// fetch sessions (active)
// fetch addresses
// fetch orders summary

C) Login events feed

GET /api/admin/auth/login-events?userId=&success=&provider=&since=&limit=100

D) Sessions management

GET /api/admin/users/:id/sessions

POST /api/admin/users/:id/sessions/revoke (kills all)

POST /api/admin/sessions/:sid/revoke

E) System/health enrichments

GET /api/admin/system/overview → DB host, uptime, memory, slow queries (top 5), pending migrations, search index status, websocket client count, webhook delivery last error/time.

F) Stripe

GET /api/admin/stripe/summary (mode, account id, last webhook, last error)

GET /api/admin/stripe/transactions?since=&limit=50

Note: keep /api/healthz public and mounted early (already advised).

3) Auth pipeline updates (to populate data)

On every login (password or Google):

// 1) Upsert user_identities for Google
// 2) Update users.auth_provider ('password'|'google'|'both')
// 3) Set users.last_login_at = now(), users.last_ip, users.last_user_agent
// 4) Insert login_events { user_id, email, provider, method:'signin', success:true, ip, ua, geo, session_id }
// 5) For session creation, store session.userId, session.role, plus session.ip & session.user_agent (from req)


On failed login, write login_events with success=false, error_code.

On every request from an authenticated user, occasionally bump sessions.last_seen_at (e.g., once per 5 minutes).

4) UI: what to show on each tab
Products (you already show most)

Columns: Name, SKU, Category, Price, Stock, Continue when OOS, Condition, Status, Created/Updated.

Badges: Low stock (threshold configurable), OOS, Price changed (last 7d).

Bulk actions: set status, adjust stock, export CSV, reindex search.

Metrics: views (from your pageview tracker), conversion rate (Orders / Views).

Categories

Columns: Name, Slug, Products, Order, Status.

Metrics: Avg products per category, top 5 categories by views / sales.

Action: merge categories (safe reassign).

Submissions

Timeline: status changes with who & when.

Attachments: thumbnails, file count.

Contact: submitter email, prior submissions, trust score.

Actions: approve → product scaffold, reject with reason (template).

Analytics

Time range picker (today, 7d, 30d, custom).

Tiles: Revenue, Orders, Conversion, Avg Order Value, Active Users, Total Products, Inventory Value, Product Views.

Charts: revenue trend, product performance, top referrers (if you log).

Drill-down links to Users/Orders/Products filtered by time.

Users (the “whole 9 yards”)

Columns (table view):

Avatar/Name, Email, Role, Auth Method (Password / Google / Both), Email Verified, MFA,

Last Login (relative), Last IP (masked unless developer), Sessions (active count),

Orders (count), LTV (currency), Joined, Status.

Filters:

Role, Status, Provider, MFA, Email Verified, Date joined, Last login > X.

Row actions:

View 360, Impersonate (dev only, requires re-auth), Revoke sessions, Force password reset, Toggle MFA required, Change role, Disable/Enable user, Delete (soft).

User 360 (detail drawer/page):

Account: id, email, name, picture, role, status, joined, marketing opt-in, email verified, stripe_customer_id (link).

Auth & Security: providers (Google w/ sub), MFA, last login, last IP/UA, active sessions (device, IP, last seen, revoke).

Activity: login events (success/failure, geo/IP/UA, risk), recent pages (from your /api/track-activity if stored), password resets.

Commerce: orders list, totals, last order, refunds, disputes (if any).

Addresses: shipping/billing.

Emails: transactional emails sent (subject, status, provider id).

Notes: admin notes, flags.

System

Environment: APP_ENV, Node version, DB host name (not URL), uptime, pid, timezone.

Health checks: DB latency, API p95, memory/CPU, websocket clients, queue depth.

Migrations: pending? last run? (from a migrations table or Drizzle meta).

Search: index status, count, last refresh.

Webhooks: last deliveries (status, latency, error), retry control.

Slow queries: top 5 with duration & sample text (pg_stat_statements if enabled).

Stripe

Mode (test/live), account id.

Last sync time, last webhook received, last webhook error, retry button.

Transaction table (time range): id, amount, status, customer(email), link to Stripe.

Payouts summary.

5) Frontend wiring (quick sketches)

Users table fetch

// client
const res = await fetch(apiUrl(`/api/admin/users?${new URLSearchParams(params)}`), { credentials: 'include' });
const { rows, total } = await res.json();


Masking helper

export const maskIp = (ip?: string, canViewFull?: boolean) =>
  !ip ? '-' : canViewFull ? ip : ip.replace(/\.\d+$/, '.xxx');


User 360

Tabbed drawer using your existing component system.

Live updates via WS topic: users.updated:<userId>, sessions.updated:<userId>, orders.created:<userId>.

6) Logging & metrics

On each admin page load, emit a lightweight event: { page: 'users', ttfb, renderTime, rows } (console/metrics).

For /api/admin/*, log actorUserId, role, path, status, and whether PII was revealed (eye icon click) to your audit_log (optional table).

7) Role-based access control (quick)
function requireRole(...roles: Array<'support'|'developer'>) {
  return (req, res, next) => {
    const r = req.session?.role;
    if (!r || !roles.includes(r)) return res.status(403).json({ error: 'forbidden' });
    next();
  };
}

// use on admin routes
app.use('/api/admin', requireRole('support','developer'));

8) Small but important indexes
CREATE INDEX IF NOT EXISTS idx_orders_user_time       ON public.orders (user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_order_items_order      ON public.order_items (order_id);
CREATE INDEX IF NOT EXISTS idx_addresses_user         ON public.addresses (user_id);
CREATE INDEX IF NOT EXISTS idx_email_logs_user_time   ON public.email_logs (user_id, created_at DESC);

9) Deployment checklist for Replit

Apply 001_dashboard_foundation.sql to lucky-poetry (dev) and muddy-moon (prod).

Deploy server with new admin endpoints + RBAC + masking.

REFRESH MATERIALIZED VIEW CONCURRENTLY public.user_aggregate; in both DBs after initial deploy and after bulk data changes.

Confirm /api/healthz returns env + DB host.

Validate Users tab populates auth_provider, providers[], last_login_at, sessions count, orders_count, lifetime_value.

Verify Google login stores a user_identities row and writes a login_events row on each auth attempt.

Verify masking: non-developer role sees masked IPs; developer can reveal after confirmation.