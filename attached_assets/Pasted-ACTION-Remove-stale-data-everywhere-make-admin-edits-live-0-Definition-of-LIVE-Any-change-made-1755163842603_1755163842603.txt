ACTION: Remove stale data everywhere & make admin edits live
0) Definition of “LIVE”
Any change made in Admin (product, category, featured, fulfillment, status, stock, images) must be visible:

In the admin table and modals immediately

In customer pages (cards, detail, featured) on the very next fetch or via WebSocket push

No API or client cache should outlive a page focus or WebSocket event.

1) Kill HTTP/API caching for dynamic routes
Server (Express/Fastify Koa—adjust to framework):

ts
Copy
Edit
// one-time middleware before routes
app.use((req, res, next) => {
  if (req.url.startsWith('/api/')) {
    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    res.setHeader('Surrogate-Control', 'no-store');
  }
  next();
});
Make sure CDN/edge/proxy honors these headers. If any reverse proxy exists, set a rule: /api/ → Cache-Control: no-store.

2) React Query defaults = always fresh
src/lib/queryClient.ts

ts
Copy
Edit
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 0,
      gcTime: 5 * 60 * 1000,
      refetchOnMount: 'always',
      refetchOnReconnect: true,
      refetchOnWindowFocus: true,
      retry: 1,
    },
    mutations: {
      retry: 0,
    },
  },
});
3) WebSocket → single, canonical message shape + backward compat
Server must send: { type: string, payload?: any }

Client must accept old { topic } too (for safety).

Server publish (unify):

ts
Copy
Edit
type WSOut = { type: string; payload?: any };
export function publish(ws: WebSocket, type: string, payload?: any) {
  ws.send(JSON.stringify({ type, payload } satisfies WSOut));
}
// usage
publish(ws, 'product:update', { id: productId });
publish(ws, 'category:update', { id: categoryId });
Client listener (tolerate both):

ts
Copy
Edit
// src/hooks/useWebSocketState.tsx
onmessage = (ev) => {
  let msg: any; try { msg = JSON.parse(ev.data); } catch { return; }
  const type = msg.type ?? msg.topic;
  const payload = msg.payload ?? msg.data ?? msg;
  if (!type) return;
  listeners.current.forEach(fn => fn({ type, payload }));
};
React Query live reconcilers (centralize):

ts
Copy
Edit
// src/hooks/useProductLiveSync.ts
subscribe(({ type, payload }) => {
  if (type === 'product:update' && payload?.id) {
    queryClient.invalidateQueries({ queryKey: ['adminProducts'] });
    queryClient.invalidateQueries({ queryKey: ['products'] });
    queryClient.invalidateQueries({ queryKey: ['products:featured'] });
    queryClient.invalidateQueries({ queryKey: ['product', payload.id] });
  }
});
4) Service Worker / PWA must never cache API
If Workbox/service worker exists, ensure networkOnly for /api/** and bump SW version.

service-worker.ts (or workbox config):

ts
Copy
Edit
workbox.routing.registerRoute(
  ({url}) => url.pathname.startsWith('/api/'),
  new workbox.strategies.NetworkOnly()
);
self.addEventListener('install', () => self.skipWaiting());
self.addEventListener('activate', (e) => {
  e.waitUntil((async () => {
    const keys = await caches.keys();
    await Promise.all(keys.map(k => caches.delete(k))); // nuke old caches
    await (self as any).clients.claim();
  })());
});
On app boot, add a one-time SW version bump & unregister handler if needed.

5) DB schema & API shape must match (removes “phantom” stale fields)
Add missing columns used by code (cost, is_featured, is_local_delivery_available, is_shipping_available) so updates don’t 500 and leave UI stale.

Migration:

sql
Copy
Edit
ALTER TABLE products
  ADD COLUMN IF NOT EXISTS cost NUMERIC(10,2),
  ADD COLUMN IF NOT EXISTS is_featured BOOLEAN NOT NULL DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS is_local_delivery_available BOOLEAN NOT NULL DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS is_shipping_available BOOLEAN NOT NULL DEFAULT TRUE;
Server returns camelCase only via one serializer. Stop leaking snake_case to clients.

ts
Copy
Edit
// server/storage.ts
function toProductJSON(r: any) {
  return {
    id: r.id,
    name: r.name,
    description: r.description,
    categoryId: r.category_id,
    price: Number(r.price),
    compareAtPrice: r.compare_at_price == null ? null : Number(r.compare_at_price),
    cost: r.cost == null ? null : Number(r.cost),
    stockQuantity: r.stock_quantity,
    status: r.status,
    weight: Number(r.weight ?? 0),
    sku: r.sku,
    images: r.images ?? [],
    isFeatured: !!r.is_featured,
    isLocalDeliveryAvailable: !!r.is_local_delivery_available,
    isShippingAvailable: !!r.is_shipping_available,
    updatedAt: r.updated_at,
  };
}
Server should accept camel or snake in requests, normalize, and write to DB (prevents partial updates silently failing).

6) Featured & fulfillment must reflect truth immediately
Featured endpoint MUST filter on is_featured = TRUE (and stop selecting missing cost until migration is applied).

After any product mutation, send a product:update WS event post-commit.

Client: remove legacy fallbacks in src/lib/products/fulfillment.ts; read only normalized camelCase fields.

7) Admin pages must refetch on focus/visibility changes
Global hook:

ts
Copy
Edit
// src/app.tsx
useEffect(() => {
  const onFocus = () => {
    queryClient.invalidateQueries({ predicate: () => true });
  };
  window.addEventListener('focus', onFocus);
  return () => window.removeEventListener('focus', onFocus);
}, []);
8) Delete ad-hoc in-memory caches or set tight TTL + invalidation
Search for any “memory cache”, “lru”, “memoize”, or “Map” storing API responses server-side. Either remove them for /api/** or:

Set TTL ≤ 5s

Invalidate explicitly on updateProduct, createProduct, deleteProduct, updateCategory, etc.

9) Fix code that creates stale illusions
CategoriesTab: import subscribe from the WS hook (it was used without definition).

useScrollLock: export matches imports (named vs default).

React Query: after a successful mutation, also setQueryData if the server returns the updated entity:

ts
Copy
Edit
const updated = await res.json();
qc.setQueryData(['product', updated.id], updated);
qc.setQueryData(['adminProducts'], (old: any) =>
  old ? { ...old, data: old.data.map(p => p.id === updated.id ? updated : p) } : old
);
10) Grep plan to find stale culprits (please run all)
API caches:
grep -R "Cache-Control" server/
grep -R "lru\\|cache\\|memo" server/

Client caches & fallbacks:
grep -R "localStorage\\|sessionStorage" src/
grep -R "staleTime\\|refetchOn" src/
grep -R "is_local_delivery_available\\|isLocalDeliveryAvailable" src/
grep -R "topic:" src/ server/
grep -R "workbox\\|service-worker" src/ public/

Any place we construct featured lists:
grep -R "featured" server/ src/

Remove fallback reads once API is normalized (camelCase only).

11) Acceptance tests (done when ✅)
Toggle Featured in admin →
a) PUT /api/admin/products/:id 200,
b) WS product:update arrives,
c) Admin table badge flips within 1s,
d) GET /api/products/featured shows the product on the next call.

Change Fulfillment mode → card chips and PDP reflect new availability without reload (WS) and after reload (HTTP).

Update name/price/stock → immediately visible in admin table and PDP.

Categories CRUD → Categories tab never throws; product filter updates instantly.

If you apply everything above, all admin edits will be live, consistent, and cache-safe across the whole app.








Ask ChatGPT
