crash is from calling .trim() on an undefined value (likely params.get("q") or a value you pass into trim). Here’s a hardened patch Replit can drop in to make the search hook uncrashable and null-safe everywhere.

1) Fix useProducts.ts (root cause)
ts
Copy
Edit
// src/hooks/useProducts.ts
import { useMemo } from "react";
import { useSearchParams } from "react-router-dom";
import { fromSlug, toSlug } from "@/lib/categories";

export type Product = {
  id: string;
  name?: string;
  brand?: string;
  category?: string;   // slug (e.g., "dumbbells")
  tags?: string[];
  price?: number;
};

const norm = (v: unknown) =>
  typeof v === "string" ? v.toLowerCase() : v == null ? "" : String(v).toLowerCase();

export function useProducts(allProducts: Product[] | undefined) {
  const [params] = useSearchParams();

  // ✅ NEVER call .trim() on a possibly-null value
  const rawQ = params.get("q");
  const q = typeof rawQ === "string" ? rawQ.trim().toLowerCase() : "";

  const rawCat = params.get("category");
  const categoryLabel = fromSlug(rawCat);
  const categorySlug = toSlug(categoryLabel); // "" when All

  const products = useMemo(() => {
    const list = Array.isArray(allProducts) ? allProducts : [];

    return list.filter((p) => {
      // category filter (safe)
      if (categorySlug && norm(p.category) !== categorySlug) return false;

      // text search (safe)
      if (!q) return true;
      const haystack = [
        p.name,
        p.brand,
        p.category,
        Array.isArray(p.tags) ? p.tags.join(" ") : "",
      ]
        .map(norm)
        .join(" ");
      return haystack.includes(q);
    });
  }, [allProducts, q, categorySlug]);

  return { products, q, categoryLabel, categorySlug };
}
Why it fixes it

We normalize every possibly-null value.

q is always a string ("" when absent).

Product fields are optional and safely stringified.

2) (If you added a searchService) make it null-safe too
ts
Copy
Edit
// src/lib/searchService.ts
export function getQueryFromURL() {
  const sp = new URLSearchParams(window.location.search);
  const q = sp.get("q");
  const category = sp.get("category");
  const sort = sp.get("sort");
  const page = Number(sp.get("page") || "1");

  return {
    q: typeof q === "string" ? q : "",                 // ✅ never undefined
    category: typeof category === "string" ? category : "",
    sort: typeof sort === "string" ? sort : "",
    page: Number.isFinite(page) && page > 0 ? page : 1,
  };
}

export function setQueryInURL(patch: Partial<{ q: string; category: string; sort: string; page: number }>, opts: { replace?: boolean } = {}) {
  const sp = new URLSearchParams(window.location.search);
  for (const [k, v] of Object.entries(patch)) {
    if (v === undefined || v === "" || v === null) sp.delete(k);
    else sp.set(k, String(v));
  }
  const url = `${window.location.pathname}?${sp.toString()}`;
  (opts.replace ? history.replaceState : history.pushState).call(history, null, "", url);
  window.dispatchEvent(new PopStateEvent("popstate")); // notify subscribers
}
3) Harden the header SearchBar input (no undefined)
ts
Copy
Edit
// inside SearchBar.tsx
const value = typeof query.q === "string" ? query.q : "";
<input
  value={value}
  onChange={(e) => setQueryInURL({ q: e.currentTarget.value ?? "" })}
  onKeyDown={(e) => { if (e.key === "Escape") setQueryInURL({ q: "", page: 1 }); }}
/>
4) Quick sanity checklist for Replit
 No .trim() calls unless you’ve already confirmed the value is a string.

 All URL param reads default to safe strings/numbers.

 Product fields are optional-friendly in filters/search.

 Clearing search (X) calls setQueryInURL({ q: "", page: 1 }).