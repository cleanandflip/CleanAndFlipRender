Comprehensive Instructions for Replit: Clean & Flip Reorganization
Based on your Clean & Flip vision - a minimalist, single-seller sports gear resale platform - here are detailed instructions for Replit to analyze and reorganize your codebase:

PHASE 1: ANALYZE & AUDIT CURRENT CODEBASE
TASK: Complete codebase audit and identify redundancies

1. Scan all files and create a dependency map
2. Identify all duplicate code patterns across:
   - API endpoints with similar logic
   - React components with repeated functionality  
   - Database queries that could be consolidated
   - CSS/Tailwind classes used inconsistently

3. List all features currently implemented vs actually needed for single-seller model:
   KEEP: Products, Cart, Checkout, Orders, Simple Admin
   REMOVE: Equipment Submissions, Wishlist, Complex Analytics, Multi-vendor logic

4. Check for unused dependencies in package.json
5. Find all console.logs, commented code, and TODO comments

PHASE 2: STREAMLINE DATABASE & BACKEND
TASK: Simplify database schema and optimize queries

1. Audit current database tables - identify which are actually being used
2. Remove/consolidate redundant tables:
   - Merge 'addresses' data directly into 'orders' table
   - Remove 'equipment_submissions' entirely
   - Remove 'wishlist' if not core to single-seller model
   - Remove 'activity_logs' if not being utilized

3. Optimize database queries:
   - Add compound indexes for common JOIN operations
   - Implement query result caching for product listings
   - Use single queries instead of multiple round trips
   - Add database connection pooling if not present

4. Consolidate API routes:
   - Merge similar endpoints (e.g., /api/products/featured into /api/products?featured=true)
   - Remove duplicate authentication checks - use middleware
   - Standardize error responses across all endpoints

PHASE 3: FRONTEND REORGANIZATION
TASK: Create clean, minimalist UI structure

1. Implement single global theme configuration:
   - Create /client/src/config/theme.ts with all design tokens
   - Colors: White background, black text, ONE accent color
   - Typography: Single font family (Inter or similar)
   - Spacing: Consistent scale (4, 8, 16, 24, 32, 48px)

2. Consolidate component structure:
   - Merge similar components (ProductCard, ProductTile, etc.)
   - Create single Layout wrapper with consistent header/footer
   - Remove any component not used at least twice
   - Standardize all buttons, inputs, cards to single variants

3. Simplify page structure to essential flows:
   PUBLIC PAGES:
   - / (Homepage - featured products grid)
   - /products (All products with filters)
   - /product/:id (Single product detail)
   - /cart (Shopping cart)
   - /checkout (Stripe payment)
   
   ADMIN PAGES:
   - /admin (Dashboard with tabs)
   - /admin/products (Add/edit products)
   - /admin/orders (Manage orders)

4. Remove unnecessary features:
   - Complex animations/transitions
   - Multiple color themes
   - Unused admin tabs
   - Social features

PHASE 4: OPTIMIZE MIDDLEWARE & FLOW
TASK: Establish clean request flow and middleware chain

1. Reorganize middleware execution order in server/index.ts:
   ORDER:
   a) Rate limiting (protect against abuse)
   b) CORS configuration
   c) Security headers (helmet)
   d) Session parsing (PostgreSQL store)
   e) Body parsing
   f) Static file serving
   g) API routes
   h) Error handling

2. Implement proper authentication flow:
   - Single auth check middleware function
   - Apply consistently to protected routes
   - Remove duplicate session checks in individual routes
   - Separate guest cart from authenticated cart

3. Optimize Stripe integration:
   - Move all Stripe logic to dedicated /server/services/stripe.ts
   - Create single checkout session handler
   - Implement webhook for order confirmation
   - Remove any test/sandbox code

PHASE 5: PERFORMANCE & CACHING
TASK: Implement smart caching and performance optimizations

1. Add response caching:
   - Cache product listings for 5 minutes
   - Cache categories until admin updates
   - Use ETags for conditional requests

2. Optimize images:
   - Ensure all Cloudinary URLs use transformations
   - Implement lazy loading for product images
   - Use appropriate image sizes for thumbnails vs detail views

3. Bundle optimization:
   - Code split admin panel from public site
   - Lazy load heavy components (charts, etc.)
   - Remove unused CSS with PurgeCSS
   - Minimize bundle with tree shaking

PHASE 6: CLEAN CODE STANDARDS
TASK: Standardize and clean all code

1. Remove all:
   - Console.log statements (except errors)
   - Commented out code blocks
   - TODO comments without implementation
   - Unused imports
   - Dead code paths

2. Standardize:
   - Error handling (try/catch with consistent responses)
   - Async/await usage (no mixed promises)
   - TypeScript types (no 'any' types)
   - File naming (kebab-case for files, PascalCase for components)

3. Consolidate configuration:
   - Single .env file with all variables
   - Central config file for app settings
   - Consistent port and URL references

PHASE 7: FINAL TESTING & VALIDATION
TASK: Verify everything works correctly

1. Test critical user flows:
   - Browse products → Add to cart → Checkout → Order confirmation
   - Admin login → Add product → View orders
   - Session persistence across page refreshes
   - Cart persistence for guest users

2. Verify database integrity:
   - All foreign keys properly linked
   - No orphaned records
   - Indexes on frequently queried columns

3. Check responsive design:
   - Mobile (320px - 768px)
   - Tablet (768px - 1024px)  
   - Desktop (1024px+)

4. Validate Stripe integration:
   - Test mode payments work
   - Webhooks properly configured
   - Customer data synced

EXPECTED OUTCOME:
After completing these phases, you should have:

50% less code with same functionality
Single source of truth for styling and configuration
3-5 second faster page loads
Cleaner architecture matching single-seller model
Consistent UI with minimalist aesthetic
Optimized database with proper indexes
Secure, efficient middleware chain
Production-ready codebase

Start with Phase 1 and work through systematically. Each phase should be completed and tested before moving to the next.