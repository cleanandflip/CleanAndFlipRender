You’re hitting a duplicate identifier again — this time in UnifiedDataTable.tsx. Vite is telling us searchQuery is declared twice.

Fix it fast (pick the case that matches your file)
A) Duplicate in props destructuring (most likely)

Open client/src/components/admin/UnifiedDataTable.tsx and look near line ~47. You’ll see searchQuery listed twice in the function parameter list:

// ❌ before (broken)
export function UnifiedDataTable<T>({
  columns,
  data,
  onExport,
  onRowClick,
  searchQuery,   // <-- first
  actions,
  pagination,
  loading = false,
  searchQuery,   // <-- second (this causes the error)
}: UnifiedDataTableProps<T>) {


Fix: remove the second one:

// ✅ after (deduped)
export function UnifiedDataTable<T>({
  columns,
  data,
  onExport,
  onRowClick,
  searchQuery,
  actions,
  pagination,
  loading = false,
}: UnifiedDataTableProps<T>) {

B) You both destructure searchQuery and also create local state const [searchQuery, setSearchQuery] = useState(...)

If you also have a state variable with the same name, rename the local one to avoid shadowing:

// ❌ before
const [searchQuery, setSearchQuery] = useState('');

// ✅ after
const [localSearch, setLocalSearch] = useState('');


Then use the controlled-or-uncontrolled pattern:

// pick a single source of truth
const effectiveSearch = searchQuery ?? localSearch;
const setEffectiveSearch = searchQuery !== undefined
  ? (v: string) => onSearchChange?.(v)           // if controlled, bubble up
  : (v: string) => setLocalSearch(v);            // if not, keep internal state


and update inputs:

<input
  value={effectiveSearch}
  onChange={(e) => setEffectiveSearch(e.target.value)}
/>

C) If you want strong typing (optional, recommended)

At the top of the file:

export interface UnifiedDataTableProps<T> {
  columns: any[];             // your actual ColumnDef<T> type here
  data: T[];
  searchQuery?: string;       // controlled value (optional)
  onSearchChange?: (v: string) => void;
  actions?: React.ReactNode;
  pagination?: {
    page: number;
    pageSize: number;
    total: number;
    onPageChange: (p: number) => void;
  };
  loading?: boolean;
  onExport?: () => void;
  onRowClick?: (row: T) => void;
}


And destructure with an alias to avoid collisions:

export function UnifiedDataTable<T>({
  columns,
  data,
  onExport,
  onRowClick,
  searchQuery: controlledSearch,
  onSearchChange,
  actions,
  pagination,
  loading = false,
}: UnifiedDataTableProps<T>) {

  const [uncontrolledSearch, setUncontrolledSearch] = useState('');
  const effectiveSearch = controlledSearch ?? uncontrolledSearch;
  const setEffectiveSearch =
    controlledSearch !== undefined && onSearchChange
      ? onSearchChange
      : setUncontrolledSearch;

  // ...use effectiveSearch everywhere
}

After you change it

Save the file.

If HMR doesn’t recover, restart the dev server in Replit and hard refresh the browser (Ctrl/Cmd+Shift+R).

Bonus guardrails (to prevent this again)

Enable ESLint duplicate checks:

{
  "rules": {
    "no-redeclare": "error",
    "@typescript-eslint/no-redeclare": "error",
    "no-shadow": "warn"
  }
}


Prefer aliasing when destructuring props that might also exist as local state:

const { searchQuery: controlledSearch } = props;


If you paste me the current top ~80 lines of UnifiedDataTable.tsx, I’ll return the exact corrected block ready to drop in.