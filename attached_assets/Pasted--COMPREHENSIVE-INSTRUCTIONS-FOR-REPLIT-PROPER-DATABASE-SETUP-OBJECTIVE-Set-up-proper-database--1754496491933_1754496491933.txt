üìã COMPREHENSIVE INSTRUCTIONS FOR REPLIT: PROPER DATABASE SETUP
üéØ OBJECTIVE
Set up proper database separation where:

Replit preview/testing ‚Üí Uses DEVELOPMENT database
cleanandflip.com (live) ‚Üí Uses PRODUCTION database
One-time data copy ‚Üí Initialize production with development data


STEP 1: UPDATE DATABASE CONNECTION FILE
Replace server/db/index.ts with:
typescriptimport { neon } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
import * as schema from './schema';

// Intelligent database selection based on environment
const getDatabaseUrl = () => {
  const baseUrl = process.env.DATABASE_URL;
  
  if (!baseUrl) {
    throw new Error('DATABASE_URL is not configured');
  }
  
  // Determine which database to use
  const isProduction = process.env.NODE_ENV === 'production';
  const isLiveDomain = process.env.APP_URL?.includes('cleanandflip.com');
  const isReplitPreview = process.env.REPL_SLUG !== undefined && !isProduction;
  
  // Parse the base URL
  const urlParts = baseUrl.match(/^(postgresql:\/\/[^/]+\/)([^?]+)(\?.+)?$/);
  if (!urlParts) {
    console.error('[DB] Invalid DATABASE_URL format');
    return baseUrl;
  }
  
  const [, connectionString, currentDb, queryParams = '?sslmode=require'] = urlParts;
  
  // Decide which database to use
  let targetDb: string;
  
  if (isProduction || isLiveDomain) {
    // PRODUCTION: Live website always uses production database
    targetDb = 'neondb';
    console.log('[DB] üöÄ Using PRODUCTION database (live site)');
  } else if (isReplitPreview) {
    // DEVELOPMENT: Replit preview uses development database
    targetDb = 'development';
    console.log('[DB] üß™ Using DEVELOPMENT database (testing)');
  } else {
    // DEFAULT: Use whatever is in DATABASE_URL
    targetDb = currentDb;
    console.log(`[DB] Using default database: ${targetDb}`);
  }
  
  const finalUrl = `${connectionString}${targetDb}${queryParams}`;
  console.log(`[DB] Database: ${targetDb} | Production: ${isProduction}`);
  
  return finalUrl;
};

// Initialize database connection
const databaseUrl = getDatabaseUrl();
const sql = neon(databaseUrl);
export const db = drizzle(sql, { schema });

// Log successful connection
db.execute(sql`SELECT 1`)
  .then(() => {
    const dbName = databaseUrl.split('/').pop()?.split('?')[0];
    console.log(`[DB] ‚úÖ Connected to ${dbName} database`);
  })
  .catch(err => {
    console.error('[DB] ‚ùå Connection failed:', err.message);
  });

STEP 2: CREATE INITIALIZATION SCRIPT
Create scripts/initialize-production-db.ts:
typescriptimport { neon } from '@neondatabase/serverless';
import { sql } from 'drizzle-orm';

async function initializeProduction() {
  console.log('=' .repeat(60));
  console.log('üöÄ PRODUCTION DATABASE INITIALIZATION');
  console.log('=' .repeat(60));
  
  const baseUrl = process.env.DATABASE_URL;
  if (!baseUrl) {
    console.error('‚ùå DATABASE_URL not found');
    return;
  }
  
  // Parse base URL
  const urlMatch = baseUrl.match(/^(postgresql:\/\/[^/]+\/)([^?]+)(\?.+)?$/);
  if (!urlMatch) {
    console.error('‚ùå Invalid DATABASE_URL format');
    return;
  }
  
  const [, connString, , queryParams = '?sslmode=require'] = urlMatch;
  
  // Build database URLs
  const devUrl = `${connString}development${queryParams}`;
  const prodUrl = `${connString}neondb${queryParams}`;
  
  console.log('\nüìä Database Configuration:');
  console.log('  Development: development');
  console.log('  Production:  neondb');
  
  const devSql = neon(devUrl);
  const prodSql = neon(prodUrl);
  
  try {
    // Check production database status
    console.log('\nüîç Checking production database...');
    const prodCheck = await prodSql`
      SELECT 
        (SELECT COUNT(*) FROM users) as users,
        (SELECT COUNT(*) FROM products) as products,
        (SELECT COUNT(*) FROM categories) as categories
    `;
    
    const counts = prodCheck[0];
    console.log(`\nüìà Current production data:`);
    console.log(`  - Users: ${counts.users}`);
    console.log(`  - Products: ${counts.products}`);
    console.log(`  - Categories: ${counts.categories}`);
    
    if (counts.users > 0) {
      console.log('\n‚ö†Ô∏è  Production database already has data!');
      console.log('    Skipping initialization to prevent data loss.');
      
      // Show existing users
      const existingUsers = await prodSql`
        SELECT email, role, created_at 
        FROM users 
        ORDER BY created_at DESC 
        LIMIT 5
      `;
      
      console.log('\nüë• Existing users:');
      existingUsers.forEach(u => {
        console.log(`  - ${u.email} (${u.role})`);
      });
      
      return;
    }
    
    // Copy from development
    console.log('\nüìã Production is empty. Copying from development...\n');
    
    // Get development data
    const devCheck = await devSql`
      SELECT 
        (SELECT COUNT(*) FROM users) as users,
        (SELECT COUNT(*) FROM products) as products,
        (SELECT COUNT(*) FROM categories) as categories
    `;
    
    if (devCheck[0].users === 0) {
      console.error('‚ùå Development database is also empty!');
      return;
    }
    
    // Copy users
    console.log('üë• Copying users...');
    await prodSql`
      INSERT INTO users 
      SELECT * FROM dblink(
        ${devUrl},
        'SELECT * FROM users'
      ) AS t(LIKE users)
      ON CONFLICT (id) DO NOTHING
    `.catch(async () => {
      // Fallback method if dblink not available
      const users = await devSql`SELECT * FROM users`;
      for (const user of users) {
        await prodSql`
          INSERT INTO users VALUES (${user})
          ON CONFLICT (id) DO NOTHING
        `.catch(() => {});
      }
    });
    
    const usersCopied = await prodSql`SELECT COUNT(*) as count FROM users`;
    console.log(`  ‚úÖ Copied ${usersCopied[0].count} users`);
    
    // Copy categories
    console.log('\nüìÅ Copying categories...');
    const categories = await devSql`SELECT * FROM categories`;
    for (const cat of categories) {
      await prodSql`
        INSERT INTO categories VALUES (${cat})
        ON CONFLICT (id) DO NOTHING
      `.catch(() => {});
    }
    
    const catsCopied = await prodSql`SELECT COUNT(*) as count FROM categories`;
    console.log(`  ‚úÖ Copied ${catsCopied[0].count} categories`);
    
    // Copy products
    console.log('\nüì¶ Copying products...');
    const products = await devSql`SELECT * FROM products`;
    for (const prod of products) {
      await prodSql`
        INSERT INTO products VALUES (${prod})
        ON CONFLICT (id) DO NOTHING
      `.catch(() => {});
    }
    
    const prodsCopied = await prodSql`SELECT COUNT(*) as count FROM products`;
    console.log(`  ‚úÖ Copied ${prodsCopied[0].count} products`);
    
    // Verify specific user
    console.log('\nüß™ Verifying password reset user...');
    const testUser = await prodSql`
      SELECT email, id 
      FROM users 
      WHERE LOWER(email) = 'cleanandflipyt@gmail.com'
    `;
    
    if (testUser.length > 0) {
      console.log(`  ‚úÖ Found: ${testUser[0].email}`);
      console.log(`  Password reset will work!`);
    } else {
      console.log(`  ‚ö†Ô∏è cleanandflipyt@gmail.com not found`);
    }
    
    console.log('\n' + '='.repeat(60));
    console.log('‚úÖ PRODUCTION DATABASE INITIALIZED SUCCESSFULLY!');
    console.log('='.repeat(60));
    
  } catch (error) {
    console.error('\n‚ùå Error:', error.message);
  }
  
  process.exit(0);
}

initializeProduction();

STEP 3: CREATE VERIFICATION SCRIPT
Create scripts/verify-database-setup.ts:
typescriptimport { db } from '../server/db';
import { sql } from 'drizzle-orm';

async function verifySetup() {
  console.log('üîç VERIFYING DATABASE SETUP\n');
  console.log('=' .repeat(60));
  
  // Check current configuration
  console.log('üìä Current Configuration:');
  console.log(`  NODE_ENV: ${process.env.NODE_ENV}`);
  console.log(`  APP_URL: ${process.env.APP_URL || 'not set'}`);
  console.log(`  REPL_SLUG: ${process.env.REPL_SLUG || 'not in Replit'}`);
  
  // Check which database we're connected to
  const dbInfo = await db.execute(sql`
    SELECT current_database() as db_name,
           current_user as db_user
  `);
  
  console.log(`\nüóÑÔ∏è  Connected Database:`);
  console.log(`  Name: ${dbInfo.rows[0].db_name}`);
  console.log(`  User: ${dbInfo.rows[0].db_user}`);
  
  // Check data
  const counts = await db.execute(sql`
    SELECT 
      (SELECT COUNT(*) FROM users) as users,
      (SELECT COUNT(*) FROM products) as products,
      (SELECT COUNT(*) FROM categories) as categories
  `);
  
  console.log(`\nüìà Database Contents:`);
  console.log(`  Users: ${counts.rows[0].users}`);
  console.log(`  Products: ${counts.rows[0].products}`);
  console.log(`  Categories: ${counts.rows[0].categories}`);
  
  // Test user lookup
  console.log('\nüß™ Testing User Lookup:');
  const testEmails = ['cleanandflipyt@gmail.com', 'test3@gmail.com'];
  
  for (const email of testEmails) {
    const user = await db.execute(sql`
      SELECT id, email 
      FROM users 
      WHERE LOWER(email) = ${email.toLowerCase()}
      LIMIT 1
    `);
    
    if (user.rows.length > 0) {
      console.log(`  ‚úÖ ${email} - FOUND`);
    } else {
      console.log(`  ‚ùå ${email} - NOT FOUND`);
    }
  }
  
  // Determine which DB should be used
  const isProduction = process.env.NODE_ENV === 'production';
  const expectedDb = isProduction ? 'neondb' : 'development';
  const actualDb = dbInfo.rows[0].db_name;
  
  console.log('\n‚úÖ Verification Results:');
  if (actualDb === expectedDb) {
    console.log(`  ‚úÖ Correct database in use (${actualDb})`);
  } else {
    console.log(`  ‚ö†Ô∏è Wrong database! Expected ${expectedDb}, got ${actualDb}`);
  }
  
  console.log('\n' + '='.repeat(60));
  process.exit(0);
}

verifySetup();

STEP 4: UPDATE ENVIRONMENT VARIABLES
In Replit Secrets, set:
env# Primary database URL (points to production)
DATABASE_URL=postgresql://neondb_owner:xxx@ep-xxx.aws.neon.tech/neondb?sslmode=require

# Environment setting (this determines which DB to use)
NODE_ENV=production

# Your live domain
APP_URL=https://cleanandflip.com

# Keep other secrets as-is
RESEND_API_KEY=xxx
STRIPE_SECRET_KEY=xxx
CLOUDINARY_URL=xxx

STEP 5: EXECUTION SEQUENCE
Run these commands in order:
bash# 1. First, initialize production database (ONE TIME ONLY)
npx tsx scripts/initialize-production-db.ts

# 2. Verify the setup is correct
npx tsx scripts/verify-database-setup.ts

# 3. Restart your server
# The server will now automatically use the correct database

# 4. Test password reset locally (should use development DB)
curl -X POST http://localhost:5000/api/auth/forgot-password \
  -H "Content-Type: application/json" \
  -d '{"email":"cleanandflipyt@gmail.com"}'

# 5. Test on live domain (should use production DB)
curl -X POST https://cleanandflip.com/api/auth/forgot-password \
  -H "Content-Type: application/json" \
  -d '{"email":"cleanandflipyt@gmail.com"}'

STEP 6: CREATE DATABASE SWITCH HELPER (OPTIONAL)
Create scripts/switch-database.ts for easy switching:
typescriptimport fs from 'fs';

const mode = process.argv[2];

if (!mode || !['development', 'production'].includes(mode)) {
  console.log('Usage: npm run db:switch [development|production]');
  process.exit(1);
}

console.log(`Switching to ${mode} mode...`);

// Update NODE_ENV
process.env.NODE_ENV = mode;

console.log(`‚úÖ Switched to ${mode} mode`);
console.log('Restart your server for changes to take effect');
Add to package.json:
json"scripts": {
  "db:switch": "tsx scripts/switch-database.ts",
  "db:verify": "tsx scripts/verify-database-setup.ts",
  "db:init-prod": "tsx scripts/initialize-production-db.ts"
}

‚úÖ FINAL VERIFICATION
After implementation:

Replit preview should show "Using DEVELOPMENT database" in logs
cleanandflip.com should show "Using PRODUCTION database" in logs
Password reset works on both environments
New users on cleanandflip.com save to production DB only

This setup ensures proper database separation and prevents accidental data mixing!