You’re seeing ERROR 42703: column "profile_address_id" does not exist during login (getUserByEmail) on your second prod. That means the app code was deployed that EXPECTS the column, but that prod DB doesn’t have the migration. Fix it like this:

Replit: fix the prod-2 DB/schema mismatch (do these in order)
1) Make sure prod-2 is pointing to the DB you think it is

In Replit → Secrets for prod-2, print the DB host to confirm which Neon branch you’re on:

node -e "console.log(new URL(process.env.DATABASE_URL).host)"


If this host/branch is not the one you migrated earlier, that explains the error. Keep this window open—you’ll run the next steps against this DB.

2) Check migrations status on prod-2
npm run drizzle:status


If there are pending migrations, apply them:

npm run drizzle:migrate


Recheck status. It must say up to date.

3) If the migration that adds users.profile_address_id is missing, hot-patch now

Create (or run) a SQL migration against prod-2’s DB right now (safe, nullable):

-- Add the column (nullable)
ALTER TABLE "users" ADD COLUMN IF NOT EXISTS "profile_address_id" uuid;

-- Add FK to addresses table (adjust table name if yours differs)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.table_constraints
    WHERE constraint_name = 'users_profile_address_id_fkey'
  ) THEN
    ALTER TABLE "users"
      ADD CONSTRAINT "users_profile_address_id_fkey"
      FOREIGN KEY ("profile_address_id") REFERENCES "addresses"("id")
      ON DELETE SET NULL;
  END IF;
END $$;

-- Helpful index
CREATE INDEX IF NOT EXISTS "idx_users_profile_address_id"
  ON "users" ("profile_address_id");


(If your addresses table/PK is named differently, adjust the FK reference.)

Verify:

SELECT column_name FROM information_schema.columns
WHERE table_name='users' AND column_name='profile_address_id';

4) Align the ORM schema (Drizzle) and rebuild

Open shared/schema.ts (or wherever users is defined) and make sure you have:

export const users = pgTable('users', {
  // ...existing fields...
  profileAddressId: uuid('profile_address_id')
    .references(() => addresses.id, { onDelete: 'set null' })
    .default(null),
});


Then rebuild and restart:

npm run build
npm start


Your logs reference dist/index.js lines inside DatabaseStorage.getUser and getUserByEmail; compiling with the fixed schema ensures Drizzle types match the DB.

5) Make auth safe so it never 500s even if DB lags

In your Passport setup (server/auth.ts or similar), wrap deserialization in a try/catch:

passport.deserializeUser(async (id: string, done) => {
  try {
    const user = await dbGetUserById(id); // uses users.profileAddressId as nullable
    return done(null, user ?? false);
  } catch (err) {
    console.error('[PASSPORT] Deserialization suppressed:', err);
    return done(null, false); // never 500 the request (e.g., /sw.js)
  }
});


Also change any code that selects profile_address_id to not crash if null (LEFT JOIN, optional chaining). Do not reference a column name that might not exist.

6) Gate static assets from auth/session overhead (prevents noisy failures)

Before passport.session():

app.use((req, _res, next) => {
  const p = req.path;
  if (p === '/sw.js' || p === '/favicon.ico' || p.startsWith('/assets/') || p.startsWith('/static/')) {
    return next();
  }
  return next();
});


With the try/catch above, this is extra safety so /sw.js can’t 500.

7) Add a boot-time schema guard so this never happens again

On server startup, assert the required columns exist; log a red, unmistakable message if not:

async function assertSchemaReady(db) {
  const rows = await db.execute(`
    SELECT 1
    FROM information_schema.columns
    WHERE table_name='users' AND column_name='profile_address_id'
  `);
  if (!rows.rowCount) {
    console.error(
      '[SCHEMA] Missing users.profile_address_id in current DATABASE_URL. Migrations have NOT been applied to this database.'
    );
  }
}


Call assertSchemaReady(db) once during boot. (Do not crash; just make it obvious.)

8) Ensure both prods run migrations on deploy

Update your start/deploy command so migrations run before the app starts:

// package.json
{
  "scripts": {
    "prestart": "npm run drizzle:migrate",
    "start": "node dist/server.js"
  }
}


Do the same for your second deployment environment.

9) Smoke test login on prod-2

Hit /status (200 expected).

POST /api/login with a known user.

If it still 500s: tail logs; it should not be “column does not exist” anymore.

Hit any page that triggers deserialization and /sw.js—no 500s.

Why this keeps happening & how this fixes it

You deployed code compiled with profile_address_id but the prod-2 DB never ran the migration that adds it. That yields Postgres 42703 during login/deserialization/queries.

The fix is to add the column on that DB, align the Drizzle schema, and ensure migrations run on every deploy.

The auth try/catch prevents future schema drifts from crashing the whole site while you apply migrations.

Optional: quick backfill (if you want a default profile address)

Run these after adding the column:

UPDATE "users" u
SET "profile_address_id" = a.id
FROM "addresses" a
WHERE a.user_id = u.id
  AND a.is_default = TRUE
  AND u.profile_address_id IS NULL;

UPDATE "users" u
SET "profile_address_id" = sub.id
FROM (
  SELECT a1.id, a1.user_id
  FROM "addresses" a1
  JOIN (
    SELECT user_id, MAX(created_at) AS latest
    FROM "addresses"
    GROUP BY user_id
  ) last ON last.user_id = a1.user_id AND last.latest = a1.created_at
) sub
WHERE sub.user_id = u.id
  AND u.profile_address_id IS NULL;


If you paste your current getUserByEmail and getUser queries (or the Drizzle builders), I’ll give the exact updated selection/join that tolerates NULL and matches your table names.