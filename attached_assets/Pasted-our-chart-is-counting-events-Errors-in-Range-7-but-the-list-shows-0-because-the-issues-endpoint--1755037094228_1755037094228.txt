our chart is counting events (Errors in Range = 7) but the list shows 0 because the issues endpoint isn‚Äôt scoped to the same time window (and in some stores, ‚Äúissues‚Äù aren‚Äôt being materialized at all). Also, the 24h/7d/30d control isn‚Äôt reflected in the issues query or the chart labels.

Below are drop-in fixes that make time range affect both the chart and the list, plus a robust server fallback that derives issues directly from events if your store doesn‚Äôt build issues.

‚úÖ What to change
1) Client ‚Äì wire the time range into the Issues query, and fix labels
client/src/api/observability.ts
(Allow passing days to issues)

ts
Copy
Edit
// inside obsApi
issues: async (params: Record<string, any> = {}) => {
  const qs = new URLSearchParams(
    Object.entries(params)
      .filter(([, v]) => v !== undefined && v !== null && v !== "")
      .map(([k, v]) => [k, String(v)]) as any
  );
  return fetch(`/api/observability/issues?${qs}`, { credentials: "include" }).then(ok);
},
client/src/pages/observability.tsx
a) Send days with the issues query and include it in the key

tsx
Copy
Edit
const { data: issuesData, isLoading } = useQuery({
  queryKey: ["obs:issues", q, level, env, status, page, limit, timeRange],
  queryFn: () =>
    obsApi.issues({
      q,
      level: level || undefined,
      env: env || undefined,
      resolved: status === "all" ? undefined : status === "resolved",
      days: parseInt(timeRange, 10),          // üëà NEW
      page,
      limit,
    }),
  placeholderData: (prev) => prev,
});
b) Make the chart label adapt to 24h vs 7/30d

tsx
Copy
Edit
const days = parseInt(timeRange, 10);
const byDay = days > 1;

const chartData = (Array.isArray(seriesData) ? seriesData : [])
  .map((r: any) => {
    const t = toDateSafe(r.ts || r.hour); // support both shapes
    return {
      label: t
        ? (byDay
            ? t.toLocaleDateString(undefined, { month: "short", day: "numeric" })
            : t.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }))
        : "",
      count: Number(r.count) || 0,
    };
  })
  .filter((d: any) => d.label);
‚Ä¶and update the chart to use dataKey="label":

tsx
Copy
Edit
<XAxis dataKey="label" tick={{ fontSize: 12 }} />
c) Keep ‚ÄúErrors in Range‚Äù aligned with the selected range

tsx
Copy
Edit
const errorsInRange = chartData.reduce((s, d) => s + d.count, 0);
Use errorsInRange in the KPI card.

2) Server ‚Äì time-scoped issues + fallback aggregation
Your /series already respects days. We‚Äôll make /issues do the same and add a fallback that groups events into issues if your store doesn‚Äôt materialize issues.

server/src/routes/observability.ts
Add helpers at the top:

ts
Copy
Edit
import crypto from "crypto";

const now = () => new Date();
const sinceDays = (d: number) => new Date(Date.now() - d * 24 * 60 * 60 * 1000);

function fingerprintFromEvent(evt: any) {
  const base = [
    evt.message || "",
    (Array.isArray(evt.stack) ? evt.stack[0] : evt.stack) || "",
    evt.service || "",
    evt.type || "",
  ].join("|");
  return crypto.createHash("sha1").update(base).digest("hex");
}
Update /issues route
ts
Copy
Edit
router.get("/issues", async (req, res) => {
  try {
    const q = String(req.query.q ?? "");
    const level = String(req.query.level ?? "");
    const env = String(req.query.env ?? "");
    const resolvedRaw = req.query.resolved;
    const resolved =
      resolvedRaw === undefined ? undefined : String(resolvedRaw) === "true";
    const page = Math.max(1, parseInt(String(req.query.page ?? "1"), 10));
    const limit = Math.min(100, Math.max(1, parseInt(String(req.query.limit ?? "20"), 10)));
    const days = Math.min(30, Math.max(1, parseInt(String(req.query.days ?? "1"), 10)));
    const since = sinceDays(days);
    const until = now();

    // First try the store's native issues API (if it supports time scoping)
    let result = await SimpleErrorStore.listIssues?.({ q, level, env, resolved, page, limit, since, until });

    // Fallback: derive issues from recent events (ensures list is never empty when the chart has data)
    if (!result || !Array.isArray(result.items)) {
      const recent = await (SimpleErrorStore.findEventsSince
        ? SimpleErrorStore.findEventsSince(since)              // prefer since-based
        : SimpleErrorStore.findEvents?.({ since, until })      // or generic finder
      );

      const events: any[] = Array.isArray(recent) ? recent : [];
      const groups = new Map<string, any>();

      for (const evt of events) {
        // basic filters first
        if (level && evt.level !== level) continue;
        if (env && evt.env !== env) continue;
        // resolved filter can't be known from raw events; we keep everything for 'all' and 'unresolved' modes
        const fp = evt.fingerprint || fingerprintFromEvent(evt);
        const g = groups.get(fp) || {
          fingerprint: fp,
          title: evt.message || "(no message)",
          level: evt.level || "error",
          firstSeen: evt.createdAt || evt.timestamp || new Date().toISOString(),
          lastSeen: evt.createdAt || evt.timestamp || new Date().toISOString(),
          count: 0,
          resolved: false,
          ignored: false,
          service: evt.service,
          envs: {},
        };
        g.count += 1;
        g.lastSeen = evt.createdAt || evt.timestamp || g.lastSeen;
        g.envs[evt.env || "unknown"] = (g.envs[evt.env || "unknown"] ?? 0) + 1;
        groups.set(fp, g);
      }

      let items = [...groups.values()];

      // text search
      if (q) {
        const QQ = q.toLowerCase();
        items = items.filter((it) =>
          it.title?.toLowerCase().includes(QQ) ||
          it.fingerprint.includes(QQ)
        );
      }

      // status filter (only apply "resolved" true if explicitly requested)
      const statusParam = resolvedRaw === undefined ? "all" : resolved ? "resolved" : "unresolved";
      if (statusParam === "resolved") items = items.filter((it) => it.resolved);
      if (statusParam === "unresolved") items = items.filter((it) => !it.resolved);

      // sort by lastSeen desc
      items.sort((a, b) => (new Date(b.lastSeen).getTime() - new Date(a.lastSeen).getTime()));

      const total = items.length;
      const start = (page - 1) * limit;
      result = { items: items.slice(start, start + limit), total };
    }

    res.json(result);
  } catch (e) {
    console.error("observability.listIssues failed:", e);
    res.status(500).json({ error: "Failed to fetch issues" });
  }
});
Make /series return a stable shape for labels
ts
Copy
Edit
router.get("/series", async (req, res) => {
  try {
    const days = Math.min(30, Math.max(1, parseInt(String(req.query.days ?? "1"), 10)));
    const rows = await SimpleErrorStore.getChartData?.(days);

    // Normalize shape to { ts, count }
    // If your store already returns { ts, count }, this is a no-op.
    const normalized = Array.isArray(rows) ? rows.map((r: any) => ({
      ts: r.ts || r.hour || r.time || r.bucket,
      count: r.count ?? r.value ?? r.total ?? 0,
    })) : [];

    res.json(normalized);
  } catch (e) {
    console.error("observability.series failed:", e);
    res.status(500).json({ error: "Failed to fetch chart data" });
  }
});
If your SimpleErrorStore doesn‚Äôt have findEventsSince/findEvents, add one wrapper that returns recent raw events (the same data /series is based on). It can be as simple as filtering by createdAt >= since.

3) (Optional) Tidy the empty state
Keep this in the page so it guides you when nothing matches:

tsx
Copy
Edit
{filteredItems.length === 0 ? (
  <div className="text-center py-10 text-muted-foreground space-y-3">
    <div>No issues found for current filters.</div>
    <div className="text-xs">
      Tips: set <b>Status</b> to <b>All</b>, enable <b>Show ignored</b>, or toggle <b>Show test events</b>.
    </div>
  </div>
) : (/* ...render list... */)}
üß™ Verify
Reload the Errors tab.

Switch the time range: Last 24h / 7d / 30d ‚Äî the chart axis should flip to time-of-day vs date labels, and Errors in Range should change.

Click Seed Test Error once‚Äîan item should appear in the list immediately.

Toggle Status / Level / Env / Ignored / Test and confirm the list updates.

üì£ Replit, please do the following
Apply the client changes above (issues query includes days, chart uses label, KPI uses errorsInRange).

Apply the server changes above (time-scoped /issues, normalized /series, and the fallback aggregator).

If SimpleErrorStore lacks findEventsSince/findEvents, add one that returns recent events used by /series.

Rebuild and run:

bash
Copy
Edit
pnpm tsc --noEmit
pnpm dev
Confirm the Errors tab shows items when Errors in Range > 0, and that switching 24h/7d/30d updates both chart and list.

If after this you still see counts but no list, paste the JSON responses for:

GET /api/observability/series?days=1

GET /api/observability/issues?days=1
so I can align the shapes exactly.









Ask ChatGPT
