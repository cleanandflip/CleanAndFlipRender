REPLIT INSTRUCTIONS — MERGE & HARDEN PRODUCTS UI + LIVE SYNC
Goal:

Use one WebSocket hook (useWebSocketState — named exports only).

Remove duplicate admin/product list components (merge ProductsTab ⇢ ProductsManager; merge ProductGrid ⇢ ProductList).

Show Delivery & Fulfillment (Local / Ships) on all customer views (cards + detail).

Block non-local users from adding local-only products (UI + server enforcement).

Add live updates to customer views.

Fix prior errors (useWebSocketReady, subscribe is not defined, send is not a function).

Do not change the existing 404 page look.

Proceed step-by-step. If any command returns no matches, continue.

0) Repo-wide safety & housekeeping
bash
Copy
Edit
# use only new hooks/routes; scrub legacy imports
grep -RIl --include="*.ts*" --include="*.tsx" -E '@/hooks/useWebSocket(?!State)|useSingletonSocket|useWebSocketReady|@/components/error-boundary' client/src || true

# Replace legacy error-boundary import casing if any
find client/src -type f \( -name '*.ts' -o -name '*.tsx' \) -exec sed -i 's#@/components/error-boundary#@/components/ErrorBoundary#g' {} +

# Remove all references to non-existent/legacy socket hooks
find client/src -type f \( -name '*.ts' -o -name '*.tsx' \) -exec sed -i 's#@/hooks/useWebSocket"#@/hooks/useWebSocketState"#g; s#@/hooks/useSingletonSocket[^"]*"#@/hooks/useWebSocketState"#g; s/useWebSocketReady/useWebSocketState/g' {} +
1) Canonicalize useWebSocketState (named exports only)
Edit: client/src/hooks/useWebSocketState.tsx
Ensure it exports the following named members (no default export): ready: boolean, lastMessage: any, subscribe(fn) => unsubscribe, and at least one of publish or sendJsonMessage.

If missing, replace file with:

tsx
Copy
Edit
import { useEffect, useRef, useState, useCallback } from "react";

type Msg = any;
type Sub = (m: Msg) => void;

let socket: WebSocket | null = null;
const subs = new Set<Sub>();

function ensureSocket() {
  if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) return socket;
  socket = new WebSocket(`${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/ws`);
  socket.onmessage = (ev) => {
    let data: any = undefined;
    try { data = JSON.parse(ev.data); } catch { data = ev.data; }
    subs.forEach(fn => { try { fn(data); } catch {} });
  };
  return socket;
}

export function useWebSocketState() {
  const [ready, setReady] = useState(false);
  const [lastMessage, setLastMessage] = useState<any>(null);
  const isMounted = useRef(true);

  useEffect(() => () => { isMounted.current = false; }, []);

  useEffect(() => {
    const s = ensureSocket();
    const onOpen = () => isMounted.current && setReady(true);
    const onClose = () => isMounted.current && setReady(false);
    const onMsg = (ev: MessageEvent) => {
      try { setLastMessage(JSON.parse(ev.data)); } catch { setLastMessage(ev.data); }
    };
    s.addEventListener("open", onOpen);
    s.addEventListener("close", onClose);
    s.addEventListener("message", onMsg);
    return () => {
      s.removeEventListener("open", onOpen);
      s.removeEventListener("close", onClose);
      s.removeEventListener("message", onMsg);
    };
  }, []);

  const subscribe = useCallback((fn: Sub) => {
    subs.add(fn);
    return () => subs.delete(fn);
  }, []);

  // publish with graceful fallback
  const sendJsonMessage = useCallback((typeOrPayload: any, maybePayload?: any) => {
    const s = ensureSocket();
    const payload = typeof typeOrPayload === "string"
      ? { type: typeOrPayload, payload: maybePayload }
      : typeOrPayload;
    try { s.send(JSON.stringify(payload)); } catch {}
  }, []);

  const publish = sendJsonMessage; // alias for compatibility

  return { ready, lastMessage, subscribe, sendJsonMessage, publish };
}
This fixes:
• “does not provide an export named ‘default’”
• “useWebSocketReady not exported”
• “subscribe is not defined”

2) One truth for fulfillment flags
Create: client/src/lib/products/fulfillment.ts

ts
Copy
Edit
export type FulfillmentFlags = { localDelivery: boolean; nationwideShipping: boolean; };
export function getFulfillmentFlags(p: any): FulfillmentFlags {
  return {
    localDelivery: Boolean(p?.localDelivery ?? p?.fulfillment?.local),
    nationwideShipping: Boolean(p?.nationwideShipping ?? p?.fulfillment?.shipping),
  };
}
export function isLocalOnly(p: any) {
  const f = getFulfillmentFlags(p);
  return f.localDelivery && !f.nationwideShipping;
}
3) Chips shown everywhere
Update: client/src/components/locality/ProductAvailabilityChips.tsx

tsx
Copy
Edit
type Props = { product: any; compact?: boolean };
import { getFulfillmentFlags } from "@/lib/products/fulfillment";

export default function ProductAvailabilityChips({ product, compact }: Props) {
  const { localDelivery, nationwideShipping } = getFulfillmentFlags(product);
  if (!localDelivery && !nationwideShipping) return null;
  const base = compact ? "px-1.5 py-0.5 text-[10px]" : "px-2 py-1 text-xs";
  return (
    <div className={`flex gap-2 ${compact ? "mt-1" : "mt-2"}`}>
      {localDelivery && <span className={`${base} rounded-full bg-blue-600/10 text-blue-300`}>Local delivery</span>}
      {nationwideShipping && <span className={`${base} rounded-full bg-emerald-600/10 text-emerald-300`}>Ships nationwide</span>}
    </div>
  );
}
Update: client/src/components/products/product-card.tsx
After existing price/details block, render:

tsx
Copy
Edit
<ProductAvailabilityChips product={product} compact={compact} />
Update: client/src/pages/product-detail.tsx
Add a section:

tsx
Copy
Edit
import ProductAvailabilityChips from "@/components/locality/ProductAvailabilityChips";
...
<section className="mt-4">
  <h3 className="text-sm font-medium text-gray-300 mb-2">Delivery & Fulfillment</h3>
  <ProductAvailabilityChips product={product} />
</section>
4) Block non-local add-to-cart for local-only products (UI + API)
Edit: client/src/components/AddToCartButton.tsx

diff
Copy
Edit
 import { useLocality } from "@/hooks/useLocality";
+import { isLocalOnly } from "@/lib/products/fulfillment";

 export default function AddToCartButton({ product, ...props }) {
   const { data: locality } = useLocality();
-  const blocked = false;
+  const blocked = isLocalOnly(product) && !locality?.isLocal;

   const handleAdd = async () => { if (blocked) return; await onAdd?.(); };
   ...
-  <Button onClick={handleAdd}>Add to cart</Button>
+  <Button onClick={handleAdd} disabled={blocked} variant={blocked ? "secondary" : "default"}>
+    {blocked ? "Local only" : "Add to cart"}
+  </Button>
Server enforcement: (mirror logic)

Create helper (or inline) in server:

Create: server/utils/fulfillment.ts

ts
Copy
Edit
export function getFulfillmentFlags(p: any) {
  return {
    localDelivery: Boolean(p?.localDelivery ?? p?.fulfillment?.local),
    nationwideShipping: Boolean(p?.nationwideShipping ?? p?.fulfillment?.shipping),
  };
}
export function isLocalOnly(p: any) {
  const f = getFulfillmentFlags(p);
  return f.localDelivery && !f.nationwideShipping;
}
Edit: cart “add item” route (wherever it lives, e.g. server/routes/cart.ts)

diff
Copy
Edit
+import { isLocalOnly } from "../utils/fulfillment";
+import { localityService } from "../services/localityService"; // or equivalent

 router.post('/cart/items', async (req, res) => {
   const { productId, quantity = 1 } = req.body;
   const product = await db.product.findById(productId);
   if (!product) return res.status(404).json({ error: 'Product not found' });
+  const localOnly = isLocalOnly(product);
+  const isLocal = await localityService.isRequestLocal(req);
+  if (localOnly && !isLocal) {
+    return res.status(400).json({ error: 'LOCAL_ONLY', message: 'Local delivery only.' });
+  }
   ...
 });
5) Live updates for customer views
Create: client/src/hooks/useProductLiveSync.ts

ts
Copy
Edit
import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { useWebSocketState } from "@/hooks/useWebSocketState";

export function useProductLiveSync({ queryKey, productId }: { queryKey: any; productId?: string }) {
  const qc = useQueryClient();
  const { ready, subscribe } = useWebSocketState();
  useEffect(() => {
    if (!ready || typeof subscribe !== "function") return;
    const unsub = subscribe((msg: any) => {
      const t = msg?.type || msg?.data?.type;
      const payload = msg?.payload || msg?.data?.payload;
      if (!t) return;
      if (["products.updated", "products.created", "products.deleted"].includes(t)) {
        if (!productId || payload?.id === productId) {
          qc.invalidateQueries({ queryKey });
        }
      }
    });
    return () => { try { unsub?.(); } catch {} };
  }, [ready, subscribe, qc, JSON.stringify(queryKey), productId]);
}
Wire it up:

Home (client/src/pages/home.tsx):

tsx
Copy
Edit
import { useProductLiveSync } from "@/hooks/useProductLiveSync";
...
useProductLiveSync({ queryKey: ["featured-products"] });
Products page (client/src/pages/products.tsx):

tsx
Copy
Edit
import { useProductLiveSync } from "@/hooks/useProductLiveSync";
...
useProductLiveSync({ queryKey: ["products", filters] });
Product detail (client/src/pages/product-detail.tsx):

tsx
Copy
Edit
import { useProductLiveSync } from "@/hooks/useProductLiveSync";
...
useProductLiveSync({ queryKey: ["product", id], productId: id });
6) MERGE: Product grids/lists
Goal: Keep ProductGrid as the single renderer and delete ProductList (or make it re-export ProductGrid).

Edit/Replace: client/src/components/products/product-grid.tsx

tsx
Copy
Edit
import ProductCard from "./product-card";

type Props = {
  products: any[];
  viewMode?: "grid" | "list";
  compactCards?: boolean;
};

export default function ProductGrid({ products, viewMode = "grid", compactCards = false }: Props) {
  const grid = viewMode === "grid";
  return (
    <div className={grid ? "grid grid-cols-2 md:grid-cols-3 gap-4" : "flex flex-col gap-3"}>
      {products?.map((p) => (
        <ProductCard key={p.id} product={p} viewMode={viewMode} compact={compactCards} />
      ))}
    </div>
  );
}
Deprecate: client/src/components/products/ProductList.tsx
Replace file content with a re-export to avoid breakage, then delete imports repo-wide.

ts
Copy
Edit
export { default } from "./product-grid";
Sweep imports to the single component:

bash
Copy
Edit
find client/src -type f -name '*.ts*' -exec sed -i 's#@/components/products/ProductList#@/components/products/product-grid#g' {} +
7) MERGE: Admin Products (ProductsTab ⇢ ProductsManager)
Keep one: client/src/pages/admin/ProductsTab.tsx as the canonical page using UnifiedDataTable.

If ProductsManager.tsx exists, replace its content with a simple re-export; then update any route to point to ProductsTab and delete alternate routes.

Replace: client/src/pages/admin/ProductsTab.tsx

tsx
Copy
Edit
import { useEffect, useMemo } from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { useWebSocketState } from "@/hooks/useWebSocketState";
import UnifiedDataTable from "@/components/admin/UnifiedDataTable";
import { getAdminProducts } from "@/api/observability"; // or your admin products API

export default function ProductsTab() {
  const qc = useQueryClient();
  const { ready, subscribe } = useWebSocketState();

  const q = useQuery({
    queryKey: ["admin-products"],
    queryFn: () => fetch("/api/admin/products").then(r => r.json()),
    staleTime: 10_000,
  });

  useEffect(() => {
    if (!ready || typeof subscribe !== "function") return;
    const off = subscribe((m: any) => {
      const t = m?.type || m?.data?.type;
      if (["products.updated", "products.created", "products.deleted"].includes(t)) {
        qc.invalidateQueries({ queryKey: ["admin-products"] });
      }
    });
    return () => { try { off?.(); } catch {} };
  }, [ready, subscribe, qc]);

  const rows = useMemo(() => q.data ?? [], [q.data]);
  return <UnifiedDataTable data={rows} resource="products" />;
}
Replace (if present): client/src/pages/admin/ProductsManager.tsx

ts
Copy
Edit
export { default } from "./ProductsTab";
Remove dead imports & routes that referenced ProductsManager directly:

bash
Copy
Edit
grep -RIl --include="*.ts*" --include="*.tsx" 'ProductsManager' client/src | xargs -r sed -i 's/ProductsManager/ProductsTab/g'
8) Harden admin modals (no raw send()
Search & patch:

bash
Copy
Edit
grep -RIn --include="*.ts*" --include="*.tsx" '\bsend\(' client/src/components/admin | cut -d: -f1 | sort -u | while read f; do
  sed -i 's/send(\([^,]*\), *\([^)]*\))/((typeof publish=="function"&&ready&&publish(\1,\2))||(typeof sendJsonMessage=="function"&&ready&&sendJsonMessage(\1,\2)))/g' "$f"
done
Ensure EnhancedProductModal imports the unified hook:

bash
Copy
Edit
applypatch << 'PATCH'
*** Begin Patch
*** Update File: client/src/components/admin/modals/EnhancedProductModal.tsx
@@
-import { useWebSocketState } from "@/hooks/useWebSocketState";
+import { useWebSocketState } from "@/hooks/useWebSocketState";
+import { useQueryClient } from "@tanstack/react-query";
@@
-  const { send } = useSocket() || {};
+  const { ready, publish, sendJsonMessage } = useWebSocketState();
+  const queryClient = useQueryClient();
@@
-    send("products.updated", { id: product.id, payload });
+    try {
+      const maybeSend = (typeof publish === "function" && publish) || (typeof sendJsonMessage === "function" && sendJsonMessage);
+      if (ready && typeof maybeSend === "function") {
+        maybeSend("products.updated", { id: product.id, payload });
+      }
+    } catch {}
+    queryClient.invalidateQueries({ queryKey: ["admin-products"] });
*** End Patch
PATCH
9) Keep current 404 page styling
No changes to client/src/pages/not-found.tsx or components/ErrorBoundary.tsx other than import casing already fixed in step 0. Do not alter their JSX or CSS.

10) Sanity checks
bash
Copy
Edit
# No legacy hooks left
grep -RIn --include="*.ts*" --include="*.tsx" -E '@/hooks/useWebSocket(?!State)|useSingletonSocket|useWebSocketReady' client/src && echo "❌ Legacy hooks remain" || echo "✅ Hooks unified"

# No raw send(
grep -RIn --include="*.ts*" --include="*.tsx" '\bsend\(' client/src | grep -v 'JSON' && echo "❌ Raw send found" || echo "✅ No raw send"

# Product chips present in ProductCard
grep -RIn --include="product-card.tsx" 'ProductAvailabilityChips' client/src/components/products && echo "✅ Chips in ProductCard"

# Build/start
npm run dev >/dev/null 2>&1 & sleep 5; curl -s http://localhost:5000/status || true
Manual verification (UI):

Home featured cards show Local delivery / Ships nationwide chips.

Products grid/list show chips.

Product detail shows Delivery & Fulfillment section.

For local-only items, non-local users see “Local only” disabled button + tooltip; server returns LOCAL_ONLY if called.

Admin Products uses the unified table; creating/editing products invalidates admin and customer queries via socket.

11) Notes / Acceptance
WebSocket: all consumers use useWebSocketState (named export; no default).

404 page: unchanged.

Duplicates removed:

ProductList.tsx → re-export of product-grid.

ProductsManager.tsx → re-export of ProductsTab.

Customer views now live-sync (useProductLiveSync) and display fulfillment everywhere.

Admin save no longer throws “send is not a function”.

Commit with message:

sql
Copy
Edit
chore(products): unify socket hook, merge admin/list components, add fulfillment UI everywhere, add live sync, enforce local-only guard (UI+API), keep 404 styling
If Replit hits anything unexpected (like a different admin API path), adapt the two fetch lines in ProductsTab.tsx and the server cart route accordingly—the rest of the architecture stays the same.









Ask ChatGPT
