DO EXACTLY THIS ‚Äî REPLIT
0) Fix the two concrete build/runtime errors shown in the logs
A. Duplicate import (StripeTab)
File: client/src/pages/admin/StripeTab.tsx
Fix: remove the second import; keep only one.

ts
Copy
Edit
// keep this ONE line
import { useWebSocketState } from '@/hooks/useWebSocketState';

// delete the duplicate line that re-imports useWebSocketState
B. ‚Äúsend is not a function‚Äù + ‚Äúsubscribe is not defined‚Äù
We standardize on publish/subscribe (not send) and expose a tiny compatibility layer so legacy code won‚Äôt crash.

Replace the entire file client/src/hooks/useWebSocketState.tsx with this:

tsx
Copy
Edit
import { useEffect, useMemo, useRef, useState, useCallback } from "react";

// ---- module-singleton so multiple hooks share one socket ----
let _socket: WebSocket | null = null;
let _connected = false;
const _listeners = new Map<string, Set<(payload: any) => void>>();

function ensureSocket() {
  if (_socket) return _socket;

  const wsUrl =
    (import.meta as any).env?.VITE_WS_URL ||
    location.origin.replace(/^http/, "ws") + "/ws";

  _socket = new WebSocket(wsUrl);

  _socket.addEventListener("open", () => {
    _connected = true;
  });

  _socket.addEventListener("close", () => {
    _connected = false;
    // lightweight retry
    setTimeout(() => {
      _socket = null;
      ensureSocket();
    }, 2000);
  });

  _socket.addEventListener("message", (e) => {
    try {
      const msg = JSON.parse(e.data);
      const set = _listeners.get(msg?.type);
      if (set) for (const fn of set) fn(msg.payload);
    } catch {}
  });

  return _socket;
}

export function useWebSocketState() {
  const [, force] = useState(0);
  const socketRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    socketRef.current = ensureSocket();
    const id = setInterval(() => force((n) => n + 1), 500); // shallow reactivity for connected flag
    return () => clearInterval(id);
  }, []);

  const subscribe = useCallback((type: string, handler: (payload: any) => void) => {
    if (!_listeners.has(type)) _listeners.set(type, new Set());
    _listeners.get(type)!.add(handler);
    return () => _listeners.get(type)!.delete(handler);
  }, []);

  const publish = useCallback((type: string, payload?: any) => {
    const s = socketRef.current ?? _socket;
    if (s && s.readyState === WebSocket.OPEN) {
      s.send(JSON.stringify({ type, payload }));
    }
  }, []);

  return useMemo(
    () => ({ connected: _connected, socket: socketRef.current, subscribe, publish }),
    [_connected, socketRef.current, subscribe, publish]
  );
}

// ---- Compatibility so legacy code won't crash ----
export const useWebSocketReady = () => {
  const { connected } = useWebSocketState();
  return connected;
};
// Some legacy code destructures { send }, so provide a no-op alias.
export function useLegacySocket() {
  const { publish } = useWebSocketState();
  const send = publish; // alias
  return { send, publish };
}
After this, replace any remaining calls of send(...) with publish(...) in admin modals/pages when you touch those files. (The compatibility alias prevents crashes in the meantime.)

1) Make fulfillment (local delivery / shipping) consistent everywhere
A. Add a tiny adapter to read flags regardless of legacy field names
File: client/src/lib/products/fulfillment.ts (create/replace)

ts
Copy
Edit
export type AnyProduct = Record<string, any>;

export function getFulfillment(p: AnyProduct) {
  // normalize different shapes from server/older clients
  const local =
    p.is_local_delivery_available ??
    p.isLocalDeliveryAvailable ??
    p.localDelivery ??
    false;

  const shipping =
    p.is_shipping_available ??
    p.isShippingAvailable ??
    p.shipping ??
    false;

  return { local: !!local, shipping: !!shipping };
}
B. Make chips use the adapter (shows on every card + detail page)
File: client/src/components/locality/ProductAvailabilityChips.tsx
Replace its internal boolean extraction with:

tsx
Copy
Edit
import { getFulfillment } from "@/lib/products/fulfillment";

export default function ProductAvailabilityChips({ product }: { product: any }) {
  const { local, shipping } = getFulfillment(product);

  if (!local && !shipping) return null;

  return (
    <div className="flex flex-wrap gap-2 mt-2">
      {local && (
        <span className="inline-flex items-center rounded-full bg-emerald-600/15 text-emerald-300 text-xs px-2 py-1">
          üöö Local delivery
        </span>
      )}
      {shipping && (
        <span className="inline-flex items-center rounded-full bg-blue-600/15 text-blue-300 text-xs px-2 py-1">
          üì¶ Nationwide shipping
        </span>
      )}
      {local && !shipping && (
        <span className="inline-flex items-center rounded-full bg-amber-600/15 text-amber-300 text-[11px] px-2 py-1">
          Local delivery only
        </span>
      )}
    </div>
  );
}
C. Show chips on all product cards (grid, list, compact)
File: client/src/components/products/product-card.tsx

Ensure the import exists:

ts
Copy
Edit
import ProductAvailabilityChips from "@/components/locality/ProductAvailabilityChips";
Right under the name/price area (in every view variant), render:

tsx
Copy
Edit
<ProductAvailabilityChips product={product} />
If the card has a compact mode, still render the chips (they‚Äôre short). This is what‚Äôs missing in your screenshot.

D. Show chips on the product detail page
File: client/src/pages/product-detail.tsx

Ensure imports:

ts
Copy
Edit
import ProductAvailabilityChips from "@/components/locality/ProductAvailabilityChips";
import { useProductLiveSync } from "@/hooks/useProductLiveSync";
Immediately after the product title/brand block:

tsx
Copy
Edit
<ProductAvailabilityChips product={product} />
2) Block carts for non-local users on local-only products (client + server)
A. Server-side guard (authoritative)
File: server/utils/fulfillment.ts (create/replace)

ts
Copy
Edit
const EARTH_R = 3958.8; // miles
const HQ = { lat: 35.5951, lng: -82.5515 }; // Asheville, NC (example)
const RADIUS = 50; // miles

function toRad(v: number) { return (v * Math.PI) / 180; }

export function isLocalMiles(lat: number, lng: number, center = HQ, radius = RADIUS) {
  if (!Number.isFinite(lat) || !Number.isFinite(lng)) return { isLocal: false, miles: Infinity };
  const dLat = toRad(lat - center.lat);
  const dLng = toRad(lng - center.lng);
  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(toRad(center.lat)) * Math.cos(toRad(lat)) * Math.sin(dLng/2)**2;
  const miles = 2 * EARTH_R * Math.asin(Math.sqrt(a));
  return { isLocal: miles <= radius, miles };
}

export function guardCartItemAgainstLocality(opts: {
  userIsLocal: boolean;
  product: { is_local_delivery_available: boolean; is_shipping_available: boolean };
}) {
  const { userIsLocal, product } = opts;
  const localOnly = !!product.is_local_delivery_available && !product.is_shipping_available;
  if (localOnly && !userIsLocal) {
    const err: any = new Error("LOCAL_ONLY_PRODUCT_OUTSIDE_ZONE");
    err.status = 400;
    err.code = "LOCAL_ONLY";
    throw err;
  }
}
File: server/routes/cart.ts ‚Äî inside the POST /api/cart/items handler, before creating the item, add:

ts
Copy
Edit
import { isLocalMiles, guardCartItemAgainstLocality } from "../utils/fulfillment";
// ...

const addresses = await storage.getUserAddresses(userId);
const defaultAddress = addresses.find(a => a.isDefault) ?? addresses[0];
const { isLocal } = defaultAddress
  ? isLocalMiles(Number(defaultAddress.latitude), Number(defaultAddress.longitude))
  : { isLocal: false };

const product = await storage.getProductById(productId);

guardCartItemAgainstLocality({
  userIsLocal: isLocal,
  product: {
    is_local_delivery_available: !!(product as any).isLocalDeliveryAvailable,
    is_shipping_available: !!(product as any).isShippingAvailable,
  },
});
This fixes your earlier ternary typo and guarantees server-side enforcement.

B. Client-side UX (disable the button & message)
File: client/src/components/AddToCartButton.tsx
Make sure it computes and blocks the local-only case for non-locals:

tsx
Copy
Edit
import { getFulfillment } from "@/lib/products/fulfillment";
import { useLocality } from "@/hooks/useLocality";

export function AddToCartButton({ product, ...props }: { product: any } & any) {
  const { data: locality } = useLocality(); // has .isLocal boolean
  const { local, shipping } = getFulfillment(product);
  const localOnly = local && !shipping;
  const blocked = localOnly && !locality?.isLocal;

  return (
    <Button
      disabled={blocked || props.disabled}
      title={blocked ? "Local delivery only ‚Äî you‚Äôre outside our zone" : undefined}
      {...props}
    >
      {blocked ? "Unavailable in your area" : "Add to Cart"}
    </Button>
  );
}
3) Real-time updates on customer pages (no more stale chips)
File: client/src/hooks/useProductLiveSync.ts (create/replace)

ts
Copy
Edit
import { useEffect } from "react";
import { useWebSocketState } from "@/hooks/useWebSocketState";
import { queryClient } from "@/lib/queryClient";

type Opts = { queryKey: any[]; productId?: string };

export function useProductLiveSync({ queryKey, productId }: Opts) {
  const { subscribe } = useWebSocketState();

  useEffect(() => {
    const offUpdate = subscribe("product:update", (payload: any) => {
      if (!productId || payload?.id === productId) {
        queryClient.invalidateQueries({ queryKey });
      }
    });
    const offCreate = subscribe("product:create", () =>
      queryClient.invalidateQueries({ queryKey })
    );
    const offDelete = subscribe("product:delete", () =>
      queryClient.invalidateQueries({ queryKey })
    );
    return () => {
      offUpdate?.(); offCreate?.(); offDelete?.();
    };
  }, [subscribe, JSON.stringify(queryKey), productId]);
}
Use it:

client/src/pages/products.tsx

tsx
Copy
Edit
import { useProductLiveSync } from "@/hooks/useProductLiveSync";
// ...
useProductLiveSync({ queryKey: ["products"] });
client/src/pages/product-detail.tsx

tsx
Copy
Edit
useProductLiveSync({ queryKey: ["product", id], productId: id });
client/src/pages/home.tsx (for featured)

tsx
Copy
Edit
useProductLiveSync({ queryKey: ["featured-products"] });
4) Remove ‚ÄúConnecting‚Ä¶‚Äù badge from customer pages
Search for the little status UI (it prints ‚ÄúConnecting‚Ä¶‚Äù with a red dot). It typically lives in a header or a tiny helper component.

Rule: Only render that indicator in development or admin.

Wrap the JSX that renders that indicator with:

tsx
Copy
Edit
{(import.meta.env.MODE === "development" || location.pathname.startsWith("/admin")) && (
  <WebSocketStatusIndicator />
)}
5) Kill the last legacy imports in bulk (safe to run)
Run these in the Replit shell:

bash
Copy
Edit
# normalize legacy socket imports to the new hook
grep -RIl --include="*.ts*" '@/hooks/useWebSocket(?!State)' client/src \
  | xargs -I{} sed -i 's#@/hooks/useWebSocket#@/hooks/useWebSocketState#g' {}

# remove accidental duplicate imports that caused the StripeTab error
sed -i '/useWebSocketState/!b;n;/useWebSocketState/d' client/src/pages/admin/StripeTab.tsx
6) Validations to perform (quick)
Admin ‚Üí Edit Product ‚Üí Save

No error toast. No ‚Äúsend is not a function.‚Äù

Featured/price/flags update instantly in the table.

/products (grid)

Every card shows the correct chips (Local, Shipping, or both).

Toggle a product‚Äôs flags in admin and watch the chips update within ~1‚Äì2s.

/product/:id (detail)

Chips appear under the title.

If Local-only and you‚Äôre outside the zone, Add to Cart is disabled with tooltip.

Cart API

Try POST /api/cart/items with a Local-only product while non-local: receives 400 LOCAL_ONLY.

No ‚ÄúConnecting‚Ä¶‚Äù badge on customer pages (but still visible in admin/dev).

7) Notes about duplicates (already aligned)
ProductList ‚Üí keep using product-grid.tsx everywhere. If any file still imports ProductList, re-point to product-grid.

ProductsManager.tsx vs ProductsTab.tsx ‚Üí use ProductsTab as the one source of truth.

That‚Äôs it. Apply the snippets exactly as above. This resolves the crashes in your logs, restores edits/saves in admin, and guarantees the delivery/fulfillment UX shows correctly on all product cards and on the product detail page, with hard server-side enforcement for carts.