Short answer: seeing a lot of rows in a sessions table is common, but the pattern in your screenshots means your server is creating new sessions for anonymous hits (and possibly every request), which is wasteful and can also explain your /api/user 401.

What’s likely happening

You’re using express-session with a Postgres store (connect-pg-simple). The columns sid | sess (jsonb) | expire match that.

New rows are being written for every visit (bots, health checks, first-page loads) because saveUninitialized: true or because the cookie isn’t sticking (domain/secure/samesite/secret mismatch), so the server thinks each request is a new client.

If you run multiple instances and their SESSION_SECRET differs, each instance will reject the other’s cookie signature → session thrash (many rows; user keeps getting logged out/401).

If the session middleware isn’t mounted on the /api/user server (or mounted with a different cookie name/secret), that route will never see a session → 401.

Do this (copy-pasteable)

1) Use a single, correct session middleware

Create session.ts and import it in your server before your routes:

// session.ts
import session from 'express-session';
import PgSimple from 'connect-pg-simple';
import { pool } from './db/pool'; // your shared pg Pool

const PgSession = PgSimple(session);

const isProd = process.env.NODE_ENV === 'production';

function baseDomain() {
  // Set to your apex in prod if you use subdomains (e.g. ".cleanflip.com")
  return isProd ? '.your-domain.com' : undefined;
}

export const sessionMiddleware = session({
  store: new PgSession({
    pool,
    tableName: 'sessions',
    createTableIfMissing: true,
    ttl: 7 * 24 * 60 * 60,          // 7 days (seconds)
    pruneSessionInterval: 60 * 60,  // prune expired rows hourly
  }),
  secret: process.env.SESSION_SECRET!, // MUST be identical across all instances
  name: 'cf.sid',
  resave: false,            // do not write on every request
  saveUninitialized: false, // don’t create rows for anonymous visitors
  cookie: {
    path: '/',
    httpOnly: true,
    secure: isProd,                         // HTTPS only in prod
    sameSite: isProd ? 'none' : 'lax',      // 'none' if cross-site
    domain: baseDomain(),
    maxAge: 7 * 24 * 60 * 60 * 1000,        // 7 days (ms)
  },
});


Mount it (and trust your proxy) before your routers:

import express from 'express';
import { sessionMiddleware } from './session';

const app = express();
app.set('trust proxy', 1); // behind Vercel/Cloudflare/NGINX

app.use(sessionMiddleware);

// If you want to avoid sessions on static files/health:
app.use('/api', sessionMiddleware);

2) Make /api/user read the session you set at login

Login should regenerate the session and set your user data:

app.post('/api/login', async (req, res, next) => {
  const user = await verifyCredentials(req.body.email, req.body.password);
  if (!user) return res.status(401).json({ error: 'Invalid login' });

  req.session.regenerate(err => {
    if (err) return next(err);
    req.session.userId = user.id;
    req.session.email = user.email;
    res.json({ ok: true });
  });
});

app.get('/api/user', (req, res) => {
  if (req.session?.userId) {
    return res.json({ id: req.session.userId, email: req.session.email });
  }
  return res.status(401).json({ error: 'Not authenticated' });
});

3) Make sure the cookie is actually sent

Client-side calls must include credentials:

// fetch
await fetch('/api/user', { credentials: 'include' });

// axios
axios.defaults.withCredentials = true;


And if your web and API are on different subdomains, your cookie needs:

domain: .your-domain.com

sameSite: 'none' and secure: true (HTTPS)

4) One secret everywhere

Set one SESSION_SECRET for all instances in the same environment (all pods/functions). If they differ, you’ll see endless new rows and random 401s.

5) Keep the table tidy and fast

Ensure there’s an index on expire (connect-pg-simple usually creates it, but verify):

CREATE INDEX IF NOT EXISTS sessions_expire_idx ON sessions(expire);


It’s safe to clean old rows manually if needed:

DELETE FROM sessions WHERE expire < NOW();


(the store’s pruneSessionInterval will also do this automatically)

6) Quick self-check

In the browser DevTools → Application → Cookies, confirm you have cf.sid (or your cookie name), path /, proper domain, not “hostOnly” when you need subdomains.

Hit a debug endpoint to see what the server receives:

app.get('/api/_debug/session', (req, res) => {
  res.json({
    id: req.sessionID,
    hasSession: !!req.session,
    userId: req.session?.userId ?? null,
    cookiesHeader: req.headers.cookie ?? null,
  });
});


If /api/_debug/session shows cookiesHeader: null, your client isn’t sending the cookie → fix withCredentials/CORS/cookie flags.

If cookiesHeader is present but hasSession: false or a new id on every hit, check:

SESSION_SECRET mismatch across instances

secure/sameSite/domain combo preventing the browser from storing/returning it

Session middleware not mounted on the /api server/route

So… is it “supposed” to look like that?

You will accumulate session rows over time.

You should not see a brand-new row for every anonymous request or every page refresh from the same browser. If you do, flip saveUninitialized to false, ensure one SESSION_SECRET, and verify the cookie flags/domains so the browser actually sends the same cookie back.