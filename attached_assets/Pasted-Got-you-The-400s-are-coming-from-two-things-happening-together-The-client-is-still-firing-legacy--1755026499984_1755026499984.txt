Got you. The 400s are coming from two things happening together:

The client is still firing legacy POST /cart calls.

Your sanitizer/middleware is rejecting POST /api/cart as “potentially unsafe”.

Here’s the shortest path to a full, permanent fix. Hand this to Replit.

1) Client: guarantee we only hit /api/cart
A. Replace all legacy calls

bash
Copy
Edit
# must return ZERO results after fix
rg -n "\"/cart\"" src client
B. Centralize one helper and use it everywhere
src/api/cart.ts

ts
Copy
Edit
export async function addToCart({
  productId, variantId, quantity = 1,
}: { productId: string; variantId?: string; quantity?: number }) {
  const res = await fetch("/api/cart", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    credentials: "include",
    body: JSON.stringify({ productId, variantId, quantity }),
  });
  const text = await res.text();
  if (!res.ok) throw new Error(`Add to cart failed ${res.status}: ${text}`);
  return text ? JSON.parse(text) : {};
}
Wire all “Add to Cart” buttons to only call this function.
In Network tab you should now see exactly one request: POST /api/cart.

2) Server: allow /api/cart through sanitizer and validate the body
A. Ensure middleware order

ts
Copy
Edit
app.use(express.json());        // 1) parse JSON first
app.use(cookieParser());        // 2) cookies for guest cart
app.use(sanitizeRequest);       // 3) your sanitizer (fixed below)
app.use("/api", apiRouter);     // 4) routes
B. Fix the sanitizer (narrow scope + allowlist)
server/middleware/sanitize.ts

ts
Copy
Edit
const FORBIDDEN = /(<|>|script:|javascript:|data:|on\w+=)/i;
const ALLOW = [
  /^\/api\/cart$/,               // allow our cart API
  /^\/api\/user$/,
  /^\/api\/products$/,
  /^\/api\/track-activity$/,
];

export function sanitizeRequest(req, res, next) {
  if (ALLOW.some(rx => rx.test(req.path))) return next();

  const scan = (v:any): boolean => {
    if (typeof v === "string") return FORBIDDEN.test(v);
    if (v && typeof v === "object") return Object.values(v).some(scan);
    return false; // numbers/bools OK
  };

  if (scan(req.body) || scan(req.query) || scan(req.params)) {
    return res.status(400).json({
      error: "Invalid input data",
      message: "Request contains potentially unsafe content",
    });
  }
  next();
}
C. Implement robust /api/cart handler
server/routes/cart.ts

ts
Copy
Edit
import { z } from "zod";
const AddSchema = z.object({
  productId: z.string().min(1),
  variantId: z.string().optional(),
  quantity: z.number().int().positive().default(1),
});

app.post("/api/cart", async (req, res) => {
  console.info("POST /api/cart body:", req.body); // TEMP: confirm payload
  const parsed = AddSchema.safeParse(req.body);
  if (!parsed.success) {
    return res.status(400).json({ error: "Invalid input", details: parsed.error.flatten() });
  }
  const { productId, variantId, quantity } = parsed.data;

  const cartId = getOrCreateCartId(req, res); // sets cookie for guests
  const product = await db.products.findById(productId); // map to your real lookup
  if (!product) return res.status(404).json({ error: "Product not found" });
  if (product.stock <= 0) return res.status(409).json({ error: "Out of stock" });

  const updated = await carts.addItem({ cartId, productId, variantId, quantity });
  return res.status(200).json(updated);
});

function getOrCreateCartId(req, res) {
  let { cartId } = req.cookies || {};
  if (!cartId) {
    cartId = crypto.randomUUID();
    res.cookie("cartId", cartId, {
      httpOnly: true, sameSite: "Lax",
      secure: process.env.NODE_ENV === "production",
      path: "/", maxAge: 1000*60*60*24*30,
    });
    carts.create(cartId);
  }
  return cartId;
}
If your DB uses a different key (e.g., sku or _id), update findById(productId) accordingly.

D. Remove/redirect the legacy route
Delete any app.post("/cart" …). If you must keep it briefly:

ts
Copy
Edit
app.post("/cart", (_req, res) => res.redirect(308, "/api/cart"));
3) Verify (don’t skip)
Dev tools → Network while clicking Add to Cart:

✅ One request: POST /api/cart

❌ Zero requests to /cart

Server logs show:

css
Copy
Edit
POST /api/cart body: { productId: "...", quantity: 1 }
POST /api/cart 200
GET /api/cart shows the new item.

Mini-cart updates (invalidate ["cart"] query on success).

Repo checks

bash
Copy
Edit
rg -n "\"/cart\"" src server client   # should be 0
rg -n "app\\.(post|get|put|delete)\\(\"/cart" server   # should be 0 (or only the 308 redirect temporarily)
4) If it still returns 400
Paste the server log line POST /api/cart body: … (so we see the exact payload).

Confirm the sanitizer file above is mounted after express.json().

Confirm your handler returns structured error JSON (you already see it in the toast).