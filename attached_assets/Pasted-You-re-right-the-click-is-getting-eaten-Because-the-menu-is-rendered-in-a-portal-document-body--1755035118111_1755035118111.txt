You’re right—the click is getting “eaten.”
Because the menu is rendered in a portal (document.body), your outside-click listener (on document.mousedown) fires when you click an option, immediately closing the menu before the option’s onClick runs.

What I changed (core fix)
Outside-click handler now ignores clicks inside the menu as well as the root.

Switched to pointerdown (works for mouse + touch) and added a single handler.

In the menu container, I stop propagation on pointerdown/click so the document handler never runs for inside clicks.

Drop this in as a full replacement for src/components/ui/Dropdown.tsx:

tsx
Copy
Edit
// src/components/ui/Dropdown.tsx
import { useState, useRef, useEffect, useCallback } from "react";
import { createPortal } from "react-dom";
import { ChevronDown } from "lucide-react";

export interface DropdownOption {
  label: string;
  value: string; // we standardize on strings
}

interface DropdownProps {
  options: DropdownOption[];
  value: string | null;                 // controlled value only
  onChange: (value: string) => void;    // MUST accept a string
  placeholder?: string;
  className?: string;
  menuClassName?: string;
  id?: string;
  name?: string;
  disabled?: boolean;
}

function normalize(v: unknown): string | null {
  if (v == null) return null;
  return String(v).trim();
}

export default function Dropdown({
  options,
  value,
  onChange,
  placeholder = "Select...",
  className = "",
  menuClassName = "",
  id,
  name,
  disabled = false,
}: DropdownProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [menuPos, setMenuPos] = useState<{ left: number; top: number; width: number }>({ left: 0, top: 0, width: 0 });
  const rootRef = useRef<HTMLDivElement>(null);
  const buttonRef = useRef<HTMLButtonElement>(null);
  const menuRef = useRef<HTMLDivElement>(null);

  // Normalize both current value and options
  const current = normalize(value);
  const normalizedOptions = options.map(o => ({ label: o.label, value: normalize(o.value)! }));
  const selectedOption = normalizedOptions.find(opt => opt.value === current) ?? null;

  // Close on outside click/tap – but ignore clicks inside the portal menu.
  useEffect(() => {
    if (!isOpen) return;

    const handlePointerDown = (e: PointerEvent) => {
      const t = e.target as Node;
      const insideRoot = !!rootRef.current?.contains(t);
      const insideMenu = !!menuRef.current?.contains(t);
      if (!insideRoot && !insideMenu) setIsOpen(false);
    };

    document.addEventListener("pointerdown", handlePointerDown);
    return () => document.removeEventListener("pointerdown", handlePointerDown);
  }, [isOpen]);

  // Position menu (prevents clipping)
  const updateMenuPos = useCallback(() => {
    const el = buttonRef.current;
    if (!el) return;
    const r = el.getBoundingClientRect();
    setMenuPos({ left: r.left + window.scrollX, top: r.bottom + window.scrollY + 6, width: r.width });
  }, []);

  useEffect(() => {
    if (!isOpen) return;
    updateMenuPos();
    const onScroll = () => updateMenuPos();
    const onResize = () => updateMenuPos();
    window.addEventListener("scroll", onScroll, true);
    window.addEventListener("resize", onResize, true);
    return () => {
      window.removeEventListener("scroll", onScroll, true);
      window.removeEventListener("resize", onResize, true);
    };
  }, [isOpen, updateMenuPos]);

  // Minimal keyboard navigation
  useEffect(() => {
    if (!isOpen) return;
    const handler = (e: KeyboardEvent) => {
      const items = Array.from(menuRef.current?.querySelectorAll<HTMLButtonElement>("[data-option]") ?? []);
      const idx = Math.max(0, items.findIndex((n) => n === document.activeElement));
      if (e.key === "Escape") setIsOpen(false);
      if (e.key === "ArrowDown") { e.preventDefault(); (items[idx + 1] ?? items[0])?.focus(); }
      if (e.key === "ArrowUp")   { e.preventDefault(); (items[idx - 1] ?? items[items.length - 1])?.focus(); }
      if (e.key === "Enter")     { (document.activeElement as HTMLButtonElement | null)?.click(); }
    };
    document.addEventListener("keydown", handler);
    return () => document.removeEventListener("keydown", handler);
  }, [isOpen]);

  const empty = !selectedOption;

  return (
    <div ref={rootRef} className={`relative ${className}`}>
      <button
        ref={buttonRef}
        id={id}
        name={name}
        type="button"
        disabled={disabled}
        onClick={() => setIsOpen((o) => !o)}
        data-empty={empty ? "true" : "false"}
        className={[
          "flex items-center justify-between w-full",
          "px-3 py-2 text-sm rounded-md",
          "border border-white/10",
          "bg-slate-800/70 hover:bg-slate-800",
          "focus:outline-none focus:ring-2 focus:ring-blue-500/60",
          disabled ? "opacity-60 cursor-not-allowed" : "",
        ].join(" ")}
        aria-haspopup="listbox"
        aria-expanded={isOpen}
      >
        <span
          className={empty ? "cf-placeholder" : "text-slate-100"}
          style={empty ? { color: "rgba(255,255,255,0.45)" } : undefined}
        >
          {selectedOption?.label ?? placeholder}
        </span>
        <ChevronDown className={`w-4 h-4 ${isOpen ? "rotate-180" : ""} ${empty ? "text-white/60" : "text-slate-300"} transition-transform`} />
      </button>

      {isOpen &&
        createPortal(
          <div
            ref={menuRef}
            role="listbox"
            style={{ position: "absolute", left: menuPos.left, top: menuPos.top, width: menuPos.width, zIndex: 60 }}
            className={[
              "rounded-md border border-white/10",
              "bg-[#121822]/95 backdrop-blur",
              "shadow-xl shadow-black/30",
              "max-h-60 overflow-auto",
              "animate-[fadeIn_120ms_ease-out]",
              menuClassName || "",
            ].join(" ")}
            // Critical: stop events so the document listener doesn't close us first.
            onPointerDown={(e) => { e.stopPropagation(); }}
            onClick={(e) => { e.stopPropagation(); }}
          >
            {normalizedOptions.map((option) => {
              const isSelected = option.value === current;
              return (
                <button
                  key={option.value}
                  type="button"
                  role="option"
                  aria-selected={isSelected}
                  data-option
                  onClick={() => {
                    onChange(option.value);
                    setIsOpen(false);
                  }}
                  className={[
                    "w-full px-3 py-2 text-sm text-left transition-colors",
                    isSelected ? "bg-blue-500/10 text-blue-300" : "text-slate-100 hover:bg-white/5",
                  ].join(" ")}
                >
                  {option.label}
                </button>
              );
            })}
          </div>,
          document.body
        )}
    </div>
  );
}
Why this fixes all pages
The old document.mousedown “outside click” closed the dropdown on any click inside the portal (Sell-to-Us, Contact Us, Dev dashboard all share this component). That unmounted the menu before the option’s onClick could fire, so selection “did nothing.”

We now (a) ignore clicks inside menuRef, and (b) stop bubbling from the menu entirely. Option onClick runs, onChange fires, then we close intentionally.