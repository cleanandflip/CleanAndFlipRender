REPLIT: Ship Single-Source-of-Truth Address System + Rock-Solid Local Checks
Goals
ONE source of truth for shipping address (SSOT). No duplicates anywhere.

Pages that must use SSOT:

/dashboard?tab=addresses

/onboarding (step 1 address; step 2 contact; step 3 prefs)

/onboarding?step=1&from=cart (guarded redirect from cart)

Checkout → shipping panel

Local customer determination must be reliable and enforced:

Only local users can add local-only products to cart and submit items for sale.

Local users get free local delivery within 48 hours (surface this at checkout and product detail).

Remove SMS updates everywhere.

Fix current bugs: Zod 500s on /api/addresses, onboarding loop, “Add Address” buttons, Geoapify 429 spam, weak phone validation, and prefills not working.

Make checkout form borders more visible and focus states accessible.

1) Data model (SSOT)
SQL migrations (Postgres)
sql
Copy
Edit
-- Canonical addresses table
CREATE TABLE IF NOT EXISTS addresses (
  id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id      UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  first_name   TEXT NOT NULL,
  last_name    TEXT NOT NULL,
  street1      TEXT NOT NULL,
  street2      TEXT,
  city         TEXT NOT NULL,
  state        TEXT NOT NULL,          -- 2-letter code
  postal_code  TEXT NOT NULL,
  country      TEXT NOT NULL DEFAULT 'US',
  latitude     NUMERIC(9,6),
  longitude    NUMERIC(9,6),
  is_local     BOOLEAN NOT NULL DEFAULT FALSE,
  is_default   BOOLEAN NOT NULL DEFAULT TRUE,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- One profile address pointer per user (SSOT)
ALTER TABLE users
  ADD COLUMN IF NOT EXISTS profile_address_id UUID REFERENCES addresses(id),
  ADD COLUMN IF NOT EXISTS onboarding_completed_at TIMESTAMPTZ;

-- Ensure only one default address per user
CREATE UNIQUE INDEX IF NOT EXISTS uniq_default_address_per_user
ON addresses(user_id) WHERE is_default = TRUE;

-- Products: gating flags
ALTER TABLE products
  ADD COLUMN IF NOT EXISTS is_local_only BOOLEAN NOT NULL DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS shipping_available BOOLEAN NOT NULL DEFAULT TRUE;

-- Submissions (if you gate by local eligibility)
ALTER TABLE submissions
  ADD COLUMN IF NOT EXISTS requires_local_customer BOOLEAN NOT NULL DEFAULT TRUE;
Note: earlier error column "is_local_delivery" does not exist—stop referencing that column. Use is_local_only on products and compute delivery eligibility from addresses.is_local.

2) Server contracts
Zod schema (align client → server)
server/routes/addresses.ts

ts
Copy
Edit
const AddressSchema = z.object({
  firstName: z.string().min(1),
  lastName: z.string().min(1),
  street1: z.string().min(1),
  street2: z.string().optional().default(''),
  city: z.string().min(1),
  state: z.string().length(2),
  postalCode: z.string().min(5).max(10),
  country: z.string().default('US'),
  latitude: z.number().optional(),
  longitude: z.number().optional(),
  setAsDefault: z.boolean().optional().default(true)
});
REST endpoints (authoritative)
GET /api/addresses → list for current user. Include is_default.

POST /api/addresses → validate with AddressSchema, upsert, compute is_local, set users.profile_address_id when setAsDefault.

PUT /api/addresses/:id → same validation; maintain default uniqueness.

DELETE /api/addresses/:id → if deleting default, move default to newest remaining (if any) and clear users.profile_address_id if none remain.

GET /api/user → include profileAddress (expanded) and isLocal (derived from that address).

POST /api/onboarding/complete → mark users.onboarding_completed_at = now() and ensure profile_address_id is set.

Return 400 for validation failures, not 500. (Right now Zod errors are bubbling to 500.)

3) Reliable “LOCAL CUSTOMER” computation
Business rule
Define local service area as a geofence: polygon of supported ZIPs or radius (e.g., 25 mi) around HQ (e.g., Asheville). Persist in config/env.

Implementation
server/lib/geo.ts

ts
Copy
Edit
export function isLocal({ lat, lng }: { lat: number; lng: number }): boolean {
  // Haversine distance from HQ to user address
  const HQ = { lat: +process.env.HQ_LAT, lng: +process.env.HQ_LNG };
  const R = 6371e3; // meters
  const φ1 = HQ.lat * Math.PI/180, φ2 = lat * Math.PI/180;
  const Δφ = (lat - HQ.lat) * Math.PI/180;
  const Δλ = (lng - HQ.lng) * Math.PI/180;
  const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
  const d = 2 * R * Math.asin(Math.sqrt(a));
  const miles = d / 1609.34;
  return miles <= +process.env.LOCAL_RADIUS_MILES; // e.g., 25
}
When saving an address, fill latitude/longitude from Geoapify response and set addresses.is_local = isLocal(...).

GET /api/user returns isLocal based on profile_address_id.

Enforcement

Cart API (POST /api/cart/items, PUT /api/cart/validate, checkout session create):

If product is_local_only === true, require user.isLocal === true else 400 with actionable error.

At checkout, revalidate cart gating server-side.

Sell flow (POST /api/submissions):

If requires_local_customer and user is not local → block with 400.

UI:

Non-locals: “Add to Cart” disabled for local-only items with tooltip (“Local pickup/delivery only in service area.”)

Locals: surface “Free local delivery in 48 hours” banner on PDP and checkout summary.

4) Geoapify usage (no more 429s)
Client autocomplete debounce 400–600ms and min 3 chars before calling.

Server-side caching: cache recent queries for 24h in memory (or Redis if enabled). Key: geo:<q>.

Backoff: on 429, use exponential backoff (250ms, 500ms, 1s) up to 3 attempts; then return a 200 with { suggestions: [] } so UI stays graceful.

Always log masked URLs (current behavior is good).

5) Front-end integration (four pages)
Shared hook (single read/write path)
client/src/hooks/useAddress.ts

Exposes:

useProfileAddress() → fetches /api/user and returns profileAddress.

saveAddress(input) → POST /api/addresses, invalidates user + addresses caches.

listAddresses() → GET /api/addresses.

All pages use this hook. No page holds its own divergent address model.

A) /dashboard?tab=addresses
Wire “Add Address” and “Add New Address” buttons to open a modal that uses saveAddress().

If user has no addresses, show the CTAs (your screenshot shows this).

After save, set toast “Saved. Set as default.” and list updates.

B) /onboarding (and ?step=1&from=cart)
Step 1 (Address): use Geoapify autocomplete; on submit call saveAddress({ setAsDefault: true }).

When the call resolves, redirect to ?step=2.

Step 2 (Contact): remove SMS entirely. Only email is already known; phone is optional but must be valid if provided.

Phone validation: E.164 pattern ^\+?[1-9]\d{7,14}$. Block “Continue” until valid (no single digit/letters). Also validate server-side.

Step 3 (Prefs): remove SMS checkbox; keep only email notifications (checked by default).

On final submit: call POST /api/onboarding/complete, refresh /api/user cache, then:

If from=cart → redirect /cart (or /checkout), else redirect /dashboard.

Fix the onboarding loop: it happens because address save fails (Zod errors) or we never mark onboarding complete. The above flow resolves both.

C) Checkout (shipping panel)
Prefill from useProfileAddress(). If none:

Show the form with Geoapify autocomplete and “Save & Continue” which calls saveAddress({ setAsDefault: true }) (for signed-in users).

If guest: use the same UI but store address only in session storage and use it for shipping quote; don’t call /api/addresses.

Make borders more visible (Tailwind example):

Inputs: border border-slate-600/70 focus:border-sky-400 focus:ring-2 focus:ring-sky-400/40 rounded-lg

Card containers: border border-slate-700/60 shadow-[0_0_0_1px_rgba(148,163,184,0.15)_inset]

Error state: border-rose-500 focus:ring-rose-400/40 + inline helper text.

Before payment:

Re-fetch /api/user and GET /api/cart then POST /api/cart/validate.

If cart contains local-only items and !user.isLocal, block and route back to shipping with error banner.

6) Validation (client + server)
Client: React Hook Form + Zod resolver for all four surfaces.
Required fields: firstName, lastName, street1, city, state (2), postalCode, country.
Phone (if present) must match E.164; disable “Continue” until valid.

Server: Use the AddressSchema above. Return 400 with structured error list. Never 500 on user mistakes.

7) Remove SMS feature
Delete SMS checkbox from onboarding Step 3 and profile.

Remove any wants_sms, phone_verified, Twilio stubs, and conditionals.

Ensure preferences save endpoint ignores any SMS fields to avoid 400s from stale clients.

8) Cart & PDP gating for local-only products
PDP: If is_local_only and !user.isLocal → disable Add to Cart with tooltip.

Cart API: hard-block server-side regardless of client state.

Checkout Summary: If user.isLocal and all items are local-only → show “Free local delivery within 48 hours” line item; shipping = $0.00.

9) Observability & resilience
Fix /api/observability/errors 400s: endpoint must accept JSON { message, stack, url, userAgent, meta? } with Content-Type: application/json.

Throttle client error reporting (1 / 10s per tab) to avoid log spam.

10) QA checklist (acceptance)
Sign up → enter address in onboarding step 1 → proceed through steps → redirected to cart → /api/user returns profileAddress and isLocal set correctly.

/dashboard?tab=addresses shows the saved address; “Add Address” adds another and toggles default; users.profile_address_id updates.

Checkout pre-fills shipping for signed-in user; for guest it does not call /api/addresses but still quotes shipping.

Local gating:

Non-local cannot add local-only product (blocked UI + server).

Local can add; checkout shows “Free local delivery within 48 hours”.

Phone field rejects letters/1-digit input; cannot continue until valid. Server rejects invalid phone too.

Geoapify: typing fires calls only after 3 chars + debounce; 429s no longer bubble as errors; suggestions can be empty gracefully.

No duplicate address stores in codebase: all forms use useAddress() and /api/addresses. There is no alternate schema anywhere.

11) Cleanup tasks
Remove any legacy fields/tables referencing shipping_address, is_local_delivery, or per-page address DTOs. Migrate to SSOT only.

Refactor components to import the shared address types from a single file (client/src/types/address.ts) so fields can’t drift.

Add unit tests for isLocal() with boundary cases; integration tests for cart gating.

12) Known bug fixes to close out
Zod 500s on /api/addresses → return 400 with field list; ensure client sends required fields.

Onboarding loop → persist profile_address_id and onboarding_completed_at, then redirect.

“Add Address” buttons on dashboard → ensure onClick opens modal and calls saveAddress.

Form borders → increase contrast + focus rings as above.

If any existing user data conflicts with the new schema, run a one-time migration to copy the most recent address into addresses and set users.profile_address_id. After this, all four pages must exclusively read/write through the SSOT endpoints above.