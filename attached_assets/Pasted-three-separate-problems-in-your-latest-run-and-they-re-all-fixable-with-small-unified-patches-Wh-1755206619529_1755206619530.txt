three separate problems in your latest run, and they’re all fixable with small, unified patches.

What the logs/screens show
Client parse error (“Unexpected token < … not valid JSON”)
You clicked Remove on the product page. The client tried res.json() but the server returned an HTML error page (because a route threw a TypeError and the error middleware didn’t force JSON). Hence the toast in your screenshot.

Server route errors (cart v2)

vbnet
Copy
Edit
TypeError: storage.getProductById is not a function
TypeError: storage.removeCartItem is not a function
Your new server/routes/cart.v2.ts expects a storage adapter with getProductById and removeCartItem, but the currently wired adapter doesn’t implement those names yet.

Trailing-? locality calls were fixed, and cart add now works for locals — great. Let’s keep that hardened pattern everywhere.

Apply these patches (copy–paste)
A) Give cart.v2 the storage functions it expects (single source of truth)
File: server/storage/index.ts (create or extend)

ts
Copy
Edit
// server/storage/index.ts
import { prisma } from '../db/prisma'; // adjust import to your prisma export

export type Storage = {
  getProductById(id: string): Promise<any | null>;
  getCartItem(userId: string, productId: string): Promise<any | null>;
  upsertCartItem(userId: string, productId: string, quantity: number): Promise<any>;
  removeCartItem(userId: string, productId: string): Promise<{ count: number }>;
};

export const storage: Storage = {
  async getProductById(id) {
    return prisma.product.findUnique({ where: { id } });
  },

  async getCartItem(userId, productId) {
    return prisma.cartItem.findFirst({ where: { userId, productId } });
  },

  async upsertCartItem(userId, productId, quantity) {
    const existing = await prisma.cartItem.findFirst({ where: { userId, productId } });
    if (existing) {
      return prisma.cartItem.update({
        where: { id: existing.id },
        data: { quantity },
      });
    }
    return prisma.cartItem.create({
      data: { userId, productId, quantity },
    });
  },

  async removeCartItem(userId, productId) {
    return prisma.cartItem.deleteMany({ where: { userId, productId } });
  },
};

export default storage;
If you already have a different storage adapter, export these exact method names (proxy to your existing repo functions). The goal is to keep cart.v2.ts unchanged.

B) Make the error handler always return JSON (never HTML)
File: server/middleware/error-handler.ts (create)

ts
Copy
Edit
import type { Request, Response, NextFunction } from 'express';

export function jsonErrorHandler(err: any, req: Request, res: Response, _next: NextFunction) {
  const status = Number(err?.status || err?.statusCode || 500);
  const code = err?.code || 'INTERNAL_ERROR';

  // Don’t leak full stack in production
  const payload: any = {
    ok: false,
    code,
    message: err?.message || 'Unexpected server error',
  };

  if (process.env.NODE_ENV !== 'production') {
    payload.stack = err?.stack;
    payload.path = req.originalUrl;
  }

  // Force JSON to avoid the client trying to parse HTML
  res.status(status).type('application/json').send(payload);
}
Wire it last in your Express app:

File: server/index.ts (or wherever you build the app)

ts
Copy
Edit
import { jsonErrorHandler } from './middleware/error-handler';

// ... all routes above this line
app.use(jsonErrorHandler); // must be the last middleware
C) Ensure cart.v2 DELETE and POST always reply with JSON
File: server/routes/cart.v2.ts

ts
Copy
Edit
import { Router } from 'express';
import storage from '../storage';
import { evaluateLocality } from '../../shared/locality'; // adjust path to your shared logic
import { modeFromProduct } from '../../shared/fulfillment';

export const cartV2 = Router();

cartV2.post('/items', async (req, res, next) => {
  try {
    const userId = req.session?.user?.id as string;
    const { productId, quantity } = req.body || {};
    if (!userId) return res.status(401).json({ ok:false, code:'AUTH_REQUIRED', message:'Sign in required' });
    if (!productId || !quantity) return res.status(400).json({ ok:false, code:'BAD_REQUEST', message:'productId and quantity are required' });

    const product = await storage.getProductById(productId);
    if (!product) return res.status(404).json({ ok:false, code:'PRODUCT_NOT_FOUND', message:'Product not found' });

    // locality enforcement for LOCAL_ONLY
    const status = await evaluateLocality(req); // your unified status function
    const mode = modeFromProduct(product);
    if (mode === 'LOCAL_ONLY' && !status.eligible) {
      return res.status(403).json({
        ok: false,
        code: 'LOCAL_ONLY_NOT_ELIGIBLE',
        message: 'This item is local-delivery only and your default address is outside our zone.',
        resolution: 'Set a local default address in Asheville (28801/03/04/05/06/08).',
      });
    }

    const item = await storage.upsertCartItem(userId, productId, Number(quantity));
    return res.status(200).json({ ok: true, item });
  } catch (err) { next(err); }
});

cartV2.delete('/items/:productId', async (req, res, next) => {
  try {
    const userId = req.session?.user?.id as string;
    const { productId } = req.params;
    if (!userId) return res.status(401).json({ ok:false, code:'AUTH_REQUIRED', message:'Sign in required' });

    const result = await storage.removeCartItem(userId, productId);
    return res.status(200).json({ ok: true, removed: result.count });
  } catch (err) { next(err); }
});
That fixes both missing storage methods and guarantees JSON on success paths.

D) Make the client resilient to non-JSON responses and 204s
File: client/src/hooks/use-cart.tsx

ts
Copy
Edit
async function parseJsonSafe(res: Response) {
  const ct = res.headers.get('content-type') || '';
  if (ct.includes('application/json')) {
    return await res.json();
  }
  const text = await res.text();
  return { ok: false, message: text || res.statusText };
}

export async function addToCart(productId: string, quantity = 1) {
  const res = await fetch('/api/cart/items', {
    method: 'POST',
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ productId, quantity }),
  });

  const payload = await parseJsonSafe(res);
  if (!res.ok || payload?.ok === false) {
    throw new Error(payload?.message || 'Unable to add to cart');
  }
  return payload;
}

export async function removeFromCart(productId: string) {
  const res = await fetch(`/api/cart/items/${encodeURIComponent(productId)}`, {
    method: 'DELETE',
    credentials: 'include',
  });

  // handle 200 with JSON or 204 no content gracefully
  if (res.status === 204) return { ok: true, removed: 1 };

  const payload = await parseJsonSafe(res);
  if (!res.ok || payload?.ok === false) {
    throw new Error(payload?.message || 'Unable to remove from cart');
  }
  return payload;
}
Result: even if a server bug slips through, the client won’t crash trying to res.json() on HTML.

E) (Already done earlier) Locality object is never undefined
You’ve patched useLocality() and the UI to use a DEFAULT_LOCALITY. Keep that in place to prevent locality.eligible crashes in Navigation or elsewhere.

Why this resolves the issues
No more storage missing-method errors. cart.v2 now talks to a stable storage adapter that implements getProductById and removeCartItem.

No more HTML error pages to the client. The JSON error middleware forces all exceptions to return application/json, so the front-end won’t choke on <html>….

Client is robust. It checks content type and supports 204s, turning unknown server output into a friendly message instead of a hard error.

Consistent API semantics. All cart endpoints always return JSON { ok, ... } on success and structured { ok:false, code, message } on failure.

Quick validation checklist
Hard refresh.

Add a LOCAL ONLY item as a local user → should add.

Click Remove on product detail → should remove and update cart count, no error toast.

Temporarily force a server throw inside cart.v2 → response should still be JSON and the client toast should say the error message, not “Unexpected token <”.

Network tab: all /api/locality/status calls are without a trailing ?.

If anything else crops up (especially around the Sell-to-Us gating), send me the exact log lines and I’ll patch those paths the same way.