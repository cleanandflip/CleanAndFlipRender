CRITICAL: Implement Perfect Real-Time Synchronization for ALL Edits
Current Issue: Product image deletions work but don't sync to public pages. This needs to be fixed for EVERYTHING.
Required: Complete audit and implementation of real-time updates across the ENTIRE platform.
All these must sync instantly when edited:

Product images (add/delete/reorder)
Product titles & descriptions
Product prices & discounts
Product sizes & availability
Product categories & tags
Shipping/pickup options
Stock status (in stock/sold out)
Product condition
ANY other editable field

Implementation Strategy:

Global State Management with Real-Time Sync:

javascript// Create a global product update event system
export const productEvents = new EventTarget();

// In admin panel after ANY update:
const updateProduct = async (productId, updates) => {
  const response = await fetch(`/api/admin/products/${productId}`, {
    method: 'PUT',
    body: JSON.stringify(updates)
  });
  
  if (response.ok) {
    // Broadcast update to all components
    productEvents.dispatchEvent(
      new CustomEvent('productUpdated', { 
        detail: { productId, updates } 
      })
    );
  }
};

// In ALL product-displaying components:
useEffect(() => {
  const handleProductUpdate = (e) => {
    // Refetch or update local state
    refetchProducts();
  };
  
  productEvents.addEventListener('productUpdated', handleProductUpdate);
  return () => productEvents.removeEventListener('productUpdated', handleProductUpdate);
}, []);

Disable ALL Caching:

javascript// API routes
export async function GET(request) {
  const products = await getProducts();
  
  return NextResponse.json(products, {
    headers: {
      'Cache-Control': 'no-store, max-age=0',
      'CDN-Cache-Control': 'no-store',
      'Vercel-CDN-Cache-Control': 'no-store',
    }
  });
}

// React Query setup
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 0,
      cacheTime: 0,
      refetchOnMount: 'always',
      refetchOnWindowFocus: true,
      refetchInterval: 30000, // Poll every 30s as backup
    },
  },
});

WebSocket/Server-Sent Events (if needed):

javascript// For true real-time updates
const useRealtimeProducts = () => {
  useEffect(() => {
    const eventSource = new EventSource('/api/products/stream');
    
    eventSource.onmessage = (event) => {
      const { type, productId } = JSON.parse(event.data);
      if (type === 'update') {
        queryClient.invalidateQueries(['products']);
        queryClient.invalidateQueries(['product', productId]);
      }
    };
    
    return () => eventSource.close();
  }, []);
};

Force Refresh Pattern:

javascript// Add timestamp to all product queries
const fetchProducts = async () => {
  const response = await fetch(`/api/products?t=${Date.now()}`);
  return response.json();
};
Testing Checklist:

 Change product title → Instantly visible on /products
 Update price → Instantly visible everywhere
 Delete image → Instantly removed from all views
 Mark as sold → Instantly updated on public site
 Change shipping options → Instantly reflected
 Update any field → Changes visible without refresh

Performance Considerations:

Use optimistic updates in admin panel
Implement debouncing for rapid edits
Only refetch changed products, not entire list
Use React Query mutations for coordinated updates

MANDATORY: Every single edit in the admin panel must be immediately visible on the public site. No exceptions. No manual refreshes needed. This is critical for accurate inventory management and customer trust.
Test each feature thoroughly and ensure the synchronization is bulletproof across the entire platform.