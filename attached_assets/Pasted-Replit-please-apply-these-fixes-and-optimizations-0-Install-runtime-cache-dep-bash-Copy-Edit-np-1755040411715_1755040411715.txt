Replit — please apply these fixes and optimizations:

0) Install runtime cache dep
bash
Copy
Edit
npm i lru-cache
1) Make /api/track-activity truly fire-and-forget (instant 202)
File: server/routes.ts (or wherever the route lives)

Replace the handler with:

ts
Copy
Edit
app.post('/api/track-activity', (req, res) => {
  // return immediately
  res.status(202).end();

  // do the work off the request cycle
  setImmediate(async () => {
    try {
      await activityStore.enqueue?.(req.body)  // if queue exists
        ?? activityStore.add?.({
          ...req.body,
          ip: req.ip,
          userAgent: req.get('user-agent') ?? null,
          at: new Date()
        });
    } catch (err) {
      logger?.debug?.('track-activity enqueue failed', { err });
    }
  });
});
2) Remove bad column from submissions query (is_local_delivery)
File: server/routes.ts (the route that logs “Error fetching user submissions”, around the /api/my-submissions handler)

Search for is_local_delivery and remove it from any SELECT list, ORDER BY, or row mapping.

Example before/after (adjust to your exact query):

ts
Copy
Edit
// BEFORE (broken)
const rows = await db.query(`
  SELECT s.id, s.user_id, s.created_at, s.status, s.payload, s.is_local_delivery
  FROM submissions s
  WHERE s.user_id = $1
  ORDER BY s.created_at DESC
  LIMIT $2 OFFSET $3
`, [userId, limit, offset]);

// AFTER (no nonexistent column)
const rows = await db.query(`
  SELECT s.id, s.user_id, s.created_at, s.status, s.payload
  FROM submissions s
  WHERE s.user_id = $1
  ORDER BY s.created_at DESC
  LIMIT $2 OFFSET $3
`, [userId, limit, offset]);

// And in any mapping:
const submissions = rows.rows.map(r => ({
  id: r.id,
  userId: r.user_id,
  createdAt: r.created_at,
  status: r.status,
  payload: r.payload,
  // removed: r.is_local_delivery
}));
If the UI referenced isLocalDelivery, remove that field or compute it elsewhere; do not reference a non-existent DB column.

3) Add in-memory caching for hot GETs
File: server/routes.ts (same module where categories/products endpoints are defined)

ts
Copy
Edit
import LRU from 'lru-cache';

const apiCache = new LRU<string, any>({ max: 500, ttl: 5 * 60 * 1000 }); // 5m

// /api/categories?active=true
app.get('/api/categories', async (req, res, next) => {
  try {
    const active = String(req.query.active ?? 'all');
    const key = `categories:${active}`;
    const hit = apiCache.get(key);
    if (hit) return res.json(hit);

    const data = await categoryStore.list({ active }); // use your existing data layer
    apiCache.set(key, data);
    res.json(data);
  } catch (e) { next(e); }
});

// /api/products/featured
app.get('/api/products/featured', async (req, res, next) => {
  try {
    const key = 'products:featured';
    const hit = apiCache.get(key);
    if (hit) return res.json(hit);

    const data = await productStore.featured(); // use your existing data layer
    apiCache.set(key, data);
    res.json(data);
  } catch (e) { next(e); }
});
4) Micro-cache + proper headers for /api/observability/series
File: server/routes/observability.ts

ts
Copy
Edit
import LRU from 'lru-cache';

const seriesCache = new LRU<string, any>({ max: 50, ttl: 10 * 1000 }); // 10s

router.get('/observability/series', async (req, res, next) => {
  try {
    const days = String(req.query.days ?? '1');
    const key = `series:${days}`;
    const hit = seriesCache.get(key);
    if (hit) {
      res.set('Cache-Control', 'private, max-age=10, stale-while-revalidate=30');
      return res.json(hit);
    }

    const data = await observability.getSeries({ days: Number(days) });
    seriesCache.set(key, data);
    res.set('Cache-Control', 'private, max-age=10, stale-while-revalidate=30');
    res.json(data);
  } catch (e) { next(e); }
});
Optional: in the React Query hook for this endpoint, set staleTime: 10000 and refetchOnWindowFocus: false.

5) Vite / Tailwind dev performance tweaks
File: vite.config.ts — add/merge these options

ts
Copy
Edit
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  css: { devSourcemap: false },                // faster CSS in dev
  optimizeDeps: { include: ['framer-motion', 'lucide-react'] } // prebundle heavy deps
});
File: tailwind.config.cjs — tighten content globs

js
Copy
Edit
module.exports = {
  content: [
    './index.html',
    './src/**/*.{ts,tsx,html}'
  ],
  theme: { extend: {} },
  plugins: []
};
File: package.json — make Tailwind run in watch mode during dev

json
Copy
Edit
{
  "scripts": {
    "dev": "TAILWIND_MODE=watch NODE_ENV=development tsx server/index.ts"
  }
}
6) (Nice to have) Only in production: enable compression + long-term static caching
File: server/index.ts (wrap under production check)

ts
Copy
Edit
import compression from 'compression';

if (process.env.NODE_ENV === 'production') {
  app.use(compression());
  app.use((req, res, next) => {
    // for hashed static assets
    if (/\.[a-f0-9]{8,}\.(css|js|png|jpg|svg)$/.test(req.url)) {
      res.set('Cache-Control', 'public, max-age=31536000, immutable');
    }
    next();
  });
}
After applying:

Restart the server.

Hit /api/my-submissions to confirm the 42703 error is gone.

Click around the shop (home, featured, categories, product pages) and confirm repeated GETs are faster.

Open the admin Observability page; toggle time ranges and confirm /api/observability/series returns quickly and stops refetch thrash.

Trigger a few POST /api/track-activity calls and verify they log ~instant 202 with no long durations.