“failed to find mutation” error is coming from the client side (TanStack Query) before the request ever hits your cart API. Below is a tight, copy-pasteable plan that:

cleans up the cart client,

defines consistent mutation keys and endpoints,

rewires all “Add to Cart” UI to the new hooks, and

adds guards + diagnostics so this can’t regress.

0) Quick triage (what’s wrong)
Logs show no POST to a cart add endpoint while you click “Add to Cart”; only GETs and an occasional /api/cart/validate.

In TanStack Query v5, the error “failed to find mutation” typically appears when code tries to inspect a mutation in the cache (or invalidate using a mutation key) that was never registered, or when an outdated v4 usage is mixed with v5.

You likely have legacy code that does something like:

queryClient.invalidateQueries({ mutationKey: ['cart', 'add'] }) (invalid — invalidateQueries takes queryKey, not mutationKey), or

uses queryClient.getMutationCache().find(...) for optimistic updates; if the key mismatch occurs, you’ll see “failed to find mutation”.

We’ll eliminate all of that and move to clean v5 patterns.

1) Server API (confirm these exist)
Unify the cart endpoints (use exact paths below):

GET /api/cart → returns the full cart (items, totals, shipping_address_id)

POST /api/cart/items → body { productId: string, quantity?: number, variantId?: string | null }
Returns the updated cart.

PATCH /api/cart/items/:itemId → body { quantity: number } → updated cart

DELETE /api/cart/items/:itemId → updated cart

POST /api/cart/validate → optional validation (keep)

(from your address work) PUT /api/cart/shipping-address & POST /api/cart/shipping-address (keep)

If your code still uses /api/cart/add or /api/cart/add-item, add a 301 redirect to /api/cart/items.

2) Client API layer — replace with these functions
client/src/api/cart.ts

ts
Copy
Edit
// TanStack Query friendly API calls
export type Cart = {
  id: string;
  items: Array<{
    id: string;
    productId: string;
    name: string;
    price: number;
    quantity: number;
    variantId?: string | null;
  }>;
  shippingAddressId?: string | null;
  subtotal: number;
  total: number;
};

const j = async (res: Response) => {
  if (!res.ok) throw new Error(await res.text() || `${res.status}`);
  return res.json();
};

export const cartApi = {
  get: async (): Promise<Cart> => j(await fetch('/api/cart', { credentials: 'include' })),

  addItem: async (payload: { productId: string; quantity?: number; variantId?: string | null }): Promise<Cart> =>
    j(await fetch('/api/cart/items', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ quantity: 1, variantId: null, ...payload }),
    })),

  updateItem: async (itemId: string, quantity: number): Promise<Cart> =>
    j(await fetch(`/api/cart/items/${itemId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ quantity }),
    })),

  removeItem: async (itemId: string): Promise<Cart> =>
    j(await fetch(`/api/cart/items/${itemId}`, {
      method: 'DELETE',
      credentials: 'include',
    })),

  validate: async () =>
    j(await fetch('/api/cart/validate', { method: 'POST', credentials: 'include' })),
};
3) One set of keys. No “find mutation” calls.
client/src/hooks/use-cart.tsx (v5 style)

ts
Copy
Edit
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { cartApi, Cart } from '@/api/cart';

export const CART_QK = ['cart'] as const;

export function useCart() {
  return useQuery({
    queryKey: CART_QK,
    queryFn: cartApi.get,
    staleTime: 1000 * 30,
  });
}

export function useAddToCart() {
  const qc = useQueryClient();
  return useMutation({
    mutationKey: ['cart:add'] as const,
    mutationFn: cartApi.addItem,
    // Optimistic update
    onMutate: async (vars) => {
      await qc.cancelQueries({ queryKey: CART_QK });
      const prev = qc.getQueryData<Cart>(CART_QK);
      if (prev) {
        const next: Cart = {
          ...prev,
          items: (() => {
            const hit = prev.items.find(i => i.productId === vars.productId && i.variantId === (vars.variantId ?? null));
            if (hit) {
              return prev.items.map(i => i.id === hit.id ? { ...i, quantity: i.quantity + (vars.quantity ?? 1) } : i);
            }
            // provisional item for UX; server will reconcile id
            return prev.items.concat({
              id: `temp-${Date.now()}`,
              productId: vars.productId,
              name: 'Updating…',
              price: 0,
              quantity: vars.quantity ?? 1,
              variantId: vars.variantId ?? null,
            });
          })(),
        };
        qc.setQueryData(CART_QK, next);
      }
      return { prev };
    },
    onError: (_err, _vars, ctx) => {
      if (ctx?.prev) qc.setQueryData(CART_QK, ctx.prev);
    },
    onSettled: () => {
      // Always refetch real server cart
      qc.invalidateQueries({ queryKey: CART_QK });
    },
  });
}

export function useUpdateCartItem() {
  const qc = useQueryClient();
  return useMutation({
    mutationKey: ['cart:updateItem'] as const,
    mutationFn: ({ itemId, quantity }: { itemId: string; quantity: number }) =>
      cartApi.updateItem(itemId, quantity),
    onSettled: () => qc.invalidateQueries({ queryKey: CART_QK }),
  });
}

export function useRemoveFromCart() {
  const qc = useQueryClient();
  return useMutation({
    mutationKey: ['cart:remove'] as const,
    mutationFn: (itemId: string) => cartApi.removeItem(itemId),
    onSettled: () => qc.invalidateQueries({ queryKey: CART_QK }),
  });
}
Important removals

Delete any code that calls queryClient.getMutationCache().find(...).

Delete any invalidateQueries({ mutationKey: ... }) (that’s invalid). Only use queryKey.

Remove any legacy useMutation('stringKey', ...) v4 signatures.

Search & purge:

bash
Copy
Edit
ripgrep -n "getMutationCache|mutationKey|useMutation\('"
ripgrep -n "cart.*add.*mutation" client/src
4) Wire the button correctly
client/src/components/AddToCartButton.tsx

tsx
Copy
Edit
import { useAddToCart } from '@/hooks/use-cart';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';

export function AddToCartButton({ productId, variantId }: { productId: string; variantId?: string | null }) {
  const { toast } = useToast();
  const { mutate, isPending } = useAddToCart();

  return (
    <Button
      disabled={isPending}
      onClick={() =>
        mutate(
          { productId, variantId: variantId ?? null, quantity: 1 },
          { onError: (e: any) => toast({ title: 'Add to cart failed', description: e?.message ?? 'Please try again.', variant: 'destructive' }) }
        )
      }
    >
      {isPending ? 'Adding…' : 'Add to cart'}
    </Button>
  );
}
Make sure every product card uses this component (no inline fetch/mutation duplicates).

5) Keep cart in sync everywhere
Anywhere you show cart counts/badges:

ts
Copy
Edit
const { data: cart } = useCart();
const count = cart?.items.reduce((n,i) => n + i.quantity, 0) ?? 0;
No ad-hoc “cart” state outside React Query.

6) Dev diagnostics (so this never hides again)
Add a global listener for mutation errors:

client/src/services/globalErrorCatcher.ts (already present — extend it)

ts
Copy
Edit
import { QueryClient } from '@tanstack/react-query';

export function attachQueryDiagnostics(qc: QueryClient) {
  qc.getMutationCache().subscribe((event) => {
    if (event?.type === 'mutationError') {
      // Surface to console in dev
      // eslint-disable-next-line no-console
      console.error('[RQ] mutationError', event);
    }
  });
}
Call attachQueryDiagnostics(queryClient) right after you create the client in lib/queryClient.ts (development only).

7) Acceptance checklist
 Clicking Add to cart triggers POST /api/cart/items in the server logs.

 Button shows “Adding…” and then cart badge increments without a full page reload.

 No “failed to find mutation” in the console.

 GET /api/cart is invalidated exactly once after the mutation settles.

 Removing/updating items works and updates the UI (and logs show PATCH/DELETE calls).

 /api/cart/validate still works; call it after add/update/remove if needed, but don’t block the add mutation.

8) Extra: guard against anonymous carts misconfig
If you support guest carts, ensure the client includes cookies:

ts
Copy
Edit
fetch(url, { credentials: 'include', ... })
If your server requires a session to add items, redirect anonymous users to login. Otherwise allow a guest cart cookie.

TL;DR for Replit
Replace cart API layer with §2.

Replace cart hooks with §3 (v5 compliant, one set of keys).

Remove all code that looks up mutations in the cache or invalidates by mutationKey.

Ensure UI uses useAddToCart from §4.

Verify server receives POST /api/cart/items on click.

This will eliminate the mutation error and give you a clean, predictable add-to-cart flow.