You‚Äôre hitting a leftover call to a bare subscribe() (from the old socket hook) inside admin tabs‚Äîafter we standardized on useWebSocketState, that function no longer exists in scope, so React throws ReferenceError: subscribe is not defined at ProductsTab line ~76.

Below is a surgical v2 fix that does two things:

Add a compatible subscribe(type, handler) to the new useWebSocketState hook (so listeners keep working).

Ensure tabs that call subscribe(...) actually get it from the hook (no more global/bare calls).

It keeps your current 404 styling‚Äîno change there.

üöë Patch script (copy/paste into Replit Shell)
bash
Copy
Edit
set -e

echo "== checkpoint =="
git rev-parse --is-inside-work-tree >/dev/null 2>&1 && git add -A && git commit -m "checkpoint before ws subscribe fix" || true

echo "== 1) Upgrade the canonical hook to expose subscribe(type, fn) =="
HOOK="client/src/hooks/useWebSocketState.tsx"
if [ -f "$HOOK" ]; then
  cp "$HOOK" "${HOOK}.bak" || true
  cat > "$HOOK" <<'TSX'
// Canonical, single-source websocket hook with a tiny pub/sub shim.
// Exposes: { ready, lastMessage, subscribe }
import { useEffect, useRef, useState } from "react";

type Json = any;
type Message = { type?: string } & Record<string, Json>;
type Unsub = () => void;
type Subscriber = (msg: Message) => void;

// --- module-scope singletons (persist across hook calls) ---
let ws: WebSocket | null = null;
let wsReady = false;

// topic -> subscribers
const topics: Record<string, Set<Subscriber>> = {};
const all: Set<Subscriber> = new Set();

function dispatch(msg: Message) {
  const t = msg?.type ?? "message";
  topics[t]?.forEach((fn) => fn(msg));
  all.forEach((fn) => fn(msg));
}

function ensureSocket(): WebSocket {
  if (ws) return ws;

  // Try typical endpoints; first one that connects wins
  const candidates = [
    (import.meta as any)?.env?.VITE_WS_URL as string | undefined,
    `${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/ws`,
    `${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/socket`,
    `${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/api/ws`,
  ].filter(Boolean) as string[];

  let url = candidates[0] ?? `${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/ws`;

  ws = new WebSocket(url);

  ws.addEventListener("open", () => {
    wsReady = true;
  });

  ws.addEventListener("close", () => {
    wsReady = false;
    // basic auto-retry in 2s
    setTimeout(() => {
      ws = null;
      ensureSocket();
    }, 2000);
  });

  ws.addEventListener("message", (evt) => {
    let payload: Message;
    try {
      payload = JSON.parse((evt as MessageEvent).data);
    } catch {
      payload = { type: "message", raw: (evt as MessageEvent).data } as Message;
    }
    dispatch(payload);
  });

  return ws;
}

// exported hook
export function useWebSocketState() {
  const [ready, setReady] = useState<boolean>(wsReady);
  const lastMessageRef = useRef<Message | null>(null);

  useEffect(() => {
    const socket = ensureSocket();

    const onOpen = () => setReady(true);
    const onClose = () => setReady(false);
    const onMessage = (evt: MessageEvent) => {
      let payload: Message;
      try {
        payload = JSON.parse(evt.data);
      } catch {
        payload = { type: "message", raw: evt.data } as Message;
      }
      lastMessageRef.current = payload;
      // Note: subscribers are notified from `dispatch` inside the socket listener set at ensureSocket()
      // but setting ref here ensures components can read the latest snapshot.
    };

    socket.addEventListener("open", onOpen);
    socket.addEventListener("close", onClose);
    socket.addEventListener("message", onMessage);

    return () => {
      socket.removeEventListener("open", onOpen);
      socket.removeEventListener("close", onClose);
      socket.removeEventListener("message", onMessage);
    };
  }, []);

  // Minimal pub/sub API compatible with previous usage:
  //   const unsubscribe = subscribe("product:created", handler)
  //   const unsubscribeAll = subscribe("*", handler)
  const subscribe = (type: string, handler: Subscriber): Unsub => {
    if (type === "*" || type === "all") {
      all.add(handler);
      return () => void all.delete(handler);
    }
    if (!topics[type]) topics[type] = new Set<Subscriber>();
    topics[type].add(handler);
    return () => void topics[type].delete(handler);
  };

  return { ready, lastMessage: lastMessageRef.current, subscribe };
}

export default undefined as unknown as never; // keep it explicitly non-default to prevent old default imports
TSX
else
  echo "ERROR: $HOOK not found"; exit 1
fi

echo "== 2) Make sure any file that calls bare subscribe() actually pulls it from the hook =="
# Find TS/TSX files with a top-level 'subscribe(' call
FILES=$(grep -RIl --include="*.tsx" --include="*.ts" -E '\bsubscribe\(' client/src/pages client/src/components 2>/dev/null || true)

for F in $FILES; do
  echo "-- patching $F"

  # 2a) Ensure the hook import exists
  grep -q 'useWebSocketState' "$F" || sed -i '1 i import { useWebSocketState } from "@/hooks/useWebSocketState";' "$F"

  # 2b) Insert `const { subscribe } = useWebSocketState();` inside the first component in this file (supports function and arrow components)
  awk '
    BEGIN{inserted=0}
    # common component starts
    /(export default function|export function|function[[:space:]]+[A-Za-z0-9_]+|export[[:space:]]+const[[:space:]]+[A-Za-z0-9_]+[[:space:]]*=\s*\(\)|const[[:space:]]+[A-Za-z0-9_]+[[:space:]]*=\s*\(\))/ && inserted==0 {
      print;
      getline; 
      print;
      print "  const { subscribe } = useWebSocketState();";
      inserted=1;
      next
    }
    {print}
  ' "$F" > /tmp/.patch.tsx && mv /tmp/.patch.tsx "$F"
done

echo "== 3) Guard older code that accessed lastMessage.data directly =="
grep -RIl --include="*.tsx" --include="*.ts" 'lastMessage.data' client/src | xargs -r sed -i -E 's/\blastMessage\.data\b/lastMessage?.data/g'

echo "== 4) Quick smoke: build + featured products API =="
npm run dev >/dev/null 2>&1 & PID=$!
sleep 3
curl -sSf http://localhost:5000/api/products/featured >/dev/null && echo "OK: /api/products/featured" || (echo "FAIL: /api/products/featured"; kill $PID; exit 1)
kill $PID >/dev/null 2>&1 || true

echo "== 5) commit =="
git rev-parse --is-inside-work-tree >/dev/null 2>&1 && git add -A && git commit -m "ws: add subscribe() to hook + wire up admin tabs" || true

echo "Done ‚úÖ"
Why this fixes your error
Root cause: Old code was calling a global subscribe(...). After the refactor, there‚Äôs no such symbol in scope, so React throws ReferenceError.

Fix: We (a) provide a subscribe(type, handler) on the canonical useWebSocketState hook, and (b) ensure every file that calls subscribe(...) actually gets it from the hook:
const { subscribe } = useWebSocketState();

The hook publishes every inbound message to subscribers by message.type and also supports "*" (catch-all), so existing handlers like subscribe("product:created", ...) keep working.

Notes
That red ‚ÄúConnecting‚Ä¶‚Äù dot simply reflects ready === false. It will flip to ‚ÄúLive Updates Active‚Äù once the socket opens. If it stays red, the WS endpoint path may differ; update the candidate URLs near the top of useWebSocketState.tsx to match your server (e.g., /socket, /ws, /realtime).

404 styling stays exactly as-is; we didn‚Äôt touch not-found.tsx.









Ask ChatGPT
