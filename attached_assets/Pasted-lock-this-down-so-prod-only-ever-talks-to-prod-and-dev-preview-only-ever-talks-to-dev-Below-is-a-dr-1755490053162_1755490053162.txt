lock this down so prod only ever talks to prod and dev/preview only ever talks to dev. Below is a drop-in, environment-proof setup with guards (“tripwires”), a health endpoint, and a tiny “env doctor” you can run before starting. It fixes the error you hit (you put a full DSN into EXPECTED_DB_HOST) and makes the checks tolerant of either a host or a full DSN.

0) What you’re hitting (and why it crashed)

Your guard compared hostnames but you supplied a full DSN to EXPECTED_DB_HOST.

Also, APP_ENV=development while the expected host string you provided belonged to production.

We’ll fix this by normalizing whatever you give (host or full DSN) and by clearly separating dev vs prod variables.

1) Canonical env loader (single source of truth)

Create server/config/env.ts:

// server/config/env.ts
import * as process from "node:process";

export type AppEnv = "development" | "preview" | "staging" | "production";

// Decide app env explicitly; never infer prod from NODE_ENV alone.
export const APP_ENV: AppEnv =
  (process.env.APP_ENV as AppEnv) ||
  (process.env.NODE_ENV === "production" ? "production" : "development");

// Require at least one of these to be set per env.
function must(...keys: string[]) {
  for (const k of keys) {
    const v = process.env[k];
    if (v && v.trim()) return v.trim();
  }
  throw new Error(`Missing required env: one of ${keys.join(", ")}`);
}

// Use dedicated DSNs per env; DO NOT point both to the same DB.
export const DATABASE_URL =
  APP_ENV === "production"
    ? must("PROD_DATABASE_URL", "DATABASE_URL")
    : must("DEV_DATABASE_URL", "DATABASE_URL");

// Optional: a DSN or a bare hostname you *expect* for this env.
// We accept either to reduce human error.
export const EXPECTED_DB = (process.env.EXPECTED_DB_URL || process.env.EXPECTED_DB_HOST || "").trim();

export function extractHost(value: string): string {
  try {
    // Works for postgres:// and postgresql:// DSNs
    return new URL(value).host;
  } catch {
    // Not a URL; treat as already a host, or a DSN w/o protocol
    // Strip creds, path, and query if present
    const s = value.replace(/^postgres(ql)?:\/\//, "");
    const afterAt = s.split("@").pop() || s;
    return afterAt.split("/")[0].split("?")[0];
  }
}

export const DB_HOST = extractHost(DATABASE_URL);
export const EXPECTED_DB_HOST = EXPECTED_DB ? extractHost(EXPECTED_DB) : "";

// API base (server-to-server absolute, or leave blank and use relative on client)
export const API_BASE_URL =
  APP_ENV === "production"
    ? process.env.API_BASE_URL_PROD?.trim() || ""
    : process.env.API_BASE_URL_DEV?.trim() || "";

// Helpful banner
export const ENV_BANNER = `[ENV_CONFIG] APP_ENV=${APP_ENV}, DATABASE_URL host=${DB_HOST}`;

2) Unbreakable guard (accepts host or DSN)

Create server/config/env-guard.ts:

// server/config/env-guard.ts
import { APP_ENV, DB_HOST, EXPECTED_DB_HOST, ENV_BANNER } from "./env";

export function assertEnvSafety() {
  console.log(ENV_BANNER);
  console.log(`[ENV_GUARD] APP_ENV=${APP_ENV} DB_HOST=${DB_HOST}`);

  // If an expectation is provided, enforce it.
  if (EXPECTED_DB_HOST && DB_HOST !== EXPECTED_DB_HOST) {
    console.error(`❌ ENV_GUARD VIOLATION: Expected DB host '${EXPECTED_DB_HOST}' but got '${DB_HOST}'`);
    console.error(`❌ This prevents cross-environment contamination`);
    throw new Error(
      `ENV_GUARD: Refusing to start. APP_ENV=${APP_ENV} but DATABASE_URL host=${DB_HOST} != EXPECTED_DB_HOST=${EXPECTED_DB_HOST}`
    );
  }

  // Extra opinionated safety rails (optional, keep if helpful):
  if (APP_ENV !== "production") {
    // In dev/preview/staging we defensively forbid known prod hosts if the user forgot EXPECTED_DB_HOST
    const knownProdHosts = (process.env.KNOWN_PROD_HOSTS || "").split(",").map(s => s.trim()).filter(Boolean);
    if (knownProdHosts.length && knownProdHosts.includes(DB_HOST)) {
      throw new Error(`ENV_GUARD: Dev-like env (${APP_ENV}) cannot use known prod host ${DB_HOST}`);
    }
  }

  console.log("✅ ENV_GUARD: Environment isolation verified");
}


Call it before anything touches the DB, e.g. in your server entry:

// server/index.ts (or ./dist/index.js equivalent before pool/prisma)
import { assertEnvSafety } from "./config/env-guard";
assertEnvSafety();

3) DB client that never flips silently

server/db/pool.ts (pg example):

import { Pool } from "pg";
import { DATABASE_URL } from "../config/env";

declare global { /* eslint-disable no-var */ var __pgPool: Pool | undefined; }

export const pool =
  global.__pgPool ||
  new Pool({
    connectionString: DATABASE_URL,
    ssl: { rejectUnauthorized: false },
    max: 10,
    idleTimeoutMillis: 30_000,
    keepAlive: true,
  });

if (process.env.NODE_ENV !== "production") global.__pgPool = pool;


If you use Prisma, keep schema.prisma pointing to env("DATABASE_URL") and set the correct DSN for each env. (Add the guard from §6 to block migrations against the wrong host.)

4) Sessions & cookies can’t bleed across envs

server/session.ts (express-session + connect-pg-simple):

import session from "express-session";
import PgSimple from "connect-pg-simple";
import { pool } from "../db/pool";
import { APP_ENV } from "../config/env";

const PgSession = PgSimple(session);
const isProd = APP_ENV === "production";

function cookieDomain() {
  // Set your apex only in prod if using subdomains (e.g., ".cleanflip.com")
  return isProd ? process.env.SESSION_COOKIE_DOMAIN || undefined : undefined;
}

export const sessionMiddleware = session({
  store: new PgSession({
    pool,
    tableName: "sessions",
    createTableIfMissing: true,
    ttl: 7 * 24 * 60 * 60,
    pruneSessionInterval: 60 * 60,
  }),
  secret: process.env.SESSION_SECRET!,     // one value per env; identical across pods
  name: "cf.sid",
  resave: false,
  saveUninitialized: false,                 // no sessions for anonymous hits
  cookie: {
    path: "/",
    httpOnly: true,
    secure: isProd,                         // HTTPS-only in prod
    sameSite: isProd ? "none" : "lax",      // "none" only when truly cross-site
    domain: cookieDomain(),                 // undefined in dev → hostOnly cookie
    maxAge: 7 * 24 * 60 * 60 * 1000,
  },
});


Mount it before your API routes and trust the proxy:

app.set("trust proxy", 1);
app.use(sessionMiddleware);

5) CORS is environment-scoped

server/config/cors.ts:

import cors from "cors";
import { APP_ENV } from "./env";

const devOrigins = [
  "http://localhost:3000",
  process.env.REPLIT_PREVIEW_ORIGIN || "", // e.g. https://<your>.repl.co
].filter(Boolean);

const prodOrigins = [
  "https://<your-prod-domain>",            // replace
];

export const corsMiddleware = cors({
  origin: APP_ENV === "production" ? prodOrigins : devOrigins,
  credentials: true,
});


Mount before your routes.

6) Prisma/migrate tripwire (prevents “oops I migrated prod”)

Create scripts/check-prisma-env.ts:

// scripts/check-prisma-env.ts
import { APP_ENV, DB_HOST, EXPECTED_DB_HOST } from "../server/config/env";

if (EXPECTED_DB_HOST && DB_HOST !== EXPECTED_DB_HOST) {
  console.error(`❌ Prisma guard: DB host mismatch. Expected ${EXPECTED_DB_HOST}, saw ${DB_HOST}`);
  process.exit(1);
}
if (APP_ENV !== "production") {
  const knownProdHosts = (process.env.KNOWN_PROD_HOSTS || "").split(",").map(s => s.trim()).filter(Boolean);
  if (knownProdHosts.length && knownProdHosts.includes(DB_HOST)) {
    console.error(`❌ Prisma guard: refusing to run in ${APP_ENV} against known prod host ${DB_HOST}`);
    process.exit(1);
  }
}
console.log("✅ Prisma guard OK");


Update package.json:

{
  "scripts": {
    "env:doctor": "ts-node scripts/env-doctor.ts",
    "db:guard": "ts-node scripts/check-prisma-env.ts",
    "migrate:deploy": "npm run db:guard && prisma migrate deploy",
    "start:dev": "APP_ENV=development node dist/index.js",
    "start:prod": "APP_ENV=production NODE_ENV=production node dist/index.js"
  }
}

7) Tiny “env doctor” & /api/healthz

scripts/env-doctor.ts:

// scripts/env-doctor.ts
import { APP_ENV, DB_HOST, EXPECTED_DB_HOST, API_BASE_URL, ENV_BANNER } from "../server/config/env";

console.log(ENV_BANNER);
console.log({
  APP_ENV,
  DB_HOST,
  EXPECTED_DB_HOST: EXPECTED_DB_HOST || "(not set)",
  API_BASE_URL: API_BASE_URL || "(relative client calls)",
});
if (EXPECTED_DB_HOST && DB_HOST !== EXPECTED_DB_HOST) {
  console.error("❌ EXPECTED_DB_HOST mismatch");
  process.exit(1);
}
console.log("✅ env:doctor OK");


server/routes/health.ts:

import { Router } from "express";
import { APP_ENV, DB_HOST } from "../config/env";
import { pool } from "../db/pool";

export const health = Router();

health.get("/api/healthz", async (_req, res) => {
  const r = await pool.query("select current_database() as db, current_user as role");
  res.json({
    env: APP_ENV,
    dbHost: DB_HOST,
    database: r.rows[0]?.db,
    role: r.rows[0]?.role,
  });
});


Mount: app.use(health);

8) Frontend routing: never cross environments

Prefer relative URLs from the client. If you must use absolute, make it env-aware.

client/src/lib/getApiBase.ts:

// Vite: NEXT_PUBLIC_* => import.meta.env.VITE_*
export function getApiBase(): string {
  // If unset, use relative paths (best for same-origin)
  return import.meta.env.VITE_API_BASE_URL?.trim() || "";
}
export function apiUrl(path: string): string {
  const base = getApiBase();
  const p = path.startsWith("/") ? path : `/${path}`;
  return base ? `${base.replace(/\/$/, "")}${p}` : p;
}


Usage:

import { apiUrl } from "@/lib/getApiBase";

await fetch(apiUrl("/api/cart"), {
  method: "POST",
  credentials: "include",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ productId, quantity: 1 }),
});

9) Replit & Production: set these secrets (exactly)
Replit preview / Development

APP_ENV=development

DEV_DATABASE_URL=postgresql://<dev-user>:<dev-pass>@ep-lingering-flower-.../neondb?sslmode=require

DATABASE_URL (set to the same as DEV_DATABASE_URL)

EXPECTED_DB_HOST=ep-lingering-flower-afk8pi6o.c-2.us-west-2.aws.neon.tech ← hostname only

SESSION_SECRET=<random-long-string>

REPLIT_PREVIEW_ORIGIN=https://<your>.repl.co (optional, for CORS)

KNOWN_PROD_HOSTS=ep-muddy-moon-aeggx6le-pooler.c-2.us-east-2.aws.neon.tech (optional guard)

Do NOT set any prod DSNs here.

Production

APP_ENV=production

PROD_DATABASE_URL=postgresql://<prod-user>:<prod-pass>@ep-muddy-moon-aeggx6le-pooler.../neondb?sslmode=require&channel_binding=require

DATABASE_URL (set to the same as PROD_DATABASE_URL)

EXPECTED_DB_HOST=ep-muddy-moon-aeggx6le-pooler.c-2.us-east-2.aws.neon.tech

SESSION_SECRET=<different random-long-string>

SESSION_COOKIE_DOMAIN=.your-prod-domain.com

API_BASE_URL_PROD=https://api.your-prod-domain.com

(Optional) KNOWN_PROD_HOSTS=ep-muddy-moon-aeggx6le-pooler.c-2.us-east-2.aws.neon.tech

10) Hard acceptance tests (don’t skip)

Boot guard

Run npm run env:doctor. It must print the correct APP_ENV and DB_HOST. No mismatch errors.

Starting the server in dev with a prod DSN must crash with an ENV_GUARD error.

Health endpoint

GET /api/healthz from preview shows { env: "development", dbHost: <dev host> }

The same endpoint on prod shows { env: "production", dbHost: <prod host> }

Network isolation

In preview DevTools → Network while adding to cart: only relative calls (/api/cart), not the prod domain.

Database isolation

After adding to cart in preview:

Row appears in dev cart_items

Does not appear in prod cart_items

Prisma guard

npm run migrate:deploy against the wrong host must fail before running.

Sessions

Preview cookie is hostOnly (no domain) and doesn’t appear on prod.

Prod cookie has domain .your-prod-domain.com, secure: true, sameSite: "none" if cross-site.

11) Optional (but recommended) DB-level safety

Create different Postgres roles and limit their scope:

-- On PROD cluster
CREATE ROLE app_prod LOGIN PASSWORD '***';
GRANT CONNECT ON DATABASE neondb TO app_prod;
-- Grant schema/table privileges as needed; do NOT grant to dev DB.

-- On DEV cluster
CREATE ROLE app_dev LOGIN PASSWORD '***';
GRANT CONNECT ON DATABASE neondb TO app_dev;
-- Grant only on dev DB.


Use app_prod in PROD_DATABASE_URL and app_dev in DEV_DATABASE_URL.
Even if someone misconfigures the app, credentials alone block cross-writes.

12) Why this is now “100% fixed”

Single env source selects the right DSN per APP_ENV.

Guards refuse to boot or migrate if the host doesn’t match what we expect.

Client uses relative API calls by default so preview can’t hit prod.

CORS + cookies are scoped per env; no cross-site leakage.

Healthz + doctor make it obvious what your app is connected to—every time.

One last security reminder

You previously posted plaintext DSNs. Rotate both dev and prod passwords and update the DSNs above accordingly.

If you want, paste your current server/index.ts and package.json scripts; I’ll wire in the exact imports and make sure the guard runs before any DB work.