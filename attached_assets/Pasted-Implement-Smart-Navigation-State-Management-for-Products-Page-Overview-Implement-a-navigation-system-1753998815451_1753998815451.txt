Implement Smart Navigation State Management for Products Page
Overview
Implement a navigation system where filters persist when viewing a product and returning, but reset when navigating away to other pages.
1. Create Navigation State Manager
typescript// src/lib/navigation-state.ts
export class NavigationStateManager {
  private static STORAGE_KEY = 'nav-state';
  private static PREVIOUS_PATH_KEY = 'prev-path';
  
  // Save current state with navigation context
  static saveState(path: string, state: any, fromPath: string) {
    const navState = {
      [path]: {
        state,
        savedAt: Date.now(),
        fromPath
      }
    };
    
    sessionStorage.setItem(this.STORAGE_KEY, JSON.stringify(navState));
    sessionStorage.setItem(this.PREVIOUS_PATH_KEY, fromPath);
  }
  
  // Get state only if coming from specific path
  static getState(path: string, expectedFromPath?: string): any {
    const stored = sessionStorage.getItem(this.STORAGE_KEY);
    const previousPath = sessionStorage.getItem(this.PREVIOUS_PATH_KEY);
    
    if (!stored) return null;
    
    try {
      const navState = JSON.parse(stored);
      const pathState = navState[path];
      
      if (!pathState) return null;
      
      // If expectedFromPath is provided, only return state if it matches
      if (expectedFromPath && previousPath !== expectedFromPath) {
        this.clearState(path);
        return null;
      }
      
      // Clear state if older than 30 minutes
      if (Date.now() - pathState.savedAt > 30 * 60 * 1000) {
        this.clearState(path);
        return null;
      }
      
      return pathState.state;
    } catch {
      return null;
    }
  }
  
  // Clear state for a specific path
  static clearState(path: string) {
    const stored = sessionStorage.getItem(this.STORAGE_KEY);
    if (!stored) return;
    
    try {
      const navState = JSON.parse(stored);
      delete navState[path];
      sessionStorage.setItem(this.STORAGE_KEY, JSON.stringify(navState));
    } catch {
      // Invalid state, clear all
      sessionStorage.removeItem(this.STORAGE_KEY);
    }
  }
  
  // Clear all navigation state
  static clearAll() {
    sessionStorage.removeItem(this.STORAGE_KEY);
    sessionStorage.removeItem(this.PREVIOUS_PATH_KEY);
  }
}
2. Update Products Page with State Management
typescript// src/pages/products.tsx
import { useState, useEffect, useRef } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { NavigationStateManager } from '@/lib/navigation-state';

interface ProductsPageState {
  filters: {
    category: string;
    minPrice: number;
    maxPrice: number;
    condition: string;
    brand: string;
    sortBy: string;
  };
  searchQuery: string;
  currentPage: number;
  scrollPosition: number;
}

export function ProductsPage() {
  const location = useLocation();
  const navigate = useNavigate();
  const scrollRestorationRef = useRef<boolean>(false);
  
  // Initialize state with saved state if coming from product detail
  const [filters, setFilters] = useState(() => {
    const savedState = NavigationStateManager.getState(
      '/products',
      '/products/*' // Only restore if coming from a product detail page
    );
    
    return savedState?.filters || {
      category: '',
      minPrice: 0,
      maxPrice: 1000,
      condition: 'all',
      brand: '',
      sortBy: 'newest'
    };
  });
  
  const [searchQuery, setSearchQuery] = useState(() => {
    const savedState = NavigationStateManager.getState('/products', '/products/*');
    return savedState?.searchQuery || '';
  });
  
  const [currentPage, setCurrentPage] = useState(() => {
    const savedState = NavigationStateManager.getState('/products', '/products/*');
    return savedState?.currentPage || 1;
  });
  
  // Save state before navigating away
  useEffect(() => {
    const handleBeforeUnload = () => {
      const currentState: ProductsPageState = {
        filters,
        searchQuery,
        currentPage,
        scrollPosition: window.scrollY
      };
      
      NavigationStateManager.saveState(
        '/products',
        currentState,
        location.pathname
      );
    };
    
    // Save state when component unmounts
    return () => {
      handleBeforeUnload();
    };
  }, [filters, searchQuery, currentPage, location.pathname]);
  
  // Restore scroll position
  useEffect(() => {
    const savedState = NavigationStateManager.getState('/products', '/products/*');
    
    if (savedState?.scrollPosition && !scrollRestorationRef.current) {
      scrollRestorationRef.current = true;
      
      // Wait for content to load before scrolling
      setTimeout(() => {
        window.scrollTo(0, savedState.scrollPosition);
      }, 100);
    }
  }, []);
  
  // Track navigation to clear state when appropriate
  useEffect(() => {
    const clearStateIfNeeded = () => {
      const from = location.state?.from;
      
      // If not coming from a product detail page, clear the saved state
      if (from && !from.startsWith('/products/')) {
        NavigationStateManager.clearState('/products');
      }
    };
    
    clearStateIfNeeded();
  }, [location]);
  
  // Product click handler
  const handleProductClick = (productId: string) => {
    // Save current state before navigating
    const currentState: ProductsPageState = {
      filters,
      searchQuery,
      currentPage,
      scrollPosition: window.scrollY
    };
    
    NavigationStateManager.saveState(
      '/products',
      currentState,
      location.pathname
    );
    
    // Navigate with state to track where we came from
    navigate(`/products/${productId}`, {
      state: { from: location.pathname }
    });
  };
  
  // Reset filters button
  const handleResetFilters = () => {
    setFilters({
      category: '',
      minPrice: 0,
      maxPrice: 1000,
      condition: 'all',
      brand: '',
      sortBy: 'newest'
    });
    setSearchQuery('');
    setCurrentPage(1);
    
    // Clear saved state
    NavigationStateManager.clearState('/products');
  };
  
  return (
    <div className="min-h-screen bg-gray-900">
      {/* Filter sidebar */}
      <FilterSidebar 
        filters={filters}
        onFilterChange={setFilters}
        onReset={handleResetFilters}
      />
      
      {/* Search bar */}
      <SearchBar 
        value={searchQuery}
        onChange={setSearchQuery}
      />
      
      {/* Products grid */}
      <ProductGrid 
        filters={filters}
        searchQuery={searchQuery}
        currentPage={currentPage}
        onProductClick={handleProductClick}
      />
      
      {/* Pagination */}
      <Pagination 
        currentPage={currentPage}
        onPageChange={setCurrentPage}
      />
    </div>
  );
}
3. Update Product Detail Page
typescript// src/pages/product-detail.tsx
import { useNavigate, useLocation } from 'react-router-dom';

export function ProductDetailPage() {
  const navigate = useNavigate();
  const location = useLocation();
  
  // Back button handler
  const handleBackToProducts = () => {
    // Navigate back with state to indicate where we're coming from
    navigate('/products', {
      state: { from: location.pathname }
    });
  };
  
  return (
    <div>
      {/* Back button */}
      <button
        onClick={handleBackToProducts}
        className="flex items-center gap-2 text-gray-400 hover:text-white mb-4"
      >
        <ArrowLeft className="w-4 h-4" />
        Back to Products
      </button>
      
      {/* Product details */}
      {/* ... */}
    </div>
  );
}
4. Update Navigation Component
typescript// src/components/layout/navigation.tsx
import { Link, useLocation } from 'react-router-dom';
import { NavigationStateManager } from '@/lib/navigation-state';

export function Navigation() {
  const location = useLocation();
  
  // Clear products state when navigating to non-product pages
  const handleNavClick = (path: string) => {
    if (path !== '/products' && !path.startsWith('/products/')) {
      NavigationStateManager.clearState('/products');
    }
  };
  
  return (
    <nav>
      <Link 
        to="/" 
        onClick={() => handleNavClick('/')}
        state={{ from: location.pathname }}
      >
        Home
      </Link>
      
      <Link 
        to="/products" 
        onClick={() => handleNavClick('/products')}
        state={{ from: location.pathname }}
      >
        Shop
      </Link>
      
      <Link 
        to="/about" 
        onClick={() => handleNavClick('/about')}
        state={{ from: location.pathname }}
      >
        About
      </Link>
      
      {/* ... other nav links */}
    </nav>
  );
}
5. Add URL-based State (Alternative Approach)
typescript// src/hooks/useProductsState.ts
import { useSearchParams } from 'react-router-dom';

export function useProductsState() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  // Parse filters from URL
  const filters = {
    category: searchParams.get('category') || '',
    minPrice: Number(searchParams.get('minPrice')) || 0,
    maxPrice: Number(searchParams.get('maxPrice')) || 1000,
    condition: searchParams.get('condition') || 'all',
    brand: searchParams.get('brand') || '',
    sortBy: searchParams.get('sortBy') || 'newest',
    search: searchParams.get('search') || '',
    page: Number(searchParams.get('page')) || 1
  };
  
  // Update filters in URL
  const updateFilters = (newFilters: Partial<typeof filters>) => {
    const params = new URLSearchParams(searchParams);
    
    Object.entries(newFilters).forEach(([key, value]) => {
      if (value) {
        params.set(key, String(value));
      } else {
        params.delete(key);
      }
    });
    
    setSearchParams(params, { replace: true });
  };
  
  // Reset all filters
  const resetFilters = () => {
    setSearchParams(new URLSearchParams(), { replace: true });
  };
  
  return { filters, updateFilters, resetFilters };
}
6. Clean Up Legacy Code
bash# Remove old state management code
grep -r "localStorage\|sessionStorage" src/ | grep -i "filter\|search\|product"

# Remove duplicate navigation handlers
grep -r "window.history\|history.push\|history.back" src/

# Find and remove old scroll restoration code
grep -r "scrollTo\|scrollIntoView" src/ --include="*.tsx" --include="*.ts"
7. Testing Instructions

Test Filter Persistence:

Go to products page
Apply filters (category, price, etc.)
Click on a product
Click back button
✅ Filters should be preserved


Test Filter Reset:

From products page with filters
Navigate to Home/About/Contact
Navigate back to Products
✅ Filters should be reset


Test Scroll Position:

Scroll down on products page
Click a product
Click back
✅ Should return to same scroll position


Test Browser Back Button:

Same tests but using browser back button
✅ Should work the same way



Summary
This implementation provides:

Smart state persistence based on navigation context
Scroll position restoration
Clean state management without duplicates
Proper cleanup when navigating away
Support for both programmatic and browser navigation

The key is tracking where the user came from and only restoring state when returning from a product detail page, while clearing it when coming from anywhere else.