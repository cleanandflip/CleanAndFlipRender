let’s replace all ad-hoc/legacy tracking with a local, Sentry-style error system that runs entirely in your app (no third-party). Below is a complete, copy-pasteable plan for Replit: schemas, endpoints, middleware, client capture, and the Admin “Error Dashboard” UI wired to those endpoints. I also included the quick fixes for your other Dev Dashboard bugs (category not saving, submissions stuck, system analytics).

0) Ground rules for this change
All server endpoints live under /api/*.

All write endpoints have Zod validation.

One DB layer in server/data/* (no inline DB in routes).

One client API layer in src/api/* (no inline fetch in views).

Remove all legacy error logging code (files, reducers, routes, cron). Only the new system remains.

1) Local “Sentry-like” Error System (LETS)
1.1 DB Schema (Mongo or Postgres; shown here as Mongo-ish)
File: server/data/errorStore.ts

ts
Copy
Edit
// Collections:
// errors_raw: every event (for drill-down)
// issues: grouped errors (for dashboards)
// issue_events: rollup counters per issue & time-bucket (hour/day)

export type RawError = {
  _id?: string;
  eventId: string;               // uuid
  createdAt: Date;
  level: "error" | "warn" | "info";
  env: "development" | "production";
  release?: string;
  service: "client" | "server";
  url?: string;                  // page or request path
  method?: string;
  statusCode?: number;           // if request failed
  message: string;
  type?: string;                 // Error name (TypeError, etc.)
  stack?: string[];              // normalized frames
  fingerprint: string;           // grouping key
  user?: { id?: string } | null;
  tags?: Record<string, string | number | boolean>;
  extra?: Record<string, any>;   // sanitized payload diff (no PII)
};

export type Issue = {
  _id?: string;
  fingerprint: string;
  title: string;                 // first line of message or best guess
  firstSeen: Date;
  lastSeen: Date;
  level: "error" | "warn" | "info";
  count: number;
  affectedUsers: number;
  resolved: boolean;
  ignored: boolean;
  sampleEventId?: string;
  envs: Record<string, number>;  // env -> count
};

export const ErrorStore = {
  // raw
  insertRaw: (doc: RawError) => db.errors_raw.insertOne(doc),
  // issue upsert (atomic)
  upsertIssue: async (raw: RawError) => {
    const title = raw.message?.split("\n")[0]?.slice(0, 160) || raw.type || "Error";
    await db.issues.updateOne(
      { fingerprint: raw.fingerprint },
      {
        $setOnInsert: {
          fingerprint: raw.fingerprint,
          title,
          firstSeen: raw.createdAt,
          resolved: false,
          ignored: false,
          sampleEventId: raw.eventId,
          level: raw.level,
        },
        $set: { lastSeen: raw.createdAt },
        $inc: { count: 1, [`envs.${raw.env}`]: 1 },
      },
      { upsert: true }
    );
  },
  // rollup for charts: hourly buckets
  bumpRollup: async (raw: RawError) => {
    const hour = new Date(raw.createdAt);
    hour.setMinutes(0,0,0);
    await db.issue_events.updateOne(
      { fingerprint: raw.fingerprint, hour },
      { $inc: { count: 1 } },
      { upsert: true }
    );
  },
  listIssues: async ({ q, level, env, resolved, page, limit }: any) => {
    const f: any = {};
    if (q) f.$text = { $search: q };
    if (level) f.level = level;
    if (env) f[`envs.${env}`] = { $gt: 0 };
    if (resolved !== undefined) f.resolved = resolved;

    const cursor = db.issues.find(f).sort({ lastSeen: -1 }).skip((page-1)*limit).limit(limit);
    const [items, total] = await Promise.all([cursor.toArray(), db.issues.countDocuments(f)]);
    return { items, total, page, limit };
  },
  getIssue: (fingerprint: string) => db.issues.findOne({ fingerprint }),
  getRawForIssue: (fingerprint: string, limit=50) =>
    db.errors_raw.find({ fingerprint }).sort({ createdAt: -1 }).limit(limit).toArray(),
  setResolved: (fingerprint: string, resolved: boolean) =>
    db.issues.updateOne({ fingerprint }, { $set: { resolved } }),
  setIgnored: (fingerprint: string, ignored: boolean) =>
    db.issues.updateOne({ fingerprint }, { $set: { ignored } }),
  chartByHour: async ({ from, to, env }: {from: Date; to: Date; env?: string}) => {
    const match: any = { hour: { $gte: from, $lte: to } };
    if (env) match.env = env; // if you store env in rollup doc
    return db.issue_events.find(match).sort({ hour: 1 }).toArray();
  }
};
Indexes to add:

errors_raw: { createdAt: -1 }, { fingerprint: 1 }

issues: { lastSeen: -1 }, { resolved: 1 }, text index on title

issue_events: { hour: 1, fingerprint: 1 }

1.2 Server ingest + grouping + sanitization
File: server/routes/observability.ts

ts
Copy
Edit
import { z } from "zod";
import { v4 as uuid } from "uuid";
import { ErrorStore } from "../data/errorStore";

// normalize/strip noise from stacks for grouping
function normalizeStack(raw?: string): string[] {
  if (!raw) return [];
  return raw
    .split("\n")
    .map(l => l.trim())
    .filter(l => l && !l.includes("node_modules") && !l.includes("(internal"))
    .map(l => l.replace(/\(\w+:\/\/.*?\)/g, "()").replace(/:\d+:\d+/g, ":__:__"));
}

// fingerprint = hash(message + top frame + url + type)
function fingerprintOf(p: { message?: string; stack?: string[]; url?: string; type?: string; service: string }) {
  const top = p.stack?.[0] ?? "";
  const basis = [p.service, p.type ?? "", p.message ?? "", top, p.url ?? ""].join("|").slice(0, 2048);
  // trivial deterministic hash
  let h = 0; for (let i=0;i<basis.length;i++) h = (h*31 + basis.charCodeAt(i))|0;
  return `${p.service}:${Math.abs(h)}`;
}

const IngestSchema = z.object({
  service: z.enum(["client","server"]),
  level: z.enum(["error","warn","info"]).default("error"),
  env: z.enum(["development","production"]).default(process.env.NODE_ENV === "production" ? "production":"development"),
  release: z.string().optional(),
  url: z.string().optional(),
  method: z.string().optional(),
  statusCode: z.number().optional(),
  message: z.string().min(1),
  type: z.string().optional(),
  stack: z.string().optional(),
  user: z.object({ id: z.string().optional() }).optional(),
  tags: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])).optional(),
  extra: z.record(z.string(), z.any()).optional(),
}).strict();

app.post("/api/observability/errors", async (req, res) => {
  const parsed = IngestSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });

  // rate-limit per IP to avoid floods (very simple)
  // (hook in your real limiter if you have one)
  // if (tooMany(req.ip)) return res.status(429).end();

  const now = new Date();
  const stack = normalizeStack(parsed.data.stack);
  const fingerprint = fingerprintOf({ ...parsed.data, stack });

  const raw = {
    eventId: uuid(),
    createdAt: now,
    ...parsed.data,
    stack,
    fingerprint,
  };

  await Promise.all([
    ErrorStore.insertRaw(raw),
    ErrorStore.upsertIssue(raw),
    ErrorStore.bumpRollup(raw),
  ]);

  res.status(201).json({ ok: true, eventId: raw.eventId, fingerprint });
});

// Admin API
app.get("/api/observability/issues", async (req, res) => {
  const q = String(req.query.q ?? "");
  const level = req.query.level as any;
  const env = req.query.env as any;
  const resolved = req.query.resolved !== undefined ? req.query.resolved === "true" : undefined;
  const page = Number(req.query.page ?? 1);
  const limit = Math.min(Number(req.query.limit ?? 20), 100);
  const result = await ErrorStore.listIssues({ q, level, env, resolved, page, limit });
  res.json(result);
});

app.get("/api/observability/issues/:fp", async (req, res) => {
  const [issue, events] = await Promise.all([
    ErrorStore.getIssue(req.params.fp),
    ErrorStore.getRawForIssue(req.params.fp, 50),
  ]);
  res.json({ issue, events });
});

app.put("/api/observability/issues/:fp/resolve", async (req, res) => {
  await ErrorStore.setResolved(req.params.fp, true);
  res.json({ ok: true });
});

app.put("/api/observability/issues/:fp/reopen", async (req, res) => {
  await ErrorStore.setResolved(req.params.fp, false);
  res.json({ ok: true });
});

app.put("/api/observability/issues/:fp/ignore", async (req, res) => {
  await ErrorStore.setIgnored(req.params.fp, true);
  res.json({ ok: true });
});

// chart: last 24h / 7d etc.
app.get("/api/observability/series", async (req, res) => {
  const now = new Date();
  const days = Number(req.query.days ?? 1);
  const from = new Date(now.getTime() - days*24*3600*1000);
  const rows = await ErrorStore.chartByHour({ from, to: now });
  res.json(rows);
});
Important: Mount ingest after your fixed sanitizer from earlier messages; or add /api/observability/errors to its allowlist, since we already validate & sanitize here.

1.3 Server capture middleware (uncaught errors)
File: server/middleware/capture.ts

ts
Copy
Edit
import { v4 as uuid } from "uuid";

export function requestId(req, res, next) {
  req.requestId = req.headers["x-request-id"] || uuid();
  res.setHeader("X-Request-Id", req.requestId);
  next();
}

export function captureErrors(err, req, res, next) {
  // ship to local ingest
  fetch("http://localhost:" + process.env.PORT + "/api/observability/errors", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      service: "server",
      level: "error",
      env: process.env.NODE_ENV === "production" ? "production" : "development",
      release: process.env.APP_RELEASE,
      url: req.originalUrl,
      method: req.method,
      statusCode: res.statusCode,
      message: err.message || "Server error",
      type: err.name,
      stack: err.stack,
      user: req.userId ? { id: String(req.userId) } : undefined,
      tags: { requestId: req.requestId },
    }),
  }).catch(()=>{ /* avoid crash on self-failure */ });

  res.status(500).json({ error: "Server error", requestId: req.requestId });
}
Mount order:

ts
Copy
Edit
app.use(requestId);
// ...routes...
app.use(captureErrors); // last
1.4 Client capture (React + global)
File: src/lib/err.ts

ts
Copy
Edit
export function reportClientError(payload: {
  level?: "error" | "warn" | "info";
  message: string;
  type?: string;
  stack?: string;
  extra?: Record<string, any>;
}) {
  try {
    fetch("/api/observability/errors", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        service: "client",
        level: payload.level ?? "error",
        env: import.meta.env.MODE === "production" ? "production" : "development",
        release: import.meta.env.VITE_APP_RELEASE,
        url: window.location.pathname + window.location.search,
        message: payload.message,
        type: payload.type,
        stack: payload.stack,
        user: window.__CF_USER ? { id: window.__CF_USER.id } : undefined,
        tags: { ua: navigator.userAgent },
        extra: payload.extra,
      }),
      keepalive: true, // allow during page unload
    });
  } catch {}
}

export function installGlobalErrorHandlers() {
  window.addEventListener("error", (e) => {
    reportClientError({
      message: e.message ?? "Unhandled error",
      type: (e.error && e.error.name) || "Error",
      stack: (e.error && e.error.stack) || undefined,
      extra: { filename: e.filename, lineno: e.lineno, colno: e.colno },
    });
  });
  window.addEventListener("unhandledrejection", (e) => {
    const reason: any = e.reason || {};
    reportClientError({
      message: String(reason.message || e.reason || "Unhandled rejection"),
      type: reason.name || "UnhandledRejection",
      stack: reason.stack,
    });
  });
}
React boundary wrapper

tsx
Copy
Edit
// src/components/Boundary.tsx
import React from "react";
import { reportClientError } from "@/lib/err";

export class ErrorBoundary extends React.Component<{children: React.ReactNode}, {hasError: boolean}> {
  state = { hasError: false };
  static getDerivedStateFromError() { return { hasError: true }; }
  componentDidCatch(error: any, info: any) {
    reportClientError({ message: error?.message ?? "Render error", type: error?.name, stack: error?.stack, extra: { info } });
  }
  render() { return this.state.hasError ? <div>Something went wrong.</div> : this.props.children; }
}
Use once in app root

tsx
Copy
Edit
// src/main.tsx
import { installGlobalErrorHandlers } from "@/lib/err";
installGlobalErrorHandlers();

root.render(
  <ErrorBoundary>
    <App />
  </ErrorBoundary>
);
1.5 Admin “Error Dashboard” (replace tab)
Endpoints already provided above. Now wire UI:

File: src/api/observability.ts

ts
Copy
Edit
export const obsApi = {
  issues: async (params: { q?: string; level?: string; env?: string; resolved?: boolean; page?: number; limit?: number } = {}) => {
    const u = new URLSearchParams(Object.entries(params).filter(([,v]) => v !== undefined) as any);
    const r = await fetch(`/api/observability/issues?${u}`, { credentials: "include" });
    if (!r.ok) throw new Error(await r.text());
    return r.json();
  },
  issue: async (fp: string) => (await fetch(`/api/observability/issues/${fp}`, { credentials: "include" })).json(),
  resolve: async (fp: string) => (await fetch(`/api/observability/issues/${fp}/resolve`, { method: "PUT", credentials: "include" })).json(),
  reopen: async (fp: string) => (await fetch(`/api/observability/issues/${fp}/reopen`, { method: "PUT", credentials: "include" })).json(),
  ignore: async (fp: string) => (await fetch(`/api/observability/issues/${fp}/ignore`, { method: "PUT", credentials: "include" })).json(),
  series: async (days=1) => (await fetch(`/api/observability/series?days=${days}`, { credentials: "include" })).json(),
};
Page: src/pages/admin/error-logs/index.tsx

Replace old code with:

Search + filters (level, env, unresolved)

Table of issues (title, lastSeen, count, envs, status)

On click → drawer with last 50 events (message, stack preview, URL, user, tags)

Chart (errors/hour) from /series?days=1|7|30

Actions: Resolve / Reopen / Ignore (call obsApi).

Delete: all previous error-log reducers, routes, and UI.

Retention job (optional): nightly delete errors_raw older than 30–90 days, keep issues and rollups.

2) Product Creator – Category not saving (quick recap)
(If you haven’t already applied)

Save categoryId only (server validation & client fix above).

Admin list and shop list should JOIN/lookup category details by categoryId (don’t store category name redundantly).

3) Equipment Submissions – stuck loading
Implement /api/submissions with pagination + indexes (see section 2 earlier).

Use useQuery(["submissions", q, status, page]) with keepPreviousData and render empty-state if items.length===0.

Add a server timeout guard; avoid giant unindexed scans.

4) System Analytics – make it work & be useful
Server health endpoint

ts
Copy
Edit
app.get("/api/system/health", async (_req, res) => {
  const start = process.hrtime.bigint();
  const dbPing = await db.admin().ping().catch(() => null);
  const dbOk = !!dbPing;
  const uptime = process.uptime();
  const mem = process.memoryUsage(); // rss, heapUsed
  const cpu = process.cpuUsage();    // user/system microseconds
  const latencyMs = Number((process.hrtime.bigint() - start) / 1000000n);

  res.json({
    status: dbOk ? "ok" : "degraded",
    uptime,
    latencyMs,
    memoryMB: Math.round(mem.rss / 1024 / 1024),
    heapMB: Math.round(mem.heapUsed / 1024 / 1024),
    cpuUserMs: Math.round(cpu.user/1000),
    cpuSystemMs: Math.round(cpu.system/1000),
    time: new Date().toISOString(),
  });
});
Client (admin/system tab)

Poll /api/system/health every 10–15s with useQuery({ refetchInterval: 15000 }).

Render:

Status card (OK/Degraded)

Uptime (format hh:mm)

Memory (MB), Heap (MB)

API latency

Replace “Database/Error/Memory” fake panels with this real data.

5) Clean-up & Guardrails
Delete all legacy error tracking files (search “error log”, “scan codebase”, “codebase doctor”) and remove their routes.

ESLint rule to prevent ad-hoc error posts:

js
Copy
Edit
// .eslintrc
"no-restricted-syntax": [
  "error",
  { selector: "CallExpression[callee.name='fetch'][arguments.0.value=/\\/api\\/error-log/]", message: "Use /api/observability/errors only." }
]
Add unit tests for fingerprintOf, normalizeStack, and IngestSchema.

Add seed data script for the error UI (optional dev convenience).

Acceptance checklist (Replit should verify)
 No old error logging code remains in the repo.

 Client & server errors show up on the new Error Dashboard within seconds.

 Issues group correctly: repeated same error increments count, not new rows.

 “Resolve/Ignore” toggle works and persists.

 Category saves by ID and reflects in lists.

 Submissions page loads, paginates, and searches.

 System tab shows live metrics (uptime, mem, latency).

 rg -n "error-log|sentry|scan codebase|codebase doctor" returns 0 relevant matches.

tailor the schemas to our exact DB (Postgres)/wire the Admin UI