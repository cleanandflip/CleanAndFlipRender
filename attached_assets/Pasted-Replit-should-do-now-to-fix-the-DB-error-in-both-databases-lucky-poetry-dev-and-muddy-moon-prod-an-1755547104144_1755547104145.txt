Replit should do now to fix the DB error in both databases (lucky-poetry dev and muddy-moon prod) and stop the /health 401s.

What’s broken (from your logs)

NeonDbError: column "continue_selling_when_out_of_stock" does not exist
→ The products table is missing the boolean column your code expects. This breaks /api/products and featured-products queries.

/health and /api/admin/system/health return 401
→ Health endpoints are behind auth or mounted after an auth gate.

We’ll fix the column in both DBs (dev + prod) and expose a public health endpoint.

✅ Do this now (Replit step-by-step)
Step 1 — Add a one-shot dual-DB migration script

Create scripts/fix-products-column.ts:

/* Run with: npx tsx scripts/fix-products-column.ts */
import 'dotenv/config';
import { Client } from 'pg';

const DEV = process.env.DEV_DATABASE_URL!;
const PROD = process.env.PROD_DATABASE_URL!;

if (!DEV || !PROD) {
  console.error('❌ Missing DEV_DATABASE_URL or PROD_DATABASE_URL in env.');
  process.exit(1);
}

const SQL = `
BEGIN;
ALTER TABLE public.products
  ADD COLUMN IF NOT EXISTS continue_selling_when_out_of_stock boolean NOT NULL DEFAULT false;
COMMENT ON COLUMN public.products.continue_selling_when_out_of_stock IS 'Allow purchases when inventory <= 0';
-- optional: tiny helper index for admin filters
CREATE INDEX IF NOT EXISTS idx_products_continue_selling ON public.products (continue_selling_when_out_of_stock);
COMMIT;`;

async function run(name: string, url: string) {
  const c = new Client({ connectionString: url, ssl: { rejectUnauthorized: false } });
  await c.connect();
  try {
    process.stdout.write(`\n[${name}] Applying migration… `);
    await c.query(SQL);
    console.log('OK');

    const v = await c.query(`
      SELECT column_name, data_type, is_nullable, column_default
      FROM information_schema.columns
      WHERE table_schema='public' AND table_name='products' AND column_name='continue_selling_when_out_of_stock'
      LIMIT 1;
    `);
    console.log(`[${name}] Column:`, v.rows[0] || '(missing)');
  } finally {
    await c.end();
  }
}

(async () => {
  await run('DEV (lucky-poetry)', DEV);
  await run('PROD (muddy-moon)', PROD);
  console.log('\n✅ Done. Both databases have the column.');
})().catch(e => {
  console.error('\n❌ Migration failed:', e?.message || e);
  process.exit(1);
});


Run it:

npx tsx scripts/fix-products-column.ts


This safely adds the column with a default (false) and is idempotent.

Step 2 — Make /health public (no auth)

Mount a public health endpoint before any auth-required middleware. If you already have /api/healthz, also add simple aliases so your monitors stop 401’ing.

/** src/routes/health.ts (or similar) **/

import { Router } from 'express';
import { pool } from '../db/pool';
import { APP_ENV, DB_HOST } from '../config/env';

export const health = Router();

health.get('/api/healthz', async (_req, res) => {
  const r = await pool.query(`select current_database() as db, current_user as role`);
  res.json({ env: APP_ENV, dbHost: DB_HOST, database: r.rows[0]?.db, role: r.rows[0]?.role });
});

// Back-compat aliases (public)
health.get('/health', (_req, res) => res.redirect(307, '/api/healthz'));
health.get('/api/admin/system/health', (_req, res) => res.redirect(307, '/api/healthz'));


Mount this router before any auth/session gate:

app.use(health);              // <— place early
// …then sessions, auth, and the rest

Step 3 — Add a runtime safety net (non-destructive)

To prevent this exact 500 from ever happening again if someone deploys before running the migration, add a non-destructive verifier that runs on boot and logs loudly if the column is missing (it can also auto-add in dev; in prod we’ll just log).

import { pool } from '../db/pool';
import { APP_ENV } from '../config/env';

export async function verifyProductSchema() {
  const q = `
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema='public'
      AND table_name='products'
      AND column_name='continue_selling_when_out_of_stock'`;
  const r = await pool.query(q);
  if (r.rowCount) {
    console.log('✅ products.continue_selling_when_out_of_stock present');
    return;
  }

  const msg = '❌ products.continue_selling_when_out_of_stock is missing!';
  if (APP_ENV !== 'production') {
    console.warn(msg, 'Auto-adding in non-prod…');
    await pool.query(`
      ALTER TABLE public.products
      ADD COLUMN IF NOT EXISTS continue_selling_when_out_of_stock boolean NOT NULL DEFAULT false;
    `);
    console.log('✅ Added column in non-prod');
  } else {
    console.error(msg, 'Run: npx tsx scripts/fix-products-column.ts');
  }
}


Call await verifyProductSchema() during boot before the app starts serving requests.

Step 4 — Defensive read in code (no more 500s during deploys)

Until every environment is migrated, read the column defensively. With SQL:

SELECT
  p.id, p.title, p.price,
  COALESCE(p.continue_selling_when_out_of_stock, false) AS continue_selling_when_out_of_stock
FROM products p
…


With Drizzle (neon-http) you can add a fallback at the mapping layer (or define the column as optional boolean with a default in your schema model). The key is to COALESCE to false so queries never explode if the column isn’t there yet.

Step 5 — Quick verification for both databases

Run this helper to confirm the column exists in both DBs after the migration.

Create scripts/verify-products-column.ts:

/* Run with: npx tsx scripts/verify-products-column.ts */
import 'dotenv/config';
import { Client } from 'pg';

async function check(name: string, url: string) {
  const c = new Client({ connectionString: url, ssl: { rejectUnauthorized: false } });
  await c.connect();
  try {
    const r = await c.query(`
      SELECT column_name, data_type, is_nullable, column_default
      FROM information_schema.columns
      WHERE table_schema='public' AND table_name='products' AND column_name='continue_selling_when_out_of_stock'
    `);
    console.log(`\n[${name}]`, r.rows[0] || '(missing)');
  } finally { await c.end(); }
}

(async () => {
  await check('DEV (lucky-poetry)', process.env.DEV_DATABASE_URL!);
  await check('PROD (muddy-moon)', process.env.PROD_DATABASE_URL!);
})();


Run:

npx tsx scripts/verify-products-column.ts


You should see the column with boolean, NO, and a DEFAULT false.

Acceptance tests (must pass)

/health, /api/admin/system/health, and /api/healthz all return 200 (JSON), no auth required.

/api/products returns 200 and includes continue_selling_when_out_of_stock in each product (boolean).

The migration script reports OK for both:

DEV (lucky-poetry): updated

PROD (muddy-moon): updated

Boot logs show ✅ products.continue_selling_when_out_of_stock present.

Notes

The migration is additive (safe): ADD COLUMN IF NOT EXISTS with default false. No data loss; no table rewrites beyond adding the column.

Keep schema changes out of normal boot where possible; use the one-shot script. The small runtime verifier remains as a seatbelt.

If your ORM schema file doesn’t yet include this column, add it now (optional boolean with default false) so type-level access is clean.