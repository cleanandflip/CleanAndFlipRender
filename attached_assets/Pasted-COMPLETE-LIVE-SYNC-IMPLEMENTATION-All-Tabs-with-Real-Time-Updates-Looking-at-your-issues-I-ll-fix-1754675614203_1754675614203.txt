COMPLETE LIVE-SYNC IMPLEMENTATION: All Tabs with Real-Time Updates
Looking at your issues, I'll fix the WebSocket connection, implement live-sync for EVERY tab, and ensure the database properly reflects the User/Developer role system.

PHASE 1: FIX DATABASE SCHEMA FOR ROLES
File 1: /db/schema.sql
sql-- RUN THIS SQL TO UPDATE DATABASE
-- First, update existing roles
UPDATE users SET role = 'developer' WHERE role = 'admin';

-- Then alter the enum type
ALTER TYPE user_role RENAME TO user_role_old;
CREATE TYPE user_role AS ENUM ('user', 'developer');
ALTER TABLE users ALTER COLUMN role TYPE user_role USING role::text::user_role;
DROP TYPE user_role_old;
File 2: /db/schema.ts
typescript// UPDATED SCHEMA WITH ONLY 2 ROLES
import { pgTable, text, uuid, timestamp, integer, boolean, pgEnum } from 'drizzle-orm/pg-core';

// ONLY 2 ROLES NOW
export const userRoleEnum = pgEnum('user_role', ['user', 'developer']);

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  email: text('email').notNull().unique(),
  username: text('username'),
  password: text('password').notNull(),
  role: userRoleEnum('role').default('user').notNull(),
  firstName: text('first_name'),
  lastName: text('last_name'),
  phone: text('phone'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
  lastLogin: timestamp('last_login'),
  isActive: boolean('is_active').default(true).notNull()
});

PHASE 2: COMPLETE WEBSOCKET SERVER SETUP
File 3: /server/websocket.ts
typescript// ROBUST WEBSOCKET SERVER WITH HEARTBEAT
import { WebSocketServer, WebSocket } from 'ws';
import { Server } from 'http';

interface WSClient {
  ws: WebSocket;
  id: string;
  userId?: string;
  role?: string;
  isAlive: boolean;
}

class WebSocketManager {
  private wss: WebSocketServer;
  private clients: Map<string, WSClient> = new Map();
  private heartbeatInterval: NodeJS.Timeout;

  constructor(server: Server) {
    this.wss = new WebSocketServer({ 
      server, 
      path: '/ws',
      perMessageDeflate: false
    });

    this.setupWebSocket();
    this.startHeartbeat();
  }

  private setupWebSocket() {
    this.wss.on('connection', (ws: WebSocket, req: any) => {
      const clientId = this.generateId();
      
      const client: WSClient = {
        ws,
        id: clientId,
        isAlive: true
      };

      this.clients.set(clientId, client);
      console.log(`WebSocket connected: ${clientId}`);

      // Send connection confirmation
      ws.send(JSON.stringify({
        type: 'connection',
        status: 'connected',
        clientId
      }));

      // Handle pong for heartbeat
      ws.on('pong', () => {
        client.isAlive = true;
      });

      // Handle messages
      ws.on('message', (message: string) => {
        try {
          const data = JSON.parse(message.toString());
          this.handleMessage(clientId, data);
        } catch (error) {
          console.error('WebSocket message error:', error);
        }
      });

      // Handle close
      ws.on('close', () => {
        this.clients.delete(clientId);
        console.log(`WebSocket disconnected: ${clientId}`);
      });

      // Handle error
      ws.on('error', (error) => {
        console.error(`WebSocket error for ${clientId}:`, error);
      });
    });
  }

  private handleMessage(clientId: string, data: any) {
    const client = this.clients.get(clientId);
    if (!client) return;

    // Handle authentication
    if (data.type === 'auth') {
      client.userId = data.userId;
      client.role = data.role;
      return;
    }

    // Broadcast to all other clients
    this.broadcast(data, clientId);
  }

  public broadcast(data: any, excludeClientId?: string) {
    const message = JSON.stringify(data);
    
    this.clients.forEach((client, id) => {
      if (id !== excludeClientId && client.ws.readyState === WebSocket.OPEN) {
        client.ws.send(message);
      }
    });
  }

  public broadcastToRole(data: any, role: string) {
    const message = JSON.stringify(data);
    
    this.clients.forEach((client) => {
      if (client.role === role && client.ws.readyState === WebSocket.OPEN) {
        client.ws.send(message);
      }
    });
  }

  private startHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      this.clients.forEach((client, id) => {
        if (!client.isAlive) {
          client.ws.terminate();
          this.clients.delete(id);
          return;
        }
        
        client.isAlive = false;
        client.ws.ping();
      });
    }, 30000); // 30 seconds
  }

  private generateId(): string {
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
  }

  public getConnectionCount(): number {
    return this.clients.size;
  }
}

export let wsManager: WebSocketManager;

export function setupWebSocket(server: Server) {
  wsManager = new WebSocketManager(server);
  return wsManager;
}

PHASE 3: ENHANCED WEBSOCKET HOOK WITH CONNECTION STATUS
File 4: /client/src/hooks/useWebSocket.tsx
typescript// COMPLETE WEBSOCKET HOOK WITH CONNECTION STATUS
import { useEffect, useRef, useState, useCallback } from 'react';
import { toast } from './useToast';

type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error';

export function useWebSocket() {
  const ws = useRef<WebSocket | null>(null);
  const [status, setStatus] = useState<ConnectionStatus>('connecting');
  const [reconnectAttempts, setReconnectAttempts] = useState(0);
  const reconnectTimeout = useRef<NodeJS.Timeout>();
  const messageQueue = useRef<any[]>([]);

  const connect = useCallback(() => {
    if (ws.current?.readyState === WebSocket.OPEN) return;
    
    setStatus('connecting');
    
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws`;
    
    try {
      ws.current = new WebSocket(wsUrl);

      ws.current.onopen = () => {
        setStatus('connected');
        setReconnectAttempts(0);
        console.log('✅ WebSocket connected');
        
        // Send authentication
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        if (user.id) {
          ws.current?.send(JSON.stringify({
            type: 'auth',
            userId: user.id,
            role: user.role
          }));
        }
        
        // Send queued messages
        while (messageQueue.current.length > 0) {
          const msg = messageQueue.current.shift();
          ws.current?.send(JSON.stringify(msg));
        }
      };

      ws.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleMessage(data);
        } catch (error) {
          console.error('WebSocket message parse error:', error);
        }
      };

      ws.current.onclose = (event) => {
        setStatus('disconnected');
        console.log('❌ WebSocket disconnected:', event.code, event.reason);
        
        // Auto-reconnect with exponential backoff
        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
        setReconnectAttempts(prev => prev + 1);
        
        reconnectTimeout.current = setTimeout(() => {
          console.log(`Reconnecting... (attempt ${reconnectAttempts + 1})`);
          connect();
        }, delay);
      };

      ws.current.onerror = (error) => {
        setStatus('error');
        console.error('WebSocket error:', error);
      };
      
    } catch (error) {
      setStatus('error');
      console.error('WebSocket connection failed:', error);
    }
  }, [reconnectAttempts]);

  const handleMessage = (data: any) => {
    console.log('📨 WebSocket message:', data);
    
    // Handle different message types
    switch (data.type) {
      case 'connection':
        if (data.status === 'connected') {
          toast.success('Real-time sync active', { duration: 2000 });
        }
        break;
        
      case 'product_update':
        window.dispatchEvent(new CustomEvent('refresh_products', { detail: data }));
        if (data.action !== 'self') {
          toast.info('Products updated', { duration: 2000 });
        }
        break;
        
      case 'category_update':
        window.dispatchEvent(new CustomEvent('refresh_categories', { detail: data }));
        if (data.action !== 'self') {
          toast.info('Categories updated', { duration: 2000 });
        }
        break;
        
      case 'user_update':
        window.dispatchEvent(new CustomEvent('refresh_users', { detail: data }));
        if (data.action !== 'self') {
          toast.info('Users updated', { duration: 2000 });
        }
        break;
        
      case 'submission_update':
        window.dispatchEvent(new CustomEvent('refresh_submissions', { detail: data }));
        break;
        
      case 'wishlist_update':
        window.dispatchEvent(new CustomEvent('refresh_wishlist', { detail: data }));
        break;
        
      case 'order_update':
        window.dispatchEvent(new CustomEvent('refresh_orders', { detail: data }));
        break;
        
      case 'stripe_sync_complete':
        window.dispatchEvent(new CustomEvent('refresh_stripe', { detail: data }));
        toast.success('Stripe sync completed');
        break;
        
      default:
        console.log('Unknown message type:', data.type);
    }
  };

  const send = useCallback((data: any) => {
    const message = typeof data === 'string' ? data : JSON.stringify(data);
    
    if (ws.current?.readyState === WebSocket.OPEN) {
      ws.current.send(message);
    } else {
      // Queue message if not connected
      messageQueue.current.push(data);
      // Try to reconnect
      if (status === 'disconnected') {
        connect();
      }
    }
  }, [status, connect]);

  useEffect(() => {
    connect();

    return () => {
      if (reconnectTimeout.current) {
        clearTimeout(reconnectTimeout.current);
      }
      if (ws.current) {
        ws.current.close();
      }
    };
  }, [connect]);

  return { 
    send, 
    status,
    isConnected: status === 'connected',
    reconnectAttempts 
  };
}

PHASE 4: USER MANAGEMENT TAB WITH LIVE SYNC
File 5: /client/src/pages/admin/UsersTab.tsx
typescript// USER MANAGEMENT WITH COMPLETE LIVE SYNC
import { useState, useEffect } from 'react';
import { Users, Plus, RefreshCw, Circle, Download } from 'lucide-react';
import { UnifiedMetricCard } from '@/components/admin/UnifiedMetricCard';
import { UserModal } from '@/components/admin/modals/UserModal';
import { useWebSocket } from '@/hooks/useWebSocket';
import { toast } from '@/hooks/useToast';

export function UsersTab() {
  const [users, setUsers] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [selectedUser, setSelectedUser] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const { send, status, isConnected } = useWebSocket();

  // Fetch users
  const fetchUsers = async () => {
    setLoading(true);
    try {
      const res = await fetch('/api/admin/users', { credentials: 'include' });
      const data = await res.json();
      setUsers(data.users || []);
    } catch (error) {
      console.error('Failed to fetch users:', error);
      toast.error('Failed to load users');
    } finally {
      setLoading(false);
    }
  };

  // Setup live sync
  useEffect(() => {
    fetchUsers();
    
    // Listen for live updates
    const handleRefresh = (event: CustomEvent) => {
      console.log('Refreshing users due to:', event.detail);
      fetchUsers();
    };
    
    window.addEventListener('refresh_users', handleRefresh as any);
    return () => window.removeEventListener('refresh_users', handleRefresh as any);
  }, []);

  // Handle user actions
  const handleEditUser = (user: any) => {
    setSelectedUser(user);
    setIsModalOpen(true);
  };

  const handleDeleteUser = async (user: any) => {
    if (!confirm(`Delete user "${user.email}"?`)) return;
    
    try {
      const res = await fetch(`/api/admin/users/${user.id}`, {
        method: 'DELETE',
        credentials: 'include'
      });
      
      if (res.ok) {
        toast.success('User deleted');
        
        // Broadcast update
        send({
          type: 'user_update',
          action: 'delete',
          userId: user.id,
          timestamp: new Date().toISOString()
        });
        
        fetchUsers();
      }
    } catch (error) {
      toast.error('Failed to delete user');
    }
  };

  const handleToggleStatus = async (user: any) => {
    try {
      const res = await fetch(`/api/admin/users/${user.id}/toggle-status`, {
        method: 'POST',
        credentials: 'include'
      });
      
      if (res.ok) {
        toast.success(`User ${user.isActive ? 'deactivated' : 'activated'}`);
        
        // Broadcast update
        send({
          type: 'user_update',
          action: 'status_change',
          userId: user.id,
          timestamp: new Date().toISOString()
        });
        
        fetchUsers();
      }
    } catch (error) {
      toast.error('Failed to update user status');
    }
  };

  const handleSaveUser = () => {
    setIsModalOpen(false);
    setSelectedUser(null);
    
    // Broadcast update
    send({
      type: 'user_update',
      action: selectedUser ? 'update' : 'create',
      timestamp: new Date().toISOString()
    });
    
    fetchUsers();
  };

  // Stats
  const stats = {
    total: users.length,
    active: users.filter(u => u.isActive).length,
    developers: users.filter(u => u.role === 'developer').length,
    newThisMonth: users.filter(u => {
      const created = new Date(u.createdAt);
      const now = new Date();
      return created.getMonth() === now.getMonth() && created.getFullYear() === now.getFullYear();
    }).length
  };

  return (
    <div className="space-y-6">
      {/* Connection Status */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Circle className={`w-3 h-3 ${
            isConnected ? 'text-green-400 fill-current' : 'text-red-400'
          }`} />
          <span className={`text-sm ${
            isConnected ? 'text-green-400' : 'text-red-400'
          }`}>
            {isConnected ? 'Live Sync Active' : 'Offline - Changes won\'t sync'}
          </span>
        </div>
      </div>

      {/* Metrics */}
      <div className="grid grid-cols-4 gap-4">
        <UnifiedMetricCard
          title="Total Users"
          value={stats.total}
          icon={Users}
          change={{ value: 12, label: 'from last month' }}
        />
        <UnifiedMetricCard
          title="Active Users"
          value={stats.active}
          icon={Users}
          change={{ value: 8, label: 'from last month' }}
        />
        <UnifiedMetricCard
          title="Developers"
          value={stats.developers}
          icon={Users}
          change={{ value: 0, label: 'from last month' }}
        />
        <UnifiedMetricCard
          title="New This Month"
          value={stats.newThisMonth}
          icon={Users}
          change={{ value: 25, label: 'from last month' }}
        />
      </div>

      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-xl font-bold text-white">User Management</h2>
          <p className="text-gray-400">Manage user accounts and permissions</p>
        </div>
        <div className="flex gap-2">
          <button
            onClick={fetchUsers}
            disabled={loading}
            className="px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg flex items-center gap-2"
          >
            <RefreshCw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
            Refresh
          </button>
          <button
            onClick={() => {
              setSelectedUser(null);
              setIsModalOpen(true);
            }}
            className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg flex items-center gap-2"
          >
            <Plus className="w-4 h-4" />
            Add User
          </button>
        </div>
      </div>

      {/* Users Table */}
      <div className="bg-[#1e293b]/50 border border-gray-800 rounded-xl overflow-hidden">
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead>
              <tr className="border-b border-gray-800">
                <th className="p-4 text-left text-xs text-gray-400 uppercase">User</th>
                <th className="p-4 text-left text-xs text-gray-400 uppercase">Role</th>
                <th className="p-4 text-left text-xs text-gray-400 uppercase">Status</th>
                <th className="p-4 text-left text-xs text-gray-400 uppercase">Joined</th>
                <th className="p-4 text-left text-xs text-gray-400 uppercase">Last Login</th>
                <th className="p-4 text-right text-xs text-gray-400 uppercase">Actions</th>
              </tr>
            </thead>
            <tbody>
              {users.map(user => (
                <tr key={user.id} className="border-b border-gray-800/50 hover:bg-white/5">
                  <td className="p-4">
                    <div>
                      <div className="text-white font-medium">{user.username || user.email}</div>
                      <div className="text-xs text-gray-500">{user.email}</div>
                    </div>
                  </td>
                  <td className="p-4">
                    <span className={`px-2 py-1 rounded text-xs font-medium ${
                      user.role === 'developer' 
                        ? 'bg-purple-500/20 text-purple-400' 
                        : 'bg-blue-500/20 text-blue-400'
                    }`}>
                      {user.role}
                    </span>
                  </td>
                  <td className="p-4">
                    <button
                      onClick={() => handleToggleStatus(user)}
                      className={`px-2 py-1 rounded text-xs font-medium cursor-pointer ${
                        user.isActive 
                          ? 'bg-green-500/20 text-green-400' 
                          : 'bg-red-500/20 text-red-400'
                      }`}
                    >
                      {user.isActive ? 'Active' : 'Inactive'}
                    </button>
                  </td>
                  <td className="p-4 text-gray-300">
                    {new Date(user.createdAt).toLocaleDateString()}
                  </td>
                  <td className="p-4 text-gray-300">
                    {user.lastLogin ? new Date(user.lastLogin).toLocaleDateString() : 'Never'}
                  </td>
                  <td className="p-4">
                    <div className="flex justify-end gap-2">
                      <button
                        onClick={() => handleEditUser(user)}
                        className="px-3 py-1 bg-white/10 hover:bg-white/20 text-white rounded text-sm"
                      >
                        Edit
                      </button>
                      <button
                        onClick={() => handleDeleteUser(user)}
                        className="px-3 py-1 bg-red-500/20 hover:bg-red-500/30 text-red-400 rounded text-sm"
                      >
                        Delete
                      </button>
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* User Modal */}
      <UserModal
        user={selectedUser}
        isOpen={isModalOpen}
        onClose={() => {
          setIsModalOpen(false);
          setSelectedUser(null);
        }}
        onSave={handleSaveUser}
      />
    </div>
  );
}

PHASE 5: BACKEND BROADCAST FOR ALL OPERATIONS
File 6: /server/routes/admin.ts
typescript// BACKEND ROUTES WITH WEBSOCKET BROADCAST
import { Router } from 'express';
import { db } from '@/db';
import { users, products, categories, orders } from '@/db/schema';
import { wsManager } from '../websocket';
import { eq } from 'drizzle-orm';

const router = Router();

// PRODUCTS - with broadcast
router.post('/api/admin/products', async (req, res) => {
  try {
    const [product] = await db.insert(products).values(req.body).returning();
    
    // Broadcast update
    wsManager?.broadcast({
      type: 'product_update',
      action: 'create',
      productId: product.id,
      timestamp: new Date().toISOString()
    });
    
    res.json({ success: true, product });
  } catch (error) {
    res.status(500).json({ error: 'Failed to create product' });
  }
});

router.put('/api/admin/products/:id', async (req, res) => {
  try {
    const [product] = await db
      .update(products)
      .set(req.body)
      .where(eq(products.id, req.params.id))
      .returning();
    
    // Broadcast update
    wsManager?.broadcast({
      type: 'product_update',
      action: 'update',
      productId: req.params.id,
      timestamp: new Date().toISOString()
    });
    
    res.json({ success: true, product });
  } catch (error) {
    res.status(500).json({ error: 'Failed to update product' });
  }
});

// USERS - with broadcast
router.get('/api/admin/users', async (req, res) => {
  try {
    const allUsers = await db
      .select()
      .from(users)
      .orderBy(users.createdAt);
    
    res.json({ users: allUsers });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

router.post('/api/admin/users', async (req, res) => {
  try {
    const [user] = await db.insert(users).values(req.body).returning();
    
    // Broadcast update
    wsManager?.broadcast({
      type: 'user_update',
      action: 'create',
      userId: user.id,
      timestamp: new Date().toISOString()
    });
    
    res.json({ success: true, user });
  } catch (error) {
    res.status(500).json({ error: 'Failed to create user' });
  }
});

router.put('/api/admin/users/:id', async (req, res) => {
  try {
    const [user] = await db
      .update(users)
      .set(req.body)
      .where(eq(users.id, req.params.id))
      .returning();
    
    // Broadcast update
    wsManager?.broadcast({
      type: 'user_update',
      action: 'update',
      userId: req.params.id,
      timestamp: new Date().toISOString()
    });
    
    res.json({ success: true, user });
  } catch (error) {
    res.status(500).json({ error: 'Failed to update user' });
  }
});

router.delete('/api/admin/users/:id', async (req, res) => {
  try {
    await db.delete(users).where(eq(users.id, req.params.id));
    
    // Broadcast update
    wsManager?.broadcast({
      type: 'user_update',
      action: 'delete',
      userId: req.params.id,
      timestamp: new Date().toISOString()
    });
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Failed to delete user' });
  }
});

router.post('/api/admin/users/:id/toggle-status', async (req, res) => {
  try {
    const [user] = await db
      .select()
      .from(users)
      .where(eq(users.id, req.params.id));
    
    const [updated] = await db
      .update(users)
      .set({ isActive: !user.isActive })
      .where(eq(users.id, req.params.id))
      .returning();
    
    // Broadcast update
    wsManager?.broadcast({
      type: 'user_update',
      action: 'status_change',
      userId: req.params.id,
      timestamp: new Date().toISOString()
    });
    
    res.json({ success: true, user: updated });
  } catch (error) {
    res.status(500).json({ error: 'Failed to toggle user status' });
  }
});

// CATEGORIES - with broadcast
router.put('/api/admin/categories/:id', async (req, res) => {
  try {
    const [category] = await db
      .update(categories)
      .set(req.body)
      .where(eq(categories.id, req.params.id))
      .returning();
    
    // Broadcast update
    wsManager?.broadcast({
      type: 'category_update',
      action: 'update',
      categoryId: req.params.id,
      timestamp: new Date().toISOString()
    });
    
    res.json({ success: true, category });
  } catch (error) {
    res.status(500).json({ error: 'Failed to update category' });
  }
});

export default router;

PHASE 6: MAIN SERVER FILE UPDATE
File 7: /server/index.ts
typescript// MAIN SERVER WITH WEBSOCKET
import express from 'express';
import { createServer } from 'http';
import { setupWebSocket } from './websocket';
import adminRoutes from './routes/admin';

const app = express();
const server = createServer(app);

// Setup WebSocket
setupWebSocket(server);

// Middleware
app.use(express.json());

// Routes
app.use(adminRoutes);

// Start server
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`WebSocket server ready at ws://localhost:${PORT}/ws`);
});

PHASE 7: ADD LIVE SYNC TO ALL OTHER TABS
File 8: /client/src/pages/admin/ProductsTab.tsx
typescript// Add to existing ProductsTab
useEffect(() => {
  fetchProducts();
  
  const handleRefresh = () => fetchProducts();
  window.addEventListener('refresh_products', handleRefresh);
  return () => window.removeEventListener('refresh_products', handleRefresh);
}, []);
File 9: /client/src/pages/admin/CategoriesTab.tsx
typescript// Add to existing CategoriesTab
useEffect(() => {
  fetchCategories();
  
  const handleRefresh = () => fetchCategories();
  window.addEventListener('refresh_categories', handleRefresh);
  return () => window.removeEventListener('refresh_categories', handleRefresh);
}, []);

INSTRUCTIONS FOR REPLIT:
markdown## REPLIT IMPLEMENTATION STEPS:

### 1. UPDATE DATABASE SCHEMA
- Run the SQL migration to update roles to only 'user' and 'developer'
- Update schema.ts file with new role enum

### 2. INSTALL WEBSOCKET DEPENDENCIES
```bash
npm install ws @types/ws
3. UPDATE SERVER SETUP

Replace server/index.ts with WebSocket-enabled version
Add websocket.ts file with complete WebSocket manager
Update all admin routes to broadcast changes

4. UPDATE FRONTEND HOOKS

Replace useWebSocket hook with enhanced version
Add connection status tracking

5. UPDATE ALL ADMIN TABS

Add WebSocket listener to ProductsTab
Add WebSocket listener to CategoriesTab
Add WebSocket listener to UsersTab (with connection status)
Add WebSocket listener to SubmissionsTab
Add WebSocket listener to WishlistTab
Add WebSocket listener to OrdersTab

6. TEST LIVE SYNC

Open admin dashboard in 2 browser tabs
Make changes in one tab
Verify changes appear instantly in other tab
Check connection status shows "Live Sync Active"

7. VERIFY ROLE SYSTEM

Check all users have either 'user' or 'developer' role
No 'admin' role should exist
User modal should only show 2 role options

8. ENVIRONMENT VARIABLES
Add to .env:
WS_HEARTBEAT_INTERVAL=30000
WS_RECONNECT_MAX_ATTEMPTS=5

---

### **EXPECTED RESULTS:**

✅ **Live Sync on ALL Tabs** - Every admin tab updates in real-time  
✅ **Connection Status Indicator** - Shows "Live Sync Active" or "Offline"  
✅ **Role System Fixed** - Only User and Developer roles in database  
✅ **WebSocket Heartbeat** - Keeps connection alive with ping/pong  
✅ **Auto-Reconnect** - Reconnects with exponential backoff  
✅ **Message Queue** - Queues messages when offline, sends when reconnected  
✅ **Broadcast System** - All changes broadcast to connected clients  
✅ **User Status Toggle** - Click to activate/deactivate users  
✅ **Toast Notifications** - Shows when data updates from other sessions  
✅ **Database Consistency** - All 'admin' roles converted to 'developer'  

Every single change in any tab will now instantly sync across all connected browser sessions!