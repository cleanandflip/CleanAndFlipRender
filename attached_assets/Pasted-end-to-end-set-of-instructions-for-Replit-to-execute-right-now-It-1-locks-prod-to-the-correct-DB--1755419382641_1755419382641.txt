end-to-end set of instructions for Replit to execute right now. It (1) locks prod to the correct DB, (2) removes onboarding everywhere (we‚Äôre not bringing it back), (3) applies migrations at boot so schema drift can‚Äôt break prod, (4) cleans builds so old code never runs, (5) fixes cart FKs + uniqueness, and (6) gives verification steps.

üîí 0) Freeze deploys & enable maintenance (one-time)

Pause current prod deployments until section 6 is completed.

If the site is actively erroring, temporarily return a simple 503 from / (or swap to a static maintenance page) while you update.

üå± 1) Environment: one DB, one config

Goal: Production code only ever talks to the production database.

1.1 Secrets (Replit ‚Üí Tools ‚Üí Secrets)

Keep only these:

DATABASE_URL ‚Üí your Neon prod branch URL

NODE_ENV=production

APP_ENV=production

APP_BUILD_ID ‚Üí set at deploy to $(git rev-parse --short HEAD)

(optional) EXPECTED_DB_HOST ‚Üí the host from your Neon prod URL (e.g. ep-xxx.neon.tech)

Delete any duplicates/legacy: PG_URL, POSTGRES_URL, NEON_DB_URL, DB_URL, etc.

1.2 Add a strict env loader

Create server/config/env.ts:

import { z } from "zod";

const EnvSchema = z.object({
  NODE_ENV: z.enum(["production","development","test"]).default("development"),
  APP_ENV: z.enum(["production","staging","development"]).default("development"),
  DATABASE_URL: z.string().url(),
  EXPECTED_DB_HOST: z.string().optional(),
  APP_BUILD_ID: z.string().optional(),
});

export const env = EnvSchema.parse(process.env);


If needed: npm i zod

1.3 Guard against wrong DB at boot

Create server/config/guards.ts:

import { env } from "./env";

export function assertProdDB() {
  if (env.APP_ENV !== "production") return;
  const url = new URL(env.DATABASE_URL);
  if (env.EXPECTED_DB_HOST && url.host !== env.EXPECTED_DB_HOST) {
    throw new Error(`[BOOT] Wrong DB host for prod: got ${url.host}, expected ${env.EXPECTED_DB_HOST}`);
  }
  if (url.protocol !== "postgres:") {
    throw new Error("[BOOT] DATABASE_URL must be postgres:// in prod");
  }
}

üß± 2) Boot migrations before routes (no more schema drift)

Create server/db/migrate.ts:

import { migrate } from "drizzle-orm/neon-http/migrator";
import { drizzle } from "drizzle-orm/neon-http";
import { neon } from "@neondatabase/serverless";
import { env } from "../config/env";

export async function applyMigrations() {
  const sql = neon(env.DATABASE_URL);
  const db = drizzle(sql);
  console.log("[MIGRATIONS] Applying‚Ä¶");
  await migrate(db, { migrationsFolder: "./drizzle" });
  console.log("[MIGRATIONS] Done.");
}


In your server bootstrap (e.g., server/app.ts or server/index.ts), very top before routes:

import { env } from "./config/env";
import { assertProdDB } from "./config/guards";
import { applyMigrations } from "./db/migrate";

console.log("[BOOT]", { env: env.APP_ENV, nodeEnv: env.NODE_ENV, build: env.APP_BUILD_ID });
console.log("[BOOT] DB:", new URL(env.DATABASE_URL).host);

assertProdDB();
await applyMigrations().catch((e) => {
  console.error("[MIGRATIONS] Failed", e);
  process.exit(1); // don't start if schema is wrong
});

üßπ 3) Remove onboarding everywhere (code + DB)

We removed onboarding. Do not re-add or read it.

3.1 Kill all code references

Search & remove:

rg -n --no-heading -g '!node_modules' \
  -e 'onboarding_completed_at' \
  -e 'onboardingCompletedAt' \
  -e '\bonboarding\b'


Apply:

shared/schema.ts ‚Üí remove any onboarding fields from users.

All queries (Drizzle or raw SQL) ‚Üí never select onboarding_completed_at.

Auth/Passport & DTOs ‚Üí remove fields/logic for onboarding.

Client ‚Üí ensure no UI uses onboarding.

3.2 DB migration to drop (idempotent)

Create drizzle/00XX_drop_onboarding.sql:

ALTER TABLE "users" DROP COLUMN IF EXISTS "onboarding_completed_at";


This keeps all envs in sync; production currently lacks this column, so IF EXISTS is safe.

üõí 4) Cart integrity: FKs + uniqueness (and stop dupes)

Your logs show FK missing + cart 500s. Add constraints safely.

4.1 Inspect current constraints (optional but informative)
SELECT conname, conrelid::regclass AS table, pg_get_constraintdef(oid)
FROM pg_constraint
WHERE conrelid::regclass::text IN ('cart_items','users','products')
ORDER BY conname;

4.2 Add FKs (idempotent, safe)

Create migration (e.g., drizzle/00XY_cart_fk.sql). Adjust column names if yours differ (commonly product_id, user_id, session_id):

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'fk_cart_items_product') THEN
    ALTER TABLE "cart_items"
    ADD CONSTRAINT "fk_cart_items_product"
    FOREIGN KEY ("product_id")
    REFERENCES "products"("id")
    ON DELETE CASCADE
    NOT VALID;
    ALTER TABLE "cart_items" VALIDATE CONSTRAINT "fk_cart_items_product";
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'fk_cart_items_user') THEN
    ALTER TABLE "cart_items"
    ADD CONSTRAINT "fk_cart_items_user"
    FOREIGN KEY ("user_id")
    REFERENCES "users"("id")
    ON DELETE SET NULL
    NOT VALID;
    ALTER TABLE "cart_items" VALIDATE CONSTRAINT "fk_cart_items_user";
  END IF;
END$$;

4.3 Enforce uniqueness per owner/product/variant (prevents duplicates)

If you have a single owner_id:

CREATE UNIQUE INDEX IF NOT EXISTS "uniq_cart_owner_product"
ON "cart_items" (owner_id, product_id, COALESCE(variant_id, ''));


If you use user_id or session_id (no owner_id):

CREATE UNIQUE INDEX IF NOT EXISTS "uniq_cart_owner_product_func"
ON "cart_items" (COALESCE(user_id::text, session_id), product_id, COALESCE(variant_id, ''));


If duplicates exist now, run your server‚Äôs consolidate routine once (or delete dup rows keeping the latest) before adding the unique index.

üç™ 5) Sessions & cart ownership (single source of truth)

You already moved to connect.sid only ‚Äî keep it that way.

server/middleware/ensureSession.ts

export default function ensureSession(req, _res, next) {
  if (!req.session) return next(new Error("Session not initialized"));
  (req as any).sessionId = req.sessionID; // mirror only
  return next();
}


Never set a custom sid cookie. Search & delete any:

rg -n --no-heading -g '!node_modules' -e "res\\.cookie\\(['\"]sid['\"]" -e "guest-" -e "session\\.cartOwnerId"


Cart owner helper (every cart route must use this)

// server/utils/cartOwner.ts
export function getCartOwnerId(req: any): string {
  return req.user?.id ?? req.sessionID; // user ID if logged in, else session ID
}


Routes

GET/POST/PATCH/DELETE /api/cart ‚Üí always const ownerId = getCartOwnerId(req).

Remove legacy cart.ts routes; keep one server/routes/cart.ts (rename your v2 to this, update imports).

Fix any subtotal NaN: ensure prices are numeric (Number(product.price)) before math.

Client

API wrapper uses credentials: 'include' / withCredentials: true.

Only call the unified endpoints (/api/cart + /api/cart/product/:id).

Purge duplicate buttons: keep one AddToCartButton and update imports.

üßº 6) Clean builds only (no stale code)

.gitignore must include:

dist
.next
build
.turbo


package.json:

{
  "scripts": {
    "clean": "rimraf dist .next .turbo build",
    "build": "npm run clean && tsc -b && vite build",
    "start": "node dist/server/index.js"
  }
}


npm i -D rimraf if missing.

Replit Deploy command (prod):

APP_ENV=production NODE_ENV=production APP_BUILD_ID=$(git rev-parse --short HEAD) npm run build && npm run start


At boot you should always see:

[BOOT] { env: 'production', nodeEnv: 'production', build: '<sha>' }
[BOOT] DB: ep-<your-prod-host>.neon.tech
[MIGRATIONS] Applying‚Ä¶
[MIGRATIONS] Done.

üßØ 7) Fast ‚Äúnuke & cutover‚Äù option (only if prod DB is messy)

If staging (or your ‚Äúenvironment‚Äù DB) is correct and prod is messy:

In Neon, branch from staging to a new prod branch.

Point prod DATABASE_URL to that new branch.

Redeploy (migrations will apply, app starts clean).

Decommission the old prod DB branch after you verify.

This is safer/faster than wiping tables by hand.

‚úÖ 8) Verification checklist (run all)

SQL checks (prod DB):

-- Onboarding must NOT exist
SELECT column_name FROM information_schema.columns
WHERE table_name='users' AND column_name='onboarding_completed_at';
-- Expect: 0 rows

-- FKs & indexes exist
SELECT conname, pg_get_constraintdef(oid)
FROM pg_constraint
WHERE conrelid::regclass::text='cart_items';

SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename='cart_items';


HTTP checks:

# User (unauthenticated is fine)
curl -i https://<your-host>/api/user

# Product feature (should be 200)
curl -i https://<your-host>/api/products/featured

# Cart flow (cookie jar preserved)
rm -f /tmp/c.sess
curl -i -c /tmp/c.sess -b /tmp/c.sess \
  -H "Content-Type: application/json" \
  -X POST https://<your-host>/api/cart \
  --data '{"productId":"TEST-1","qty":1}'

curl -s -c /tmp/c.sess -b /tmp/c.sess https://<your-host>/api/cart | head -120
# Expect to see TEST-1 with qty 1 (no NaN totals, no 500s)


Logs should NOT contain:

onboarding_completed_at

FK constraint: ‚ùå MISSING

random/stale commit IDs (confirm [BOOT] build is current)

schema mismatch fallbacks

üß± 9) Guardrails so this never returns

ESLint rule to block ‚Äúonboarding‚Äù:

"no-restricted-syntax": [
  "error",
  { "selector": "Literal[value=/onboarding/i]", "message": "Onboarding was removed. Do not reintroduce." }
]


CI drift check (GitHub Actions or Replit CI):

npm ci && npx drizzle-kit check (or migrate against a temp Neon branch, then drop it).

Grep fail for onboarding:

test $(rg -n --no-heading -S '\bonboarding\b' | wc -l) -eq 0

Done right, this gives you:

A single prod DB, enforced at boot.

No onboarding anywhere (no 500s from missing columns).

Migrations must be applied before the server starts.

Clean deployments (no stale dist/ surprises).

Cart with FKs + unique owner/product integrity (no dupes, fewer 500s).

If you want, paste your users definition from shared/schema.ts and your getUser/deserialize function; I‚Äôll hand back the exact final snippets (with only supported fields) to drop in.