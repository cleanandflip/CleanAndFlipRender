Scope
Left Category Tabs: keep structure, add smooth animations, a11y, and keyboard support.

Unified Search System used by both the page search and the header search.

Buttons on product cards must work (add-to-cart, view, etc.) with proper states.

Remove all legacy filter/search code and dead imports.

Ensure deep-links, back/forward, and URL syncing are correct.

Phase 1 — Shared Search System (single source of truth)
1. Create a Search Service (URL-driven)
File: src/lib/searchService.ts

Expose functions:

getQueryFromURL(): { q: string; category: string; sort?: string; page?: number }

setQueryInURL(patch: Partial<{ q: string; category: string; sort: string; page: number }>, { replace?: boolean } = {})

subscribeToQuery(fn: (query) => void): () => void (listen to popstate for back/forward)

All search UIs must read from this and write with setQueryInURL.

2. Replace page + header search inputs with a shared component
Component: src/components/search/SearchBar.tsx

Props:

placeholder?: string

autoFocus?: boolean

size?: "sm" | "md" | "lg"

id?: string (for accessibility)

Behavior:

Controlled by the querystring (q).

Debounced update: 300ms before writing to URL.

Clear button resets q and keeps other params.

Keyboard:

/ to focus (global listener).

Esc to blur/clear (configurable).

Emits analytics event search_changed with { q, category }.

Use the same component in header and on /products.

3. Products data must react to URL
If client-side filtering: hook already written (useProducts) should depend on window.location.search.

If API filtering:

The fetcher must include ?q=&category= from searchService.getQueryFromURL() and refetch on changes.

Keep deep-linking: loading /products?category=barbells&q=rogue shows correct results immediately.

Phase 2 — Category Tabs polish (animations + a11y + keyboard)
1. Hook up interaction states (logic is already there)
Add aria-current="page" to the active tab (done).

Add aria-label="Product Categories" on nav.

Keyboard:

Tab/Shift+Tab navigates focus across items.

Optional: Arrow Up/Down cycles between tabs; Enter/Space activates.

Implement by capturing keydown on the tablist and moving focus.

2. Animations (theme will supply styles)
On hover/focus: subtle scale/raise + opacity change (CSS-only).

On active change:

Animate an active indicator/pill sliding to the selected tab (transform-based).

Add a reduced-motion fallback (no transform when prefers-reduced-motion).

On mount: staggered fade-in of tabs for a polished first render.

Replit: add the necessary utility classes/variants per your theme framework; avoid inline styles.

Phase 3 — Button functionality audit and fixes
1. Product Card Buttons
Identify all interactive buttons on the grid:

View / Details → navigate to products/:id.

Add to Cart → add item; show completing state.

Sign in to shop → if gated, open auth flow.

Ensure each button has:

onClick wired to its handler.

aria-label (for icon-only).

Disabled state during async actions.

Loading state (spinner or text, theme-styled).

Error toast on failure (use your existing toast service).

2. Business rules
If inventory is <= 0, disable “Add to Cart” and show “Sold Out”.

Respect min/max quantity per product.

Preserve return-to param: when navigating to auth or details, include ?returnTo=/products?....

3. Analytics
Emit events:

product_viewed, add_to_cart_clicked, add_to_cart_succeeded/failed.

Phase 4 — Legacy teardown
1. Remove old filters/search logic
Delete UI panels for price/brand/condition, etc.

Remove hooks/contexts: useFilters, FiltersProvider, range schemas.

Remove URL writers for legacy params (priceMin, brand, etc.).

Update barrels to stop exporting removed modules.

Commands (grep):

nginx
Copy
Edit
rg -n "Filter|Filters|Facet|useFilters|FiltersProvider"
rg -n "priceMin|priceMax|brand|condition|availability|range"
All should return no active references after the refactor.

Phase 5 — Nav bar search parity
Replace header search with the shared SearchBar component.

Behavior:

Typing in header updates the same q param.

Pressing Enter navigates to /products (if not already there) and preserves current category.

If already on /products, simply updates URL and triggers filtering.

Add global / keybinding to focus whichever SearchBar is visible.

Phase 6 — Error states, empty states, and loading
Empty results: friendly message + suggestion to clear search or switch category.

Loading:

Show skeletons in the grid while fetching or filtering.

Errors:

Display retry CTA; don’t crash page.

Phase 7 — Tests (critical paths)
Search Service

setQueryInURL({ q: "bar" }) updates URL with preserved category.

Back/forward triggers subscribers and updates UI.

SearchBar

Debounce: URL writes only after 300ms of idle typing.

Clear resets q but not category.

Category Tabs

Clicking “Barbells” sets ?category=barbells and keeps q.

Unknown slug on load → falls back to All Categories (no param).

Product Buttons

“Add to Cart” toggles disabled/loading and calls cart API once.

“View” navigates with returnTo.

Phase 8 — Acceptance criteria (sign-off)
 Header and page searches look and behave identically (shared component).

 Typing in either search updates ?q= and filters the grid.

 Category tabs animate nicely and are keyboard-accessible.

 Active tab state persists on reload via ?category=.

 Product buttons function with correct states and analytics.

 Old filter code and query params are fully removed.

 No UI regressions on mobile/desktop.

 Lighthouse/Perf unchanged or improved.

Integration Notes (where Replit will wire)
Replace old page-level search input with <SearchBar />.

Replace header’s search with <SearchBar />.

Ensure the products fetcher (or client filter) subscribes to window.onpopstate via the search service to re-render on history changes.

Use your theme for:

Tab hover/active transitions, indicator animation, focus rings.

SearchBar field, clear button, loading indicator.

Button loading/disabled/hover states.