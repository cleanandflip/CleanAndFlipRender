FIX IMAGE UPLOAD - DIRECT TO CLOUDINARY (ENTIRE APP)

REPLIT INSTRUCTIONS:
markdown## IMPLEMENT DIRECT CLOUDINARY UPLOAD EVERYWHERE

### THE PROBLEM:
- Images as base64 are too large (PayloadTooLargeError)
- Server can't handle large image data in JSON
- Multiple places upload images (Sell page, Admin dashboard, Product modals)

### THE SOLUTION:
Create ONE reusable Cloudinary upload system for the ENTIRE app

---

### STEP 1: CREATE REUSABLE CLOUDINARY HOOK

FILE: Create `/client/src/hooks/useCloudinaryUpload.tsx`

CREATE a reusable hook that:
1. Handles all image uploads app-wide
2. Returns: uploadImages, uploadProgress, isUploading, error
3. Includes compression, validation, progress tracking
4. Can be used in ANY component

Key features:
- MAX_FILE_SIZE = 3MB
- MAX_IMAGES configurable per use
- Auto-compression for large files
- Progress tracking
- Error handling

---

### STEP 2: BACKEND - CREATE CLOUDINARY SIGNATURE ENDPOINT

FILE: `/server/routes/api.ts` or create `/server/routes/cloudinary.ts`

CREATE an endpoint that:
1. Path: `/api/cloudinary/signature`
2. Requires authentication
3. Generates timestamp and signature
4. Works for ALL image uploads (products, equipment, etc.)
5. Different folders based on upload type:
   - 'equipment-submissions' for sell-to-us
   - 'products' for product images
   - Pass folder as query param: `/api/cloudinary/signature?folder=products`

---

### STEP 3: UPDATE ALL IMAGE UPLOAD LOCATIONS

#### A. SELL TO US PAGE
FILE: `/client/src/pages/SellToUs.tsx`

USE the new hook:
```jsx
import { useCloudinaryUpload } from '@/hooks/useCloudinaryUpload';

// In component:
const { uploadImages, uploadProgress, isUploading } = useCloudinaryUpload({
  maxImages: 8,
  folder: 'equipment-submissions'
});

// In handleFiles:
const urls = await uploadImages(files);
setUploadedImages(urls);
B. PRODUCT MODAL (Admin Dashboard)
FILE: /client/src/components/admin/modals/ProductModal.tsx
REPLACE existing image upload with:
jsximport { useCloudinaryUpload } from '@/hooks/useCloudinaryUpload';

// In component:
const { uploadImages, uploadProgress, isUploading } = useCloudinaryUpload({
  maxImages: 10,
  folder: 'products'
});

// Handle product images:
const handleImageUpload = async (files: File[]) => {
  const urls = await uploadImages(files);
  setProductImages(urls);
  // Update form with Cloudinary URLs
};
C. ADMIN PRODUCTS TAB
FILE: /client/src/pages/admin/ProductsTab.tsx
UPDATE bulk upload and single product upload to use the same system.
D. ANY OTHER IMAGE UPLOAD
Search for these patterns and replace ALL:

FileReader with base64 conversion
readAsDataURL
Large base64 strings in API calls
Image upload in any modal or form


STEP 4: CREATE REUSABLE IMAGE UPLOAD COMPONENT
FILE: Create /client/src/components/shared/ImageUploadZone.tsx
CREATE a reusable component that:

Uses the useCloudinaryUpload hook
Shows drag & drop zone
Displays upload progress
Shows image previews
Can be dropped into ANY form

Props:

maxImages: number
folder: string
onUploadComplete: (urls: string[]) => void
existingImages?: string[]

Use this component in:

ProductModal
SellToUs page
Any future image upload needs


STEP 5: UPDATE ALL API ENDPOINTS
FILES TO CHECK:

/server/routes/admin.ts - Product creation/update
/server/routes/products.ts - Product management
/server/routes/equipment.ts - Equipment submissions

ENSURE all endpoints:

Expect image URLs (strings) not base64
Validate URLs are from Cloudinary
Store URLs directly in database
No longer process base64 images


STEP 6: SERVER CONFIGURATION
FILE: /server/index.ts
REDUCE body parser limit since we're not sending images anymore:
typescript// Can now use small limit - images go direct to Cloudinary
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ limit: '1mb', extended: true }));

STEP 7: DATABASE SCHEMA CHECK
Ensure all image fields in database:

products.images
equipment_submissions.images
Any other image columns

Are storing Cloudinary URLs (text/json) not base64 blobs.

KEY IMPLEMENTATION POINTS:

ONE SOURCE OF TRUTH: Single upload hook/component used everywhere
CONSISTENT LIMITS: Same file size/count limits app-wide
FOLDER ORGANIZATION:

/products for product images
/equipment-submissions for sell-to-us
/avatars for user avatars (if needed)


SECURITY: Signature always from backend
VALIDATION: Check file type/size before upload
OPTIMIZATION: Auto-compress large images
USER FEEDBACK: Progress bars everywhere
ERROR HANDLING: Consistent error messages

SEARCH AND REPLACE PATTERNS:
Find these patterns in ALL files:
bash# Find base64 conversions
grep -r "readAsDataURL" client/src

# Find FileReader usage
grep -r "new FileReader" client/src

# Find large body parser limits
grep -r "limit.*mb" server/

# Find image handling in modals
grep -r "handleImageUpload\|handleFileUpload" client/src/components
Replace ALL with the new Cloudinary system.
BENEFITS FOR ENTIRE APP:

No more payload errors anywhere
Consistent image handling
Faster uploads (direct to CDN)
Automatic optimization (WebP, compression)
Better user experience
Reduced server load
Scalable solution

TESTING CHECKLIST:

 Sell to Us page - upload 8 images
 Admin Products - create product with images
 Admin Products - edit product images
 Admin Products - bulk upload
 All uploads show progress
 Large files get compressed
 Error messages work
 Images display from Cloudinary URLs
 No base64 in network requests

This ensures EVERY image upload in your app uses the same efficient Cloudinary system!