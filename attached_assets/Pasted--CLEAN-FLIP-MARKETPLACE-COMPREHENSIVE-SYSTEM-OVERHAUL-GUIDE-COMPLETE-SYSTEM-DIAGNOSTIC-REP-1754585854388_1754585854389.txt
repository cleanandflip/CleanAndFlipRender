ðŸ”§ CLEAN & FLIP MARKETPLACE - COMPREHENSIVE SYSTEM OVERHAUL GUIDE
ðŸ“Š COMPLETE SYSTEM DIAGNOSTIC REPORT
Based on your audit report, server logs, and dashboard screenshots, here's a comprehensive analysis and multi-option fix strategy for each critical issue.

ISSUE 1: EQUIPMENT SUBMISSIONS DATABASE FAILURE ðŸ”´
Root Cause Analysis:
ERROR: column equipment_submissions.reference_number does not exist
The API is querying for reference_number but your schema likely uses id or a different column name.

SOLUTION OPTIONS:
Option A: Database Migration (RECOMMENDED)
sql
-- Create migration file: /db/migrations/fix_equipment_submissions.sql
BEGIN;

-- Check existing schema
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'equipment_submissions';

-- Add reference_number if missing
ALTER TABLE equipment_submissions 
ADD COLUMN IF NOT EXISTS reference_number VARCHAR(20) UNIQUE 
DEFAULT CONCAT('REF-', LPAD(CAST(EXTRACT(EPOCH FROM NOW()) * 1000 AS VARCHAR), 13, '0'));

-- Create index for performance
CREATE INDEX IF NOT EXISTS idx_equipment_submissions_reference 
ON equipment_submissions(reference_number);

-- Migrate existing data
UPDATE equipment_submissions 
SET reference_number = CONCAT('REF-', LPAD(CAST(id AS VARCHAR), 8, '0'))
WHERE reference_number IS NULL;

COMMIT;
Option B: API Layer Fix (Quick Fix)
javascript
// /server/routes/admin/submissions.js
import { eq, desc, like, or, sql } from 'drizzle-orm';

router.get('/admin/submissions', requireAdmin, async (req, res) => {
  try {
    const { status, search, sortBy = 'created_at', sortOrder = 'desc', page = 1, limit = 20 } = req.query;
    
    // Build dynamic query with fallback columns
    const conditions = [];
    
    if (status && status !== 'all') {
      conditions.push(eq(equipmentSubmissions.status, status));
    }
    
    if (search) {
      // Use existing columns instead of reference_number
      conditions.push(
        or(
          like(equipmentSubmissions.id, `%${search}%`),
          like(equipmentSubmissions.name, `%${search}%`),
          like(equipmentSubmissions.email, `%${search}%`),
          like(equipmentSubmissions.brand, `%${search}%`)
        )
      );
    }
    
    // Safe column mapping
    const sortColumns = {
      'date': equipmentSubmissions.created_at,
      'status': equipmentSubmissions.status,
      'name': equipmentSubmissions.name,
      'value': equipmentSubmissions.estimated_value
    };
    
    const sortColumn = sortColumns[sortBy] || equipmentSubmissions.created_at;
    const orderDirection = sortOrder === 'asc' ? 'asc' : 'desc';
    
    const [submissions, totalCount] = await Promise.all([
      db.select({
        id: equipmentSubmissions.id,
        referenceNumber: sql`COALESCE(${equipmentSubmissions.reference_number}, CONCAT('REF-', ${equipmentSubmissions.id}))`,
        name: equipmentSubmissions.name,
        email: equipmentSubmissions.email,
        phone: equipmentSubmissions.phone,
        equipmentType: equipmentSubmissions.equipment_type,
        brand: equipmentSubmissions.brand,
        modelName: equipmentSubmissions.model_name,
        condition: equipmentSubmissions.condition,
        description: equipmentSubmissions.description,
        estimatedValue: equipmentSubmissions.estimated_value,
        images: equipmentSubmissions.images,
        status: equipmentSubmissions.status,
        submittedAt: equipmentSubmissions.created_at,
        notes: equipmentSubmissions.admin_notes
      })
      .from(equipmentSubmissions)
      .where(conditions.length > 0 ? and(...conditions) : undefined)
      .orderBy(orderDirection === 'asc' ? asc(sortColumn) : desc(sortColumn))
      .limit(Number(limit))
      .offset((Number(page) - 1) * Number(limit)),
      
      db.select({ count: count() })
        .from(equipmentSubmissions)
        .where(conditions.length > 0 ? and(...conditions) : undefined)
    ]);
    
    res.json({
      submissions,
      total: totalCount[0]?.count || 0,
      page: Number(page),
      totalPages: Math.ceil((totalCount[0]?.count || 0) / Number(limit))
    });
  } catch (error) {
    console.error('Submissions endpoint error:', error);
    res.status(500).json({ 
      error: 'Failed to fetch submissions',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});
Option C: Schema Redesign (Long-term)
javascript
// /db/schema/equipment-submissions.ts
export const equipmentSubmissions = pgTable('equipment_submissions', {
  id: uuid('id').defaultRandom().primaryKey(),
  referenceNumber: varchar('reference_number', { length: 20 })
    .notNull()
    .unique()
    .$defaultFn(() => `REF-${Date.now()}-${Math.random().toString(36).substr(2, 5).toUpperCase()}`),
  
  // Customer information
  name: varchar('name', { length: 255 }).notNull(),
  email: varchar('email', { length: 255 }).notNull(),
  phone: varchar('phone', { length: 20 }),
  
  // Equipment details
  equipmentType: varchar('equipment_type', { length: 100 }).notNull(),
  brand: varchar('brand', { length: 100 }).notNull(),
  modelName: varchar('model_name', { length: 255 }),
  condition: varchar('condition', { length: 50 }).notNull(),
  yearPurchased: integer('year_purchased'),
  originalPrice: decimal('original_price', { precision: 10, scale: 2 }),
  estimatedValue: decimal('estimated_value', { precision: 10, scale: 2 }),
  
  // Additional fields
  description: text('description'),
  images: json('images').$type<string[]>().default([]),
  
  // Status tracking
  status: varchar('status', { length: 50 })
    .notNull()
    .default('pending')
    .$type<'pending' | 'reviewing' | 'approved' | 'rejected' | 'purchased'>(),
  
  // Admin fields
  adminNotes: text('admin_notes'),
  reviewedBy: uuid('reviewed_by').references(() => users.id),
  reviewedAt: timestamp('reviewed_at'),
  offerAmount: decimal('offer_amount', { precision: 10, scale: 2 }),
  
  // Timestamps
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull()
}, (table) => ({
  referenceNumberIdx: index('idx_reference_number').on(table.referenceNumber),
  statusIdx: index('idx_status').on(table.status),
  createdAtIdx: index('idx_created_at').on(table.createdAt),
  emailIdx: index('idx_email').on(table.email)
}));
ISSUE 2: IMAGE CACHING & CLOUDINARY PROBLEMS ðŸ”´
Root Cause:
Cloudinary URLs are being cached by browsers and CDN, showing outdated images even after updates.

SOLUTION OPTIONS:
Option A: Cloudinary Versioning System (RECOMMENDED)
javascript
// /server/utils/cloudinary.js
import { v2 as cloudinary } from 'cloudinary';
import crypto from 'crypto';

class CloudinaryManager {
  constructor() {
    cloudinary.config({
      cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
      api_key: process.env.CLOUDINARY_API_KEY,
      api_secret: process.env.CLOUDINARY_API_SECRET,
      secure: true
    });
  }
  
  async uploadImage(file, folder = 'products') {
    try {
      // Generate unique version ID
      const versionId = crypto.randomBytes(4).toString('hex');
      
      const result = await cloudinary.uploader.upload(file, {
        folder: `clean-flip/${folder}`,
        resource_type: 'auto',
        overwrite: true,
        invalidate: true, // Invalidate CDN cache
        unique_filename: false,
        use_filename: true,
        context: `version=${versionId}`,
        transformation: [
          { quality: 'auto:best' },
          { fetch_format: 'auto' }
        ]
      });
      
      // Return URL with version parameter
      return {
        url: result.secure_url,
        publicId: result.public_id,
        version: result.version,
        versionedUrl: `${result.secure_url}?v=${result.version}`
      };
    } catch (error) {
      console.error('Cloudinary upload error:', error);
      throw error;
    }
  }
  
  async updateImage(publicId, newFile) {
    // Delete old version
    await this.deleteImage(publicId);
    // Upload new version
    return this.uploadImage(newFile);
  }
  
  async deleteImage(publicId) {
    try {
      await cloudinary.uploader.destroy(publicId, { invalidate: true });
    } catch (error) {
      console.error('Cloudinary delete error:', error);
    }
  }
  
  getOptimizedUrl(publicId, options = {}) {
    const defaults = {
      quality: 'auto',
      fetch_format: 'auto',
      width: options.width || 800,
      height: options.height || 800,
      crop: 'limit',
      dpr: 'auto'
    };
    
    return cloudinary.url(publicId, {
      ...defaults,
      ...options,
      version: Date.now(), // Force cache bust
      secure: true
    });
  }
}

export const cloudinaryManager = new CloudinaryManager();
Option B: Frontend Image Component with Cache Control
typescript
// /client/src/components/OptimizedImage.tsx
import React, { useState, useEffect } from 'react';
import { Loader2 } from 'lucide-react';

interface OptimizedImageProps {
  src: string;
  alt: string;
  className?: string;
  width?: number;
  height?: number;
  priority?: boolean;
  onError?: () => void;
}

export const OptimizedImage: React.FC<OptimizedImageProps> = ({
  src,
  alt,
  className = '',
  width,
  height,
  priority = false,
  onError
}) => {
  const [imageSrc, setImageSrc] = useState<string>('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(false);
  
  useEffect(() => {
    // Add cache busting and optimization parameters
    const optimizeImageUrl = (url: string) => {
      if (!url) return '/placeholder.jpg';
      
      // Check if it's a Cloudinary URL
      if (url.includes('cloudinary.com')) {
        const baseUrl = url.split('?')[0];
        const timestamp = Date.now();
        
        // Add Cloudinary transformations
        const transformations = [
          'q_auto:best',
          'f_auto',
          width ? `w_${width}` : 'w_800',
          height ? `h_${height}` : 'h_800',
          'c_limit',
          'dpr_auto'
        ].join(',');
        
        // Insert transformations into URL
        const urlParts = baseUrl.split('/upload/');
        if (urlParts.length === 2) {
          return `${urlParts[0]}/upload/${transformations}/${urlParts[1]}?v=${timestamp}`;
        }
      }
      
      // For non-Cloudinary URLs, just add timestamp
      return `${url}${url.includes('?') ? '&' : '?'}t=${Date.now()}`;
    };
    
    setImageSrc(optimizeImageUrl(src));
  }, [src, width, height]);
  
  const handleImageError = () => {
    setError(true);
    setLoading(false);
    setImageSrc('/placeholder.jpg');
    onError?.();
  };
  
  const handleImageLoad = () => {
    setLoading(false);
    setError(false);
  };
  
  return (
    <div className={`relative ${className}`}>
      {loading && (
        <div className="absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800">
          <Loader2 className="w-8 h-8 animate-spin text-gray-400" />
        </div>
      )}
      
      <img
        src={imageSrc}
        alt={alt}
        className={`${className} ${loading ? 'opacity-0' : 'opacity-100'} transition-opacity duration-300`}
        onLoad={handleImageLoad}
        onError={handleImageError}
        loading={priority ? 'eager' : 'lazy'}
        width={width}
        height={height}
      />
      
      {error && (
        <div className="absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800">
          <span className="text-gray-500">Failed to load image</span>
        </div>
      )}
    </div>
  );
};
Option C: Service Worker for Image Management
javascript
// /public/image-service-worker.js
const CACHE_NAME = 'clean-flip-images-v1';
const IMAGE_CACHE_DURATION = 60 * 60 * 1000; // 1 hour

self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('cloudinary.com')) {
    event.respondWith(
      caches.open(CACHE_NAME).then(async (cache) => {
        const cachedResponse = await cache.match(event.request);
        
        if (cachedResponse) {
          const cachedTime = new Date(cachedResponse.headers.get('sw-cached-time'));
          const now = new Date();
          
          if (now - cachedTime < IMAGE_CACHE_DURATION) {
            return cachedResponse;
          }
        }
        
        const networkResponse = await fetch(event.request);
        const responseToCache = networkResponse.clone();
        
        const headers = new Headers(responseToCache.headers);
        headers.set('sw-cached-time', new Date().toISOString());
        
        const modifiedResponse = new Response(responseToCache.body, {
          status: responseToCache.status,
          statusText: responseToCache.statusText,
          headers: headers
        });
        
        cache.put(event.request, modifiedResponse);
        return networkResponse;
      })
    );
  }
});
ISSUE 3: PRODUCT EDIT MODAL COMPLETE REBUILD ðŸ”´
Complete New Implementation:
typescript
// /client/src/components/admin/ProductEditModal.tsx
import React, { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle,
  DialogFooter 
} from '@/components/ui/dialog';
import { 
  Tabs, 
  TabsContent, 
  TabsList, 
  TabsTrigger 
} from '@/components/ui/tabs';
import { 
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage
} from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Switch } from '@/components/ui/switch';
import { 
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { 
  Upload, 
  X, 
  Save, 
  Loader2, 
  Package, 
  DollarSign, 
  Image as ImageIcon,
  Tag,
  AlertCircle,
  Check
} from 'lucide-react';
import { toast } from 'sonner';

// Validation Schema
const productSchema = z.object({
  name: z.string().min(3, 'Product name must be at least 3 characters'),
  sku: z.string().optional(),
  category_id: z.string().uuid('Please select a category'),
  description: z.string().min(10, 'Description must be at least 10 characters'),
  price: z.number().min(0, 'Price must be positive'),
  compare_at_price: z.number().optional(),
  stock: z.number().int().min(0, 'Stock must be non-negative'),
  brand: z.string().optional(),
  condition: z.enum(['new', 'like-new', 'good', 'fair']),
  active: z.boolean(),
  featured: z.boolean(),
  shipping_available: z.boolean(),
  local_pickup_available: z.boolean(),
  weight: z.number().optional(),
  dimensions: z.object({
    length: z.number().optional(),
    width: z.number().optional(),
    height: z.number().optional()
  }).optional(),
  tags: z.array(z.string()).optional(),
  images: z.array(z.string()).min(1, 'At least one image is required')
});

type ProductFormData = z.infer<typeof productSchema>;

interface ProductEditModalProps {
  product?: any;
  open: boolean;
  onClose: () => void;
  onSuccess?: () => void;
}

export const ProductEditModal: React.FC<ProductEditModalProps> = ({
  product,
  open,
  onClose,
  onSuccess
}) => {
  const [activeTab, setActiveTab] = useState('basic');
  const [uploadingImages, setUploadingImages] = useState(false);
  const [imageUrls, setImageUrls] = useState<string[]>(product?.images || []);
  const queryClient = useQueryClient();
  
  // Fetch categories
  const { data: categories } = useQuery({
    queryKey: ['categories'],
    queryFn: () => fetch('/api/admin/categories').then(res => res.json())
  });
  
  // Form setup
  const form = useForm<ProductFormData>({
    resolver: zodResolver(productSchema),
    defaultValues: {
      name: product?.name || '',
      sku: product?.sku || '',
      category_id: product?.category_id || '',
      description: product?.description || '',
      price: product?.price || 0,
      compare_at_price: product?.compare_at_price || undefined,
      stock: product?.stock || 0,
      brand: product?.brand || '',
      condition: product?.condition || 'new',
      active: product?.active ?? true,
      featured: product?.featured ?? false,
      shipping_available: product?.shipping_available ?? true,
      local_pickup_available: product?.local_pickup_available ?? true,
      tags: product?.tags || [],
      images: product?.images || []
    }
  });
  
  // Save mutation
  const saveMutation = useMutation({
    mutationFn: async (data: ProductFormData) => {
      const url = product 
        ? `/api/admin/products/${product.id}`
        : '/api/admin/products';
      
      const method = product ? 'PUT' : 'POST';
      
      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      
      if (!response.ok) {
        throw new Error('Failed to save product');
      }
      
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['products'] });
      toast.success(product ? 'Product updated!' : 'Product created!');
      onSuccess?.();
      onClose();
    },
    onError: (error) => {
      toast.error('Failed to save product');
      console.error('Save error:', error);
    }
  });
  
  // Image upload handler
  const handleImageUpload = async (files: FileList) => {
    setUploadingImages(true);
    const formData = new FormData();
    
    Array.from(files).forEach(file => {
      formData.append('images', file);
    });
    
    try {
      const response = await fetch('/api/admin/upload', {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) throw new Error('Upload failed');
      
      const { urls } = await response.json();
      const newImages = [...imageUrls, ...urls];
      setImageUrls(newImages);
      form.setValue('images', newImages);
      
      toast.success(`${urls.length} image(s) uploaded`);
    } catch (error) {
      toast.error('Failed to upload images');
      console.error('Upload error:', error);
    } finally {
      setUploadingImages(false);
    }
  };
  
  const removeImage = (index: number) => {
    const newImages = imageUrls.filter((_, i) => i !== index);
    setImageUrls(newImages);
    form.setValue('images', newImages);
  };
  
  const onSubmit = (data: ProductFormData) => {
    saveMutation.mutate(data);
  };
  
  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-5xl max-h-[90vh] overflow-hidden bg-gray-900 border-gray-800">
        <DialogHeader className="border-b border-gray-800 pb-4">
          <DialogTitle className="text-xl font-bold text-white flex items-center gap-2">
            <Package className="w-5 h-5" />
            {product ? 'Edit Product' : 'Create New Product'}
          </DialogTitle>
        </DialogHeader>
        
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="flex flex-col h-full">
            <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1">
              <TabsList className="grid w-full grid-cols-4 bg-gray-800/50">
                <TabsTrigger value="basic" className="data-[state=active]:bg-gray-700">
                  <Package className="w-4 h-4 mr-2" />
                  Basic Info
                </TabsTrigger>
                <TabsTrigger value="pricing" className="data-[state=active]:bg-gray-700">
                  <DollarSign className="w-4 h-4 mr-2" />
                  Pricing
                </TabsTrigger>
                <TabsTrigger value="images" className="data-[state=active]:bg-gray-700">
                  <ImageIcon className="w-4 h-4 mr-2" />
                  Images
                </TabsTrigger>
                <TabsTrigger value="shipping" className="data-[state=active]:bg-gray-700">
                  <Tag className="w-4 h-4 mr-2" />
                  Details
                </TabsTrigger>
              </TabsList>
              
              <div className="overflow-y-auto max-h-[calc(90vh-200px)] mt-6">
                {/* Basic Info Tab */}
                <TabsContent value="basic" className="space-y-4">
                  <FormField
                    control={form.control}
                    name="name"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel className="text-gray-200">Product Name *</FormLabel>
                        <FormControl>
                          <Input 
                            {...field} 
                            className="bg-gray-800 border-gray-700 text-white"
                            placeholder="Enter product name"
                          />
                        </FormControl>
                        <FormMessage className="text-red-400" />
                      </FormItem>
                    )}
                  />
                  
                  <div className="grid grid-cols-2 gap-4">
                    <FormField
                      control={form.control}
                      name="sku"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-gray-200">SKU</FormLabel>
                          <FormControl>
                            <Input 
                              {...field} 
                              className="bg-gray-800 border-gray-700 text-white"
                              placeholder="Auto-generated if empty"
                            />
                          </FormControl>
                        </FormItem>
                      )}
                    />
                    
                    <FormField
                      control={form.control}
                      name="category_id"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-gray-200">Category *</FormLabel>
                          <Select onValueChange={field.onChange} defaultValue={field.value}>
                            <FormControl>
                              <SelectTrigger className="bg-gray-800 border-gray-700 text-white">
                                <SelectValue placeholder="Select category" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent className="bg-gray-800 border-gray-700">
                              {categories?.map((cat: any) => (
                                <SelectItem 
                                  key={cat.id} 
                                  value={cat.id}
                                  className="text-white hover:bg-gray-700"
                                >
                                  {cat.name}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                          <FormMessage className="text-red-400" />
                        </FormItem>
                      )}
                    />
                  </div>
                  
                  <FormField
                    control={form.control}
                    name="description"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel className="text-gray-200">Description *</FormLabel>
                        <FormControl>
                          <Textarea 
                            {...field} 
                            className="bg-gray-800 border-gray-700 text-white min-h-[120px]"
                            placeholder="Describe your product..."
                          />
                        </FormControl>
                        <FormMessage className="text-red-400" />
                      </FormItem>
                    )}
                  />
                  
                  <div className="grid grid-cols-2 gap-4">
                    <FormField
                      control={form.control}
                      name="brand"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-gray-200">Brand</FormLabel>
                          <FormControl>
                            <Input 
                              {...field} 
                              className="bg-gray-800 border-gray-700 text-white"
                              placeholder="Product brand"
                            />
                          </FormControl>
                        </FormItem>
                      )}
                    />
                    
                    <FormField
                      control={form.control}
                      name="condition"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-gray-200">Condition</FormLabel>
                          <Select onValueChange={field.onChange} defaultValue={field.value}>
                            <FormControl>
                              <SelectTrigger className="bg-gray-800 border-gray-700 text-white">
                                <SelectValue />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent className="bg-gray-800 border-gray-700">
                              <SelectItem value="new" className="text-white">New</SelectItem>
                              <SelectItem value="like-new" className="text-white">Like New</SelectItem>
                              <SelectItem value="good" className="text-white">Good</SelectItem>
                              <SelectItem value="fair" className="text-white">Fair</SelectItem>
                            </SelectContent>
                          </Select>
                        </FormItem>
                      )}
                    />
                  </div>
                </TabsContent>
                
                {/* Pricing Tab */}
                <TabsContent value="pricing" className="space-y-4">
                  <div className="grid grid-cols-2 gap-4">
                    <FormField
                      control={form.control}
                      name="price"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-gray-200">Price *</FormLabel>
                          <FormControl>
                            <div className="relative">
                              <span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">$</span>
                              <Input 
                                {...field}
                                type="number"
                                step="0.01"
                                className="bg-gray-800 border-gray-700 text-white pl-8"
                                placeholder="0.00"
                                onChange={e => field.onChange(parseFloat(e.target.value))}
                              />
                            </div>
                          </FormControl>
                          <FormMessage className="text-red-400" />
                        </FormItem>
                      )}
                    />
                    
                    <FormField
                      control={form.control}
                      name="compare_at_price"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-gray-200">Compare at Price</FormLabel>
                          <FormControl>
                            <div className="relative">
                              <span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">$</span>
                              <Input 
                                {...field}
                                type="number"
                                step="0.01"
                                className="bg-gray-800 border-gray-700 text-white pl-8"
                                placeholder="0.00"
                                onChange={e => field.onChange(e.target.value ? parseFloat(e.target.value) : undefined)}
                              />
                            </div>
                          </FormControl>
                          <FormDescription className="text-gray-400">
                            Original price for showing discounts
                          </FormDescription>
                        </FormItem>
                      )}
                    />
                  </div>
                  
                  <FormField
                    control={form.control}
                    name="stock"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel className="text-gray-200">Stock Quantity *</FormLabel>
                        <FormControl>
                          <Input 
                            {...field}
                            type="number"
                            className="bg-gray-800 border-gray-700 text-white"
                            placeholder="0"
                            onChange={e => field.onChange(parseInt(e.target.value))}
                          />
                        </FormControl>
                        <FormMessage className="text-red-400" />
                      </FormItem>
                    )}
                  />
                  
                  {/* Discount Calculator */}
                  {form.watch('compare_at_price') && form.watch('price') < form.watch('compare_at_price')! && (
                    <Alert className="bg-green-900/20 border-green-800">
                      <AlertCircle className="w-4 h-4 text-green-400" />
                      <AlertDescription className="text-green-300">
                        {Math.round(((form.watch('compare_at_price')! - form.watch('price')) / form.watch('compare_at_price')!) * 100)}% discount
                      </AlertDescription>
                    </Alert>
                  )}
                </TabsContent>
                
                {/* Images Tab */}
                <TabsContent value="images" className="space-y-4">
                  <div className="space-y-4">
                    <div className="border-2 border-dashed border-gray-700 rounded-lg p-8">
                      <input
                        type="file"
                        id="image-upload"
                        className="hidden"
                        multiple
                        accept="image/*"
                        onChange={(e) => e.target.files && handleImageUpload(e.target.files)}
                        disabled={uploadingImages}
                      />
                      <label
                        htmlFor="image-upload"
                        className="flex flex-col items-center justify-center cursor-pointer"
                      >
                        {uploadingImages ? (
                          <Loader2 className="w-12 h-12 animate-spin text-gray-400" />
                        ) : (
                          <Upload className="w-12 h-12 text-gray-400" />
                        )}
                        <p className="mt-2 text-sm text-gray-400">
                          {uploadingImages ? 'Uploading...' : 'Click to upload images'}
                        </p>
                        <p className="text-xs text-gray-500 mt-1">
                          PNG, JPG, GIF up to 10MB
                        </p>
                      </label>
                    </div>
                    
                    {/* Image Preview Grid */}
                    {imageUrls.length > 0 && (
                      <div className="grid grid-cols-4 gap-4">
                        {imageUrls.map((url, index) => (
                          <div key={index} className="relative group">
                            <img
                              src={url}
                              alt={`Product ${index + 1}`}
                              className="w-full h-32 object-cover rounded-lg"
                            />
                            <button
                              type="button"
                              onClick={() => removeImage(index)}
                              className="absolute top-2 right-2 p-1 bg-red-600 rounded-full opacity-0 group-hover:opacity-100 transition-opacity"
                            >
                              <X className="w-4 h-4 text-white" />
                            </button>
                            {index === 0 && (
                              <Badge className="absolute bottom-2 left-2 bg-blue-600">
                                Primary
                              </Badge>
                            )}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </TabsContent>
                
                {/* Details Tab */}
                <TabsContent value="shipping" className="space-y-4">
                  <div className="space-y-4">
                    <FormField
                      control={form.control}
                      name="active"
                      render={({ field }) => (
                        <FormItem className="flex items-center justify-between rounded-lg border border-gray-700 p-4">
                          <div className="space-y-0.5">
                            <FormLabel className="text-gray-200">Active</FormLabel>
                            <FormDescription className="text-gray-400">
                              Product is visible in the shop
                            </FormDescription>
                          </div>
                          <FormControl>
                            <Switch
                              checked={field.value}
                              onCheckedChange={field.onChange}
                            />
                          </FormControl>
                        </FormItem>
                      )}
                    />
                    
                    <FormField
                      control={form.control}
                      name="featured"
                      render={({ field }) => (
                        <FormItem className="flex items-center justify-between rounded-lg border border-gray-700 p-4">
                          <div className="space-y-0.5">
                            <FormLabel className="text-gray-200">Featured</FormLabel>
                            <FormDescription className="text-gray-400">
                              Show on homepage
                            </FormDescription>
                          </div>
                          <FormControl>
                            <Switch
                              checked={field.value}
                              onCheckedChange={field.onChange}
                            />
                          </FormControl>
                        </FormItem>
                      )}
                    />
                    
                    <FormField
                      control={form.control}
                      name="shipping_available"
                      render={({ field }) => (
                        <FormItem className="flex items-center justify-between rounded-lg border border-gray-700 p-4">
                          <div className="space-y-0.5">
                            <FormLabel className="text-gray-200">Shipping Available</FormLabel>
                            <FormDescription className="text-gray-400">
                              Can be shipped to customers
                            </FormDescription>
                          </div>
                          <FormControl>
                            <Switch
                              checked={field.value}
                              onCheckedChange={field.onChange}
                            />
                          </FormControl>
                        </FormItem>
                      )}
                    />
                    
                    <FormField
                      control={form.control}
                      name="local_pickup_available"
                      render={({ field }) => (
                        <FormItem className="flex items-center justify-between rounded-lg border border-gray-700 p-4">
                          <div className="space-y-0.5">
                            <FormLabel className="text-gray-200">Local Pickup</FormLabel>
                            <FormDescription className="text-gray-400">
                              Available for local pickup
                            </FormDescription>
                          </div>
                          <FormControl>
                            <Switch
                              checked={field.value}
                              onCheckedChange={field.onChange}
                            />
                          </FormControl>
                        </FormItem>
                      )}
                    />
                  </div>
                </TabsContent>
              </div>
            </Tabs>
            
            <DialogFooter className="border-t border-gray-800 pt-4 mt-4">
              <Button
                type="button"
                variant="outline"
                onClick={onClose}
                className="bg-gray-800 border-gray-700 text-white hover:bg-gray-700"
              >
                Cancel
              </Button>
              <Button
                type="submit"
                disabled={saveMutation.isPending}
                className="bg-blue-600 hover:bg-blue-700"
              >
                {saveMutation.isPending ? (
                  <>
                    <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    Saving...
                  </>
                ) : (
                  <>
                    <Save className="w-4 h-4 mr-2" />
                    {product ? 'Update Product' : 'Create Product'}
                  </>
                )}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
};
ISSUE 4: ANALYTICS SYSTEM COMPLETE OVERHAUL ðŸ”´
Backend Analytics Engine:
javascript
// /server/services/analytics.service.js
import { db } from '../db/index.js';
import { 
  activityLogs, 
  orders, 
  users, 
  products, 
  wishlist,
  cartItems 
} from '../db/schema.js';
import { sql, eq, and, gte, lte, desc, count, sum } from 'drizzle-orm';
import { startOfDay, endOfDay, subDays, format } from 'date-fns';

export class AnalyticsService {
  constructor() {
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
  }
  
  // Real-time activity tracking
  async trackActivity(userId, action, metadata = {}) {
    try {
      await db.insert(activityLogs).values({
        user_id: userId,
        action,
        resource: metadata.resource || null,
        resource_id: metadata.resourceId || null,
        metadata: JSON.stringify(metadata),
        ip_address: metadata.ip || null,
        user_agent: metadata.userAgent || null,
        created_at: new Date()
      });
      
      // Invalidate relevant caches
      this.invalidateCache(['dashboard', 'conversion']);
    } catch (error) {
      console.error('Activity tracking error:', error);
    }
  }
  
  // Dashboard metrics
  async getDashboardMetrics(dateRange = 30) {
    const cacheKey = `dashboard-${dateRange}`;
    
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (Date.now() - cached.timestamp < this.cacheTimeout) {
        return cached.data;
      }
    }
    
    const startDate = subDays(new Date(), dateRange);
    
    const [
      revenue,
      orderStats,
      userStats,
      productStats,
      conversionData
    ] = await Promise.all([
      this.getRevenueMetrics(startDate),
      this.getOrderMetrics(startDate),
      this.getUserMetrics(startDate),
      this.getProductMetrics(startDate),
      this.getConversionMetrics(startDate)
    ]);
    
    const metrics = {
      revenue,
      orders: orderStats,
      users: userStats,
      products: productStats,
      conversion: conversionData,
      timestamp: Date.now()
    };
    
    this.cache.set(cacheKey, { data: metrics, timestamp: Date.now() });
    
    return metrics;
  }
  
  // Revenue analytics
  async getRevenueMetrics(startDate) {
    const result = await db.select({
      total: sql`COALESCE(SUM(CAST(total_amount AS DECIMAL)), 0)`,
      count: count(),
      avgOrderValue: sql`COALESCE(AVG(CAST(total_amount AS DECIMAL)), 0)`,
      daily: sql`
        SELECT 
          DATE(created_at) as date,
          SUM(CAST(total_amount AS DECIMAL)) as revenue,
          COUNT(*) as orders
        FROM orders
        WHERE created_at >= ${startDate}
          AND status IN ('completed', 'processing')
        GROUP BY DATE(created_at)
        ORDER BY date DESC
      `
    })
    .from(orders)
    .where(
      and(
        gte(orders.created_at, startDate),
        sql`status IN ('completed', 'processing')`
      )
    );
    
    // Calculate growth
    const previousPeriod = await db.select({
      total: sql`COALESCE(SUM(CAST(total_amount AS DECIMAL)), 0)`
    })
    .from(orders)
    .where(
      and(
        gte(orders.created_at, subDays(startDate, 30)),
        lte(orders.created_at, startDate),
        sql`status IN ('completed', 'processing')`
      )
    );
    
    const growth = previousPeriod[0]?.total 
      ? ((result[0].total - previousPeriod[0].total) / previousPeriod[0].total) * 100
      : 0;
    
    return {
      total: parseFloat(result[0]?.total || 0),
      orderCount: result[0]?.count || 0,
      avgOrderValue: parseFloat(result[0]?.avgOrderValue || 0),
      growth: growth.toFixed(2),
      trend: result[0]?.daily || []
    };
  }
  
  // Order metrics
  async getOrderMetrics(startDate) {
    const statusBreakdown = await db.select({
      status: orders.status,
      count: count()
    })
    .from(orders)
    .where(gte(orders.created_at, startDate))
    .groupBy(orders.status);
    
    const fulfillmentRate = statusBreakdown.reduce((acc, curr) => {
      if (curr.status === 'completed') return acc + curr.count;
      return acc;
    }, 0) / (statusBreakdown.reduce((acc, curr) => acc + curr.count, 0) || 1);
    
    return {
      total: statusBreakdown.reduce((acc, curr) => acc + curr.count, 0),
      byStatus: statusBreakdown,
      fulfillmentRate: (fulfillmentRate * 100).toFixed(2),
      pending: statusBreakdown.find(s => s.status === 'pending')?.count || 0,
      processing: statusBreakdown.find(s => s.status === 'processing')?.count || 0,
      completed: statusBreakdown.find(s => s.status === 'completed')?.count || 0
    };
  }
  
  // User analytics
  async getUserMetrics(startDate) {
    const [
      totalUsers,
      newUsers,
      activeUsers,
      userActivity
    ] = await Promise.all([
      db.select({ count: count() }).from(users),
      
      db.select({ count: count() })
        .from(users)
        .where(gte(users.created_at, startDate)),
      
      db.select({ 
        count: sql`COUNT(DISTINCT user_id)` 
      })
      .from(activityLogs)
      .where(gte(activityLogs.created_at, startDate)),
      
      db.select({
        date: sql`DATE(created_at)`,
        signups: count()
      })
      .from(users)
      .where(gte(users.created_at, startDate))
      .groupBy(sql`DATE(created_at)`)
      .orderBy(desc(sql`DATE(created_at)`))
    ]);
    
    return {
      total: totalUsers[0]?.count || 0,
      new: newUsers[0]?.count || 0,
      active: activeUsers[0]?.count || 0,
      signupTrend: userActivity,
      churnRate: this.calculateChurnRate(totalUsers[0]?.count, activeUsers[0]?.count)
    };
  }
  
  // Product performance
  async getProductMetrics(startDate) {
    const [
      topProducts,
      lowStock,
      viewsVsSales
    ] = await Promise.all([
      // Top selling products
      db.select({
        product_id: sql`oi.product_id`,
        name: products.name,
        quantity_sold: sql`SUM(oi.quantity)`,
        revenue: sql`SUM(oi.quantity * oi.price)`
      })
      .from(sql`order_items oi`)
      .innerJoin(products, eq(sql`oi.product_id`, products.id))
      .innerJoin(orders, eq(sql`oi.order_id`, orders.id))
      .where(
        and(
          gte(orders.created_at, startDate),
          sql`orders.status IN ('completed', 'processing')`
        )
      )
      .groupBy(sql`oi.product_id`, products.name)
      .orderBy(desc(sql`SUM(oi.quantity)`))
      .limit(10),
      
      // Low stock alert
      db.select({
        id: products.id,
        name: products.name,
        stock: products.stock,
        sku: products.sku
      })
      .from(products)
      .where(
        and(
          eq(products.active, true),
          lte(products.stock, 5)
        )
      )
      .orderBy(products.stock),
      
      // Product views vs sales
      this.getProductConversionRates(startDate)
    ]);
    
    return {
      topSelling: topProducts,
      lowStock,
      conversionRates: viewsVsSales
    };
  }
  
  // Conversion funnel
  async getConversionMetrics(startDate) {
    const [
      visitors,
      addedToCart,
      initiatedCheckout,
      completed
    ] = await Promise.all([
      // Unique visitors
      db.select({ 
        count: sql`COUNT(DISTINCT COALESCE(user_id, ip_address))` 
      })
      .from(activityLogs)
      .where(
        and(
          gte(activityLogs.created_at, startDate),
          eq(activityLogs.action, 'page_view')
        )
      ),
      
      // Added to cart
      db.select({ 
        count: sql`COUNT(DISTINCT user_id)` 
      })
      .from(activityLogs)
      .where(
        and(
          gte(activityLogs.created_at, startDate),
          eq(activityLogs.action, 'add_to_cart')
        )
      ),
      
      // Started checkout
      db.select({ 
        count: sql`COUNT(DISTINCT user_id)` 
      })
      .from(activityLogs)
      .where(
        and(
          gte(activityLogs.created_at, startDate),
          eq(activityLogs.action, 'checkout_started')
        )
      ),
      
      // Completed orders
      db.select({ 
        count: sql`COUNT(DISTINCT user_id)` 
      })
      .from(orders)
      .where(
        and(
          gte(orders.created_at, startDate),
          eq(orders.status, 'completed')
        )
      )
    ]);
    
    const visitorCount = visitors[0]?.count || 1;
    const cartCount = addedToCart[0]?.count || 0;
    const checkoutCount = initiatedCheckout[0]?.count || 0;
    const completedCount = completed[0]?.count || 0;
    
    return {
      funnel: {
        visitors: visitorCount,
        addedToCart: cartCount,
        checkout: checkoutCount,
        completed: completedCount
      },
      rates: {
        cartRate: ((cartCount / visitorCount) * 100).toFixed(2),
        checkoutRate: ((checkoutCount / cartCount) * 100).toFixed(2),
        completionRate: ((completedCount / checkoutCount) * 100).toFixed(2),
        overallConversion: ((completedCount / visitorCount) * 100).toFixed(2)
      }
    };
  }
  
  // Wishlist analytics
  async getWishlistAnalytics() {
    const [
      totalWishlistItems,
      uniqueUsers,
      mostWishlisted,
      conversionFromWishlist,
      activityTrend
    ] = await Promise.all([
      db.select({ count: count() }).from(wishlist),
      
      db.select({ 
        count: sql`COUNT(DISTINCT user_id)` 
      }).from(wishlist),
      
      db.select({
        product_id: wishlist.product_id,
        name: products.name,
        image: products.image_url,
        price: products.price,
        wishlist_count: count()
      })
      .from(wishlist)
      .innerJoin(products, eq(wishlist.product_id, products.id))
      .groupBy(wishlist.product_id, products.name, products.image_url, products.price)
      .orderBy(desc(count()))
      .limit(10),
      
      // Wishlist to purchase conversion
      db.select({
        converted: sql`
          COUNT(DISTINCT w.user_id) FILTER (
            WHERE EXISTS (
              SELECT 1 FROM order_items oi
              JOIN orders o ON oi.order_id = o.id
              WHERE oi.product_id = w.product_id
              AND o.user_id = w.user_id
              AND o.created_at > w.created_at
            )
          )
        `,
        total: sql`COUNT(DISTINCT w.user_id)`
      })
      .from(sql`wishlist w`),
      
      // 30-day trend
      db.select({
        date: sql`DATE(created_at)`,
        additions: sql`COUNT(*) FILTER (WHERE created_at IS NOT NULL)`,
        removals: sql`COUNT(*) FILTER (WHERE deleted_at IS NOT NULL)`
      })
      .from(wishlist)
      .where(gte(wishlist.created_at, subDays(new Date(), 30)))
      .groupBy(sql`DATE(created_at)`)
      .orderBy(sql`DATE(created_at)`)
    ]);
    
    const conversionRate = conversionFromWishlist[0]?.total 
      ? (conversionFromWishlist[0].converted / conversionFromWishlist[0].total) * 100
      : 0;
    
    return {
      totalItems: totalWishlistItems[0]?.count || 0,
      uniqueUsers: uniqueUsers[0]?.count || 0,
      topProducts: mostWishlisted,
      conversionRate: conversionRate.toFixed(2),
      trend: activityTrend,
      avgItemsPerUser: uniqueUsers[0]?.count 
        ? (totalWishlistItems[0]?.count / uniqueUsers[0]?.count).toFixed(2)
        : 0
    };
  }
  
  // Helper methods
  calculateChurnRate(total, active) {
    if (!total) return 0;
    return (((total - active) / total) * 100).toFixed(2);
  }
  
  async getProductConversionRates(startDate) {
    return db.select({
      product_id: products.id,
      name: products.name,
      views: sql`
        COUNT(DISTINCT al.user_id) FILTER (
          WHERE al.action = 'product_view' 
          AND al.resource_id = products.id::text
        )
      `,
      purchases: sql`
        COUNT(DISTINCT o.user_id) FILTER (
          WHERE oi.product_id = products.id
        )
      `,
      conversion_rate: sql`
        CASE 
          WHEN COUNT(DISTINCT al.user_id) FILTER (
            WHERE al.action = 'product_view' 
            AND al.resource_id = products.id::text
          ) > 0
          THEN (
            COUNT(DISTINCT o.user_id) FILTER (
              WHERE oi.product_id = products.id
            )::float / 
            COUNT(DISTINCT al.user_id) FILTER (
              WHERE al.action = 'product_view' 
              AND al.resource_id = products.id::text
            )::float
          ) * 100
          ELSE 0
        END
      `
    })
    .from(products)
    .leftJoin(
      activityLogs,
      and(
        eq(activityLogs.action, 'product_view'),
        sql`activity_logs.resource_id = products.id::text`,
        gte(activityLogs.created_at, startDate)
      )
    )
    .leftJoin(
      sql`order_items oi`,
      eq(sql`oi.product_id`, products.id)
    )
    .leftJoin(
      orders,
      and(
        eq(sql`oi.order_id`, orders.id),
        gte(orders.created_at, startDate)
      )
    )
    .groupBy(products.id, products.name)
    .having(sql`COUNT(DISTINCT al.user_id) > 0`)
    .orderBy(desc(sql`conversion_rate`))
    .limit(20);
  }
  
  invalidateCache(keys = []) {
    if (keys.length === 0) {
      this.cache.clear();
    } else {
      keys.forEach(key => {
        for (const [cacheKey] of this.cache) {
          if (cacheKey.includes(key)) {
            this.cache.delete(cacheKey);
          }
        }
      });
    }
  }
}

export const analyticsService = new AnalyticsService();
Frontend Analytics Dashboard:
typescript
// /client/src/components/admin/AnalyticsDashboard.tsx
import React, { useState, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  PieChart,
  Pie,
  Cell,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  Area,
  AreaChart,
  RadarChart,
  PolarGrid,
  PolarAngleAxis,
  PolarRadiusAxis,
  Radar
} from 'recharts';
import { 
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle 
} from '@/components/ui/card';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from '@/components/ui/select';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import {
  TrendingUp,
  TrendingDown,
  DollarSign,
  Users,
  Package,
  ShoppingCart,
  Eye,
  Target,
  AlertCircle,
  Download,
  RefreshCw
} from 'lucide-react';
import { format, subDays } from 'date-fns';

const COLORS = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899'];

export const AnalyticsDashboard: React.FC = () => {
  const [dateRange, setDateRange] = useState('30');
  const [refreshKey, setRefreshKey] = useState(0);
  
  // Fetch analytics data
  const { data: analytics, isLoading, refetch } = useQuery({
    queryKey: ['analytics', dateRange, refreshKey],
    queryFn: async () => {
      const response = await fetch(`/api/admin/analytics?days=${dateRange}`);
      if (!response.ok) throw new Error('Failed to fetch analytics');
      return response.json();
    },
    refetchInterval: 60000 // Auto-refresh every minute
  });
  
  const handleExport = async (type: 'csv' | 'pdf') => {
    const response = await fetch(`/api/admin/analytics/export?format=${type}&days=${dateRange}`);
    const blob = await response.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `analytics-${format(new Date(), 'yyyy-MM-dd')}.${type}`;
    a.click();
  };
  
  const MetricCard = ({ title, value, change, icon: Icon, prefix = '', suffix = '' }: any) => (
    <Card className="bg-gray-800/50 border-gray-700">
      <CardHeader className="flex flex-row items-center justify-between pb-2">
        <CardTitle className="text-sm font-medium text-gray-400">{title}</CardTitle>
        <Icon className="w-4 h-4 text-gray-500" />
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold text-white">
          {prefix}{value}{suffix}
        </div>
        {change !== undefined && (
          <div className="flex items-center mt-2">
            {change >= 0 ? (
              <TrendingUp className="w-4 h-4 text-green-500 mr-1" />
            ) : (
              <TrendingDown className="w-4 h-4 text-red-500 mr-1" />
            )}
            <span className={`text-sm ${change >= 0 ? 'text-green-500' : 'text-red-500'}`}>
              {Math.abs(change)}%
            </span>
            <span className="text-sm text-gray-400 ml-1">vs last period</span>
          </div>
        )}
      </CardContent>
    </Card>
  );
  
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-96">
        <RefreshCw className="w-8 h-8 animate-spin text-gray-400" />
      </div>
    );
  }
  
  return (
    <div className="space-y-6">
      {/* Header Controls */}
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold text-white">Analytics Dashboard</h2>
        <div className="flex gap-4">
          <Select value={dateRange} onValueChange={setDateRange}>
            <SelectTrigger className="w-40 bg-gray-800 border-gray-700">
              <SelectValue />
            </SelectTrigger>
            <SelectContent className="bg-gray-800 border-gray-700">
              <SelectItem value="7">Last 7 days</SelectItem>
              <SelectItem value="30">Last 30 days</SelectItem>
              <SelectItem value="90">Last 90 days</SelectItem>
              <SelectItem value="365">Last year</SelectItem>
            </SelectContent>
          </Select>
          
          <Button
            onClick={() => {
              setRefreshKey(prev => prev + 1);
              refetch();
            }}
            variant="outline"
            className="bg-gray-800 border-gray-700"
          >
            <RefreshCw className="w-4 h-4 mr-2" />
            Refresh
          </Button>
          
          <Button
            onClick={() => handleExport('csv')}
            variant="outline"
            className="bg-gray-800 border-gray-700"
          >
            <Download className="w-4 h-4 mr-2" />
            Export
          </Button>
        </div>
      </div>
      
      {/* Key Metrics */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <MetricCard
          title="Total Revenue"
          value={analytics?.revenue?.total?.toLocaleString() || '0'}
          change={analytics?.revenue?.growth}
          icon={DollarSign}
          prefix="$"
        />
        <MetricCard
          title="Total Orders"
          value={analytics?.orders?.total || '0'}
          change={analytics?.orders?.growth}
          icon={ShoppingCart}
        />
        <MetricCard
          title="Conversion Rate"
          value={analytics?.conversion?.rates?.overallConversion || '0'}
          change={analytics?.conversion?.change}
          icon={Target}
          suffix="%"
        />
        <MetricCard
          title="Active Users"
          value={analytics?.users?.active || '0'}
          change={analytics?.users?.growth}
          icon={Users}
        />
      </div>
      
      {/* Charts Section */}
      <Tabs defaultValue="revenue" className="space-y-4">
        <TabsList className="bg-gray-800/50">
          <TabsTrigger value="revenue">Revenue</TabsTrigger>
          <TabsTrigger value="orders">Orders</TabsTrigger>
          <TabsTrigger value="conversion">Conversion</TabsTrigger>
          <TabsTrigger value="products">Products</TabsTrigger>
          <TabsTrigger value="users">Users</TabsTrigger>
        </TabsList>
        
        {/* Revenue Tab */}
        <TabsContent value="revenue" className="space-y-4">
          <Card className="bg-gray-800/50 border-gray-700">
            <CardHeader>
              <CardTitle>Revenue Trend</CardTitle>
              <CardDescription>Daily revenue over selected period</CardDescription>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={400}>
                <AreaChart data={analytics?.revenue?.trend || []}>
                  <defs>
                    <linearGradient id="colorRevenue" x1="0" y1="0" x2="0" y2="1">
                      <stop offset="5%" stopColor="#3B82F6" stopOpacity={0.8}/>
                      <stop offset="95%" stopColor="#3B82F6" stopOpacity={0}/>
                    </linearGradient>
                  </defs>
                  <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                  <XAxis 
                    dataKey="date" 
                    stroke="#9CA3AF"
                    tickFormatter={(date) => format(new Date(date), 'MMM dd')}
                  />
                  <YAxis stroke="#9CA3AF" />
                  <Tooltip 
                    contentStyle={{ backgroundColor: '#1F2937', border: 'none' }}
                    labelStyle={{ color: '#9CA3AF' }}
                  />
                  <Area 
                    type="monotone" 
                    dataKey="revenue" 
                    stroke="#3B82F6" 
                    fillOpacity={1} 
                    fill="url(#colorRevenue)" 
                  />
                </AreaChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        </TabsContent>
        
        {/* Conversion Funnel Tab */}
        <TabsContent value="conversion" className="space-y-4">
          <Card className="bg-gray-800/50 border-gray-700">
            <CardHeader>
              <CardTitle>Conversion Funnel</CardTitle>
              <CardDescription>User journey from visit to purchase</CardDescription>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={400}>
                <BarChart 
                  data={[
                    { stage: 'Visitors', count: analytics?.conversion?.funnel?.visitors || 0 },
                    { stage: 'Added to Cart', count: analytics?.conversion?.funnel?.addedToCart || 0 },
                    { stage: 'Checkout', count: analytics?.conversion?.funnel?.checkout || 0 },
                    { stage: 'Completed', count: analytics?.conversion?.funnel?.completed || 0 }
                  ]}
                  layout="vertical"
                >
                  <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                  <XAxis type="number" stroke="#9CA3AF" />
                  <YAxis dataKey="stage" type="category" stroke="#9CA3AF" />
                  <Tooltip 
                    contentStyle={{ backgroundColor: '#1F2937', border: 'none' }}
                  />
                  <Bar dataKey="count" fill="#3B82F6" />
                </BarChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        </TabsContent>
        
        {/* Products Performance Tab */}
        <TabsContent value="products" className="space-y-4">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            <Card className="bg-gray-800/50 border-gray-700">
              <CardHeader>
                <CardTitle>Top Selling Products</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  {analytics?.products?.topSelling?.map((product: any, index: number) => (
                    <div key={product.product_id} className="flex items-center justify-between">
                      <div className="flex items-center gap-3">
                        <span className="text-2xl font-bold text-gray-500">
                          #{index + 1}
                        </span>
                        <div>
                          <p className="text-white font-medium">{product.name}</p>
                          <p className="text-sm text-gray-400">
                            {product.quantity_sold} sold
                          </p>
                        </div>
                      </div>
                      <div className="text-right">
                        <p className="text-white font-medium">
                          ${parseFloat(product.revenue).toLocaleString()}
                        </p>
                      </div>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
            
            <Card className="bg-gray-800/50 border-gray-700">
              <CardHeader>
                <CardTitle>Low Stock Alert</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  {analytics?.products?.lowStock?.map((product: any) => (
                    <div key={product.id} className="flex items-center justify-between">
                      <div>
                        <p className="text-white font-medium">{product.name}</p>
                        <p className="text-sm text-gray-400">SKU: {product.sku}</p>
                      </div>
                      <Badge 
                        variant={product.stock === 0 ? 'destructive' : 'warning'}
                        className="bg-red-900/50"
                      >
                        {product.stock} left
                      </Badge>
                    </div>
                  ))}
                  {analytics?.products?.lowStock?.length === 0 && (
                    <p className="text-gray-400 text-center py-8">
                      All products are well stocked
                    </p>
                  )}
                </div>
              </CardContent>
            </Card>
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
};
ISSUE 5: API REQUEST OPTIMIZATION ðŸ”´
Request Deduplication & Caching System:
javascript
// /server/middleware/requestOptimizer.js
import crypto from 'crypto';
import LRU from 'lru-cache';

class RequestOptimizer {
  constructor() {
    this.cache = new LRU({
      max: 500,
      ttl: 1000 * 60 * 5, // 5 minutes
      updateAgeOnGet: true,
      updateAgeOnHas: true
    });
    
    this.pendingRequests = new Map();
    this.requestCounts = new Map();
    this.rateLimits = {
      default: { window: 60000, max: 100 },
      api: { window: 60000, max: 60 },
      admin: { window: 60000, max: 200 }
    };
  }
  
  // Generate cache key
  getCacheKey(req) {
    const data = {
      method: req.method,
      url: req.originalUrl,
      query: req.query,
      body: req.method === 'GET' ? undefined : req.body,
      userId: req.user?.id
    };
    
    return crypto
      .createHash('sha256')
      .update(JSON.stringify(data))
      .digest('hex');
  }
  
  // Middleware for request deduplication
  deduplicate() {
    return async (req, res, next) => {
      // Skip non-GET requests
      if (req.method !== 'GET') return next();
      
      const key = this.getCacheKey(req);
      
      // Check cache first
      if (this.cache.has(key)) {
        const cached = this.cache.get(key);
        console.log(`[CACHE HIT] ${req.originalUrl}`);
        return res.json(cached);
      }
      
      // Check for pending request
      if (this.pendingRequests.has(key)) {
        console.log(`[DEDUP] Waiting for pending request: ${req.originalUrl}`);
        
        try {
          const result = await this.pendingRequests.get(key);
          return res.json(result);
        } catch (error) {
          return next(error);
        }
      }
      
      // Create new pending request
      const pendingPromise = new Promise((resolve, reject) => {
        const originalJson = res.json.bind(res);
        const originalStatus = res.status.bind(res);
        
        res.json = (data) => {
          this.cache.set(key, data);
          this.pendingRequests.delete(key);
          resolve(data);
          return originalJson(data);
        };
        
        res.status = (code) => {
          if (code >= 400) {
            this.pendingRequests.delete(key);
            reject(new Error(`Request failed with status ${code}`));
          }
          return originalStatus(code);
        };
        
        next();
      });
      
      this.pendingRequests.set(key, pendingPromise);
    };
  }
  
  // Rate limiting per route
  rateLimit(type = 'default') {
    const limits = this.rateLimits[type] || this.rateLimits.default;
    
    return (req, res, next) => {
      const key = `${req.ip}-${type}`;
      const now = Date.now();
      
      if (!this.requestCounts.has(key)) {
        this.requestCounts.set(key, { count: 0, resetTime: now + limits.window });
      }
      
      const record = this.requestCounts.get(key);
      
      if (now > record.resetTime) {
        record.count = 0;
        record.resetTime = now + limits.window;
      }
      
      record.count++;
      
      if (record.count > limits.max) {
        return res.status(429).json({
          error: 'Too many requests',
          retryAfter: Math.ceil((record.resetTime - now) / 1000)
        });
      }
      
      res.set({
        'X-RateLimit-Limit': limits.max,
        'X-RateLimit-Remaining': limits.max - record.count,
        'X-RateLimit-Reset': new Date(record.resetTime).toISOString()
      });
      
      next();
    };
  }
  
  // Clear cache for specific patterns
  invalidate(pattern) {
    const keys = [...this.cache.keys()];
    let cleared = 0;
    
    keys.forEach(key => {
      if (!pattern || key.includes(pattern)) {
        this.cache.delete(key);
        cleared++;
      }
    });
    
    console.log(`[CACHE] Cleared ${cleared} entries`);
    return cleared;
  }
}

export const requestOptimizer = new RequestOptimizer();

// Apply to Express app
app.use('/api', requestOptimizer.deduplicate());
app.use('/api', requestOptimizer.rateLimit('api'));
app.use('/api/admin', requestOptimizer.rateLimit('admin'));
ISSUE 6: COMPLETE USERS TAB REBUILD ðŸ”´
typescript
// /client/src/components/admin/UsersManagement.tsx
import React, { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  getFilteredRowModel,
  useReactTable,
  SortingState,
  ColumnFiltersState
} from '@tanstack/react-table';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow
} from '@/components/ui/table';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger
} from '@/components/ui/dropdown-menu';
import { Badge } from '@/components/ui/badge';
import { Checkbox } from '@/components/ui/checkbox';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle
} from '@/components/ui/card';
import {
  Users,
  Search,
  Filter,
  MoreHorizontal,
  Download,
  UserPlus,
  Mail,
  Shield,
  ShoppingCart,
  Calendar,
  MapPin,
  Activity,
  TrendingUp,
  UserCheck,
  UserX,
  RefreshCw
} from 'lucide-react';
import { format } from 'date-fns';
import { toast } from 'sonner';

interface User {
  id: string;
  name: string;
  email: string;
  role: 'customer' | 'admin' | 'developer';
  status: 'active' | 'inactive' | 'suspended';
  created_at: string;
  last_login: string;
  total_orders: number;
  total_spent: number;
  location?: string;
}

export const UsersManagement: React.FC = () => {
  const [sorting, setSorting] = useState<SortingState>([]);
  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);
  const [rowSelection, setRowSelection] = useState({});
  const [globalFilter, setGlobalFilter] = useState('');
  
  const queryClient = useQueryClient();
  
  // Fetch users
  const { data: usersData, isLoading } = useQuery({
    queryKey: ['users', globalFilter],
    queryFn: async () => {
      const response = await fetch(`/api/admin/users?search=${globalFilter}`);
      if (!response.ok) throw new Error('Failed to fetch users');
      return response.json();
    }
  });
  
  // User actions
  const updateUserMutation = useMutation({
    mutationFn: async ({ userId, updates }: any) => {
      const response = await fetch(`/api/admin/users/${userId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      if (!response.ok) throw new Error('Failed to update user');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] });
      toast.success('User updated successfully');
    }
  });
  
  // Bulk actions
  const bulkActionMutation = useMutation({
    mutationFn: async ({ action, userIds }: any) => {
      const response = await fetch('/api/admin/users/bulk', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action, userIds })
      });
      if (!response.ok) throw new Error('Bulk action failed');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] });
      setRowSelection({});
      toast.success('Bulk action completed');
    }
  });
  
  // Table columns
  const columns: ColumnDef<User>[] = [
    {
      id: 'select',
      header: ({ table }) => (
        <Checkbox
          checked={table.getIsAllPageRowsSelected()}
          onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}
          aria-label="Select all"
          className="border-gray-600"
        />
      ),
      cell: ({ row }) => (
        <Checkbox
          checked={row.getIsSelected()}
          onCheckedChange={(value) => row.toggleSelected(!!value)}
          aria-label="Select row"
          className="border-gray-600"
        />
      ),
      enableSorting: false,
      enableHiding: false
    },
    {
      accessorKey: 'name',
      header: 'User',
      cell: ({ row }) => (
        <div className="flex items-center gap-3">
          <div className="w-10 h-10 rounded-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center text-white font-semibold">
            {row.original.name.charAt(0).toUpperCase()}
          </div>
          <div>
            <p className="font-medium text-white">{row.original.name}</p>
            <p className="text-sm text-gray-400">{row.original.email}</p>
          </div>
        </div>
      )
    },
    {
      accessorKey: 'role',
      header: 'Role',
      cell: ({ row }) => {
        const role = row.original.role;
        return (
          <Badge 
            className={
              role === 'admin' 
                ? 'bg-purple-900/50 text-purple-300'
                : role === 'developer'
                ? 'bg-blue-900/50 text-blue-300'
                : 'bg-gray-700 text-gray-300'
            }
          >
            <Shield className="w-3 h-3 mr-1" />
            {role}
          </Badge>
        );
      }
    },
    {
      accessorKey: 'status',
      header: 'Status',
      cell: ({ row }) => {
        const status = row.original.status;
        return (
          <Badge 
            className={
              status === 'active'
                ? 'bg-green-900/50 text-green-300'
                : status === 'suspended'
                ? 'bg-red-900/50 text-red-300'
                : 'bg-yellow-900/50 text-yellow-300'
            }
          >
            {status === 'active' ? (
              <UserCheck className="w-3 h-3 mr-1" />
            ) : (
              <UserX className="w-3 h-3 mr-1" />
            )}
            {status}
          </Badge>
        );
      }
    },
    {
      accessorKey: 'total_orders',
      header: 'Orders',
      cell: ({ row }) => (
        <div className="flex items-center gap-2">
          <ShoppingCart className="w-4 h-4 text-gray-400" />
          <span className="text-white">{row.original.total_orders}</span>
        </div>
      )
    },
    {
      accessorKey: 'total_spent',
      header: 'Total Spent',
      cell: ({ row }) => (
        <span className="text-white font-medium">
          ${row.original.total_spent.toLocaleString()}
        </span>
      )
    },
    {
      accessorKey: 'last_login',
      header: 'Last Active',
      cell: ({ row }) => (
        <div className="text-sm text-gray-400">
          {row.original.last_login 
            ? format(new Date(row.original.last_login), 'MMM dd, yyyy')
            : 'Never'
          }
        </div>
      )
    },
    {
      accessorKey: 'created_at',
      header: 'Joined',
      cell: ({ row }) => (
        <div className="text-sm text-gray-400">
          {format(new Date(row.original.created_at), 'MMM dd, yyyy')}
        </div>
      )
    },
    {
      id: 'actions',
      cell: ({ row }) => (
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" className="h-8 w-8 p-0">
              <MoreHorizontal className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end" className="bg-gray-800 border-gray-700">
            <DropdownMenuLabel className="text-gray-300">Actions</DropdownMenuLabel>
            <DropdownMenuItem 
              onClick={() => window.location.href = `/admin/users/${row.original.id}`}
              className="text-gray-300 hover:bg-gray-700"
            >
              View Details
            </DropdownMenuItem>
            <DropdownMenuItem 
              onClick={() => {/* Open edit modal */}}
              className="text-gray-300 hover:bg-gray-700"
            >
              Edit User
            </DropdownMenuItem>
            <DropdownMenuSeparator className="bg-gray-700" />
            <DropdownMenuItem 
              onClick={() => updateUserMutation.mutate({
                userId: row.original.id,
                updates: { status: row.original.status === 'active' ? 'suspended' : 'active' }
              })}
              className="text-gray-300 hover:bg-gray-700"
            >
              {row.original.status === 'active' ? 'Suspend' : 'Activate'}
            </DropdownMenuItem>
            <DropdownMenuItem 
              onClick={() => {/* Send email */}}
              className="text-gray-300 hover:bg-gray-700"
            >
              <Mail className="w-4 h-4 mr-2" />
              Send Email
            </DropdownMenuItem>
            <DropdownMenuItem 
              onClick={() => {/* Reset password */}}
              className="text-red-400 hover:bg-gray-700"
            >
              Reset Password
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      )
    }
  ];
  
  // Table instance
  const table = useReactTable({
    data: usersData?.users || [],
    columns,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    onSortingChange: setSorting,
    onColumnFiltersChange: setColumnFilters,
    onRowSelectionChange: setRowSelection,
    state: {
      sorting,
      columnFilters,
      rowSelection,
      globalFilter
    }
  });
  
  const selectedCount = Object.keys(rowSelection).length;
  
  return (
    <div className="space-y-6">
      {/* Stats Cards */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card className="bg-gray-800/50 border-gray-700">
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium text-gray-400">Total Users</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-white">{usersData?.stats?.total || 0}</div>
            <p className="text-xs text-gray-400 mt-1">
              <TrendingUp className="w-3 h-3 inline mr-1 text-green-500" />
              +{usersData?.stats?.newThisMonth || 0} this month
            </p>
          </CardContent>
        </Card>
        
        <Card className="bg-gray-800/50 border-gray-700">
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium text-gray-400">Active Users</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-white">{usersData?.stats?.active || 0}</div>
            <p className="text-xs text-gray-400 mt-1">Last 30 days</p>
          </CardContent>
        </Card>
        
        <Card className="bg-gray-800/50 border-gray-700">
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium text-gray-400">Total Revenue</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-white">
              ${usersData?.stats?.totalRevenue?.toLocaleString() || '0'}
            </div>
            <p className="text-xs text-gray-400 mt-1">From all users</p>
          </CardContent>
        </Card>
        
        <Card className="bg-gray-800/50 border-gray-700">
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium text-gray-400">Avg Order Value</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-white">
              ${usersData?.stats?.avgOrderValue?.toFixed(2) || '0'}
            </div>
            <p className="text-xs text-gray-400 mt-1">Per user</p>
          </CardContent>
        </Card>
      </div>
      
      {/* Table Controls */}
      <Card className="bg-gray-800/50 border-gray-700">
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="text-white">User Management</CardTitle>
              <CardDescription>Manage customer accounts and permissions</CardDescription>
            </div>
            <div className="flex gap-2">
              <Button
                onClick={() => {/* Open invite modal */}}
                className="bg-blue-600 hover:bg-blue-700"
              >
                <UserPlus className="w-4 h-4 mr-2" />
                Invite User
              </Button>
              <Button
                onClick={() => {/* Export users */}}
                variant="outline"
                className="bg-gray-700 border-gray-600"
              >
                <Download className="w-4 h-4 mr-2" />
                Export
              </Button>
            </div>
          </div>
        </CardHeader>
        
        <CardContent>
          {/* Search and Filters */}
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-4 flex-1">
              <div className="relative flex-1 max-w-sm">
                <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400" />
                <Input
                  placeholder="Search users..."
                  value={globalFilter}
                  onChange={(e) => setGlobalFilter(e.target.value)}
                  className="pl-10 bg-gray-700 border-gray-600 text-white"
                />
              </div>
              
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" className="bg-gray-700 border-gray-600">
                    <Filter className="w-4 h-4 mr-2" />
                    Filters
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent className="bg-gray-800 border-gray-700">
                  <DropdownMenuItem className="text-gray-300">Active Users</DropdownMenuItem>
                  <DropdownMenuItem className="text-gray-300">New Users</DropdownMenuItem>
                  <DropdownMenuItem className="text-gray-300">High Value</DropdownMenuItem>
                  <DropdownMenuItem className="text-gray-300">Inactive</DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
            
            {selectedCount > 0 && (
              <div className="flex items-center gap-2">
                <span className="text-sm text-gray-400">
                  {selectedCount} selected
                </span>
                <Button
                  onClick={() => bulkActionMutation.mutate({
                    action: 'suspend',
                    userIds: Object.keys(rowSelection)
                  })}
                  variant="outline"
                  size="sm"
                  className="bg-gray-700 border-gray-600"
                >
                  Bulk Actions
                </Button>
              </div>
            )}
          </div>
          
          {/* Users Table */}
          <div className="rounded-md border border-gray-700">
            <Table>
              <TableHeader>
                {table.getHeaderGroups().map((headerGroup) => (
                  <TableRow key={headerGroup.id} className="border-gray-700">
                    {headerGroup.headers.map((header) => (
                      <TableHead key={header.id} className="text-gray-300">
                        {header.isPlaceholder
                          ? null
                          : flexRender(
                              header.column.columnDef.header,
                              header.getContext()
                            )}
                      </TableHead>
                    ))}
                  </TableRow>
                ))}
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={columns.length} className="text-center py-8">
                      <RefreshCw className="w-6 h-6 animate-spin mx-auto text-gray-400" />
                    </TableCell>
                  </TableRow>
                ) : table.getRowModel().rows?.length ? (
                  table.getRowModel().rows.map((row) => (
                    <TableRow
                      key={row.id}
                      data-state={row.getIsSelected() && "selected"}
                      className="border-gray-700"
                    >
                      {row.getVisibleCells().map((cell) => (
                        <TableCell key={cell.id}>
                          {flexRender(cell.column.columnDef.cell, cell.getContext())}
                        </TableCell>
                      ))}
                    </TableRow>
                  ))
                ) : (
                  <TableRow>
                    <TableCell colSpan={columns.length} className="text-center py-8 text-gray-400">
                      No users found
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
          </div>
          
          {/* Pagination */}
          <div className="flex items-center justify-between mt-4">
            <div className="text-sm text-gray-400">
              Showing {table.getState().pagination.pageIndex * table.getState().pagination.pageSize + 1} to{' '}
              {Math.min(
                (table.getState().pagination.pageIndex + 1) * table.getState().pagination.pageSize,
                usersData?.total || 0
              )}{' '}
              of {usersData?.total || 0} users
            </div>
            <div className="flex gap-2">
              <Button
                onClick={() => table.previousPage()}
                disabled={!table.getCanPreviousPage()}
                variant="outline"
                size="sm"
                className="bg-gray-700 border-gray-600"
              >
                Previous
              </Button>
              <Button
                onClick={() => table.nextPage()}
                disabled={!table.getCanNextPage()}
                variant="outline"
                size="sm"
                className="bg-gray-700 border-gray-600"
              >
                Next
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};
ðŸš€ DEPLOYMENT STRATEGY
Phase 1: Database & Backend (Day 1)
bash
# 1. Backup database
pg_dump $DATABASE_URL > backup_$(date +%Y%m%d).sql

# 2. Run migrations
npm run db:generate
npm run db:migrate

# 3. Update API endpoints
git checkout -b fix/backend-issues
# Apply all backend fixes
npm test
git commit -m "fix: backend issues and database schema"
Phase 2: Frontend Components (Day 2)
bash
# 1. Update components
git checkout -b fix/frontend-components
# Apply all frontend fixes
npm run build
npm run test:e2e

# 2. Test locally
npm run dev
# Manual testing checklist

git commit -m "fix: rebuild admin dashboard components"
Phase 3: Optimization & Caching (Day 3)
bash
# 1. Implement caching layers
npm install lru-cache @tanstack/react-query
# Apply optimization code

# 2. Performance testing
npm run lighthouse
npm run bundle-analyze

git commit -m "perf: implement caching and request optimization"
Phase 4: Production Deploy
bash
# 1. Merge to main
git checkout main
git merge fix/backend-issues
git merge fix/frontend-components

# 2. Deploy
npm run build
npm run deploy

# 3. Monitor
npm run monitor:errors
npm run monitor:performance
ðŸ“Š TESTING CHECKLIST
Backend Tests
 Equipment submissions API works
 Image URLs update without caching
 Analytics data populates correctly
 API requests are deduplicated
 Rate limiting works properly
 Database queries are optimized
Frontend Tests
 Product edit modal saves correctly
 Users tab displays all data
 Analytics charts render properly
 Wishlist analytics show data
 No console errors
 Mobile responsive
Performance Tests
 Page load time < 3s
 API response time < 200ms
 Image load time < 1s
 No memory leaks
 Bundle size < 500KB
ðŸŽ¯ SUCCESS METRICS
After implementing all fixes, you should see:

Zero console errors
All tabs loading in < 500ms
Analytics showing real data
Images updating immediately
50% reduction in API calls
Consistent dark theme UI
All CRUD operations working
Mobile-responsive admin panel
This comprehensive overhaul will transform your Clean & Flip marketplace into a production-ready, high-performance e-commerce platform with a professional admin dashboard that matches modern standards.