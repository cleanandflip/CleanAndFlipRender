# Complete Password Reset System Fix for Clean & Flip

## Issue Summary
1. **User not found** - Query returning 0 even though email exists
2. **Missing table** - `password_reset_tokens` table doesn't exist
3. **Duplicate emails** - Multiple reset attempts
4. **Email delays** - 4-5 minute delivery time

## Step 1: Create Missing Database Table

### Create `/server/db/migrations/create-password-reset-tokens.sql`:

```sql
-- Create password_reset_tokens table
CREATE TABLE IF NOT EXISTS password_reset_tokens (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token VARCHAR(255) NOT NULL UNIQUE,
  expires_at TIMESTAMP NOT NULL,
  used BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW(),
  used_at TIMESTAMP,
  ip_address VARCHAR(45),
  user_agent TEXT
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_token ON password_reset_tokens(token);
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_user_id ON password_reset_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_expires_at ON password_reset_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_password_reset_used ON password_reset_tokens(used) WHERE used = false;

-- Clean up any old tokens
DELETE FROM password_reset_tokens WHERE expires_at < NOW();
```

### Run the migration immediately:
```bash
psql $DATABASE_URL < server/db/migrations/create-password-reset-tokens.sql
```

## Step 2: Fix User Email Lookup

### Create `/server/utils/user-lookup.ts`:

```typescript
import { db } from '../db';
import { sql } from 'drizzle-orm';

/**
 * Find user by email with multiple fallback strategies
 */
export async function findUserByEmail(email: string): Promise<any | null> {
  if (!email) return null;
  
  // Multiple normalization strategies
  const normalizations = [
    email.toLowerCase().trim(),                    // Standard normalization
    email.trim(),                                  // Case-sensitive trim
    email.toLowerCase(),                           // Just lowercase
    email,                                         // Exact as provided
    email.replace(/\s+/g, ''),                    // Remove all spaces
    email.toLowerCase().replace(/\s+/g, ''),      // Lowercase + remove spaces
  ];
  
  // Remove duplicates
  const uniqueEmails = [...new Set(normalizations)];
  
  console.log('[DEBUG] Trying email variations:', uniqueEmails);
  
  for (const emailVariant of uniqueEmails) {
    try {
      // Try raw SQL first (most reliable)
      const result = await db.execute(sql`
        SELECT id, email, name, password, role, created_at
        FROM users
        WHERE email = ${emailVariant}
        LIMIT 1
      `);
      
      if (result.rows.length > 0) {
        console.log('[DEBUG] User found with email variant:', emailVariant);
        return result.rows[0];
      }
    } catch (error) {
      console.error('[DEBUG] Query error for variant:', emailVariant, error.message);
    }
  }
  
  // If still not found, try case-insensitive search
  try {
    const result = await db.execute(sql`
      SELECT id, email, name, password, role, created_at
      FROM users
      WHERE LOWER(TRIM(email)) = LOWER(TRIM(${email}))
      LIMIT 1
    `);
    
    if (result.rows.length > 0) {
      console.log('[DEBUG] User found with case-insensitive search');
      return result.rows[0];
    }
  } catch (error) {
    console.error('[DEBUG] Case-insensitive search error:', error.message);
  }
  
  // Last resort: partial match (dangerous but helps debug)
  if (process.env.NODE_ENV === 'development') {
    try {
      const result = await db.execute(sql`
        SELECT id, email, name
        FROM users
        WHERE email ILIKE ${`%${email.trim()}%`}
        LIMIT 5
      `);
      
      if (result.rows.length > 0) {
        console.log('[DEBUG] Partial matches found:', result.rows.map(r => r.email));
      }
    } catch (error) {
      console.error('[DEBUG] Partial match error:', error.message);
    }
  }
  
  return null;
}

/**
 * Debug function to list all user emails
 */
export async function debugListEmails(): Promise<string[]> {
  try {
    const result = await db.execute(sql`
      SELECT email, LENGTH(email) as len, created_at
      FROM users
      ORDER BY created_at DESC
      LIMIT 20
    `);
    
    return result.rows.map(r => `${r.email} (length: ${r.len})`);
  } catch (error) {
    console.error('[DEBUG] Error listing emails:', error);
    return [];
  }
}
```

## Step 3: Complete Password Reset Service Rewrite

### Replace `/server/services/password-reset.service.ts`:

```typescript
import crypto from 'crypto';
import bcrypt from 'bcrypt';
import { db } from '../db';
import { sql } from 'drizzle-orm';
import { emailService } from './email.service';
import { findUserByEmail } from '../utils/user-lookup';

export class PasswordResetService {
  private static readonly TOKEN_LENGTH = 32;
  private static readonly TOKEN_EXPIRY_HOURS = 1;
  private static readonly RATE_LIMIT_MINUTES = 2;
  
  // In-memory rate limiting (replace with Redis in production)
  private static rateLimitMap = new Map<string, Date>();
  
  /**
   * Request password reset with deduplication
   */
  static async requestPasswordReset(
    email: string, 
    ipAddress: string, 
    userAgent: string
  ): Promise<{ success: boolean; message: string; debugInfo?: any }> {
    const startTime = Date.now();
    
    try {
      // Rate limiting check
      const rateLimitKey = `${email}:${ipAddress}`;
      const lastRequest = this.rateLimitMap.get(rateLimitKey);
      
      if (lastRequest) {
        const minutesSinceLastRequest = (Date.now() - lastRequest.getTime()) / 60000;
        if (minutesSinceLastRequest < this.RATE_LIMIT_MINUTES) {
          console.log(`[RATE_LIMIT] Too many requests for ${email} from ${ipAddress}`);
          return { 
            success: true, 
            message: 'If an account exists, reset email sent',
            debugInfo: { rateLimited: true }
          };
        }
      }
      
      // Update rate limit
      this.rateLimitMap.set(rateLimitKey, new Date());
      
      // Find user with improved lookup
      console.log(`[PASSWORD_RESET] Starting reset process for: ${email}`);
      const user = await findUserByEmail(email);
      
      if (!user) {
        console.log(`[PASSWORD_RESET] No user found for email: ${email}`);
        // Still return success to prevent email enumeration
        return { 
          success: true, 
          message: 'If an account exists, reset email sent',
          debugInfo: { userFound: false }
        };
      }
      
      console.log(`[PASSWORD_RESET] User found: ID ${user.id}, Email: ${user.email}`);
      
      // Check for existing valid token to prevent duplicates
      const existingTokenResult = await db.execute(sql`
        SELECT id, created_at 
        FROM password_reset_tokens
        WHERE user_id = ${user.id}
          AND used = false
          AND expires_at > NOW()
        ORDER BY created_at DESC
        LIMIT 1
      `);
      
      if (existingTokenResult.rows.length > 0) {
        const tokenAge = (Date.now() - new Date(existingTokenResult.rows[0].created_at).getTime()) / 60000;
        if (tokenAge < 5) { // Token created less than 5 minutes ago
          console.log(`[PASSWORD_RESET] Recent token exists, skipping email`);
          return { 
            success: true, 
            message: 'If an account exists, reset email sent',
            debugInfo: { recentTokenExists: true, tokenAge }
          };
        }
      }
      
      // Invalidate all old tokens for this user
      await db.execute(sql`
        UPDATE password_reset_tokens
        SET used = true, used_at = NOW()
        WHERE user_id = ${user.id} AND used = false
      `);
      
      // Generate new token
      const rawToken = crypto.randomBytes(this.TOKEN_LENGTH).toString('hex');
      const hashedToken = await bcrypt.hash(rawToken, 10);
      
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + this.TOKEN_EXPIRY_HOURS);
      
      // Insert new token
      await db.execute(sql`
        INSERT INTO password_reset_tokens (user_id, token, expires_at, ip_address, user_agent)
        VALUES (${user.id}, ${hashedToken}, ${expiresAt}, ${ipAddress}, ${userAgent})
      `);
      
      // Generate reset link
      const baseUrl = process.env.NODE_ENV === 'production' 
        ? 'https://cleanandflip.com'
        : process.env.FRONTEND_URL || 'http://localhost:5173';
        
      const resetLink = `${baseUrl}/reset-password?token=${rawToken}&email=${encodeURIComponent(user.email)}`;
      
      console.log(`[PASSWORD_RESET] Generated reset link for user ${user.id}`);
      
      // Send email immediately
      try {
        await emailService.sendPasswordResetEmail({
          to: user.email,
          userName: user.name || 'Customer',
          resetLink,
          ipAddress,
          userAgent,
          expiresIn: '1 hour'
        });
        
        const elapsed = Date.now() - startTime;
        console.log(`[PASSWORD_RESET] Email sent successfully in ${elapsed}ms`);
        
      } catch (emailError) {
        console.error('[PASSWORD_RESET] Email send error:', emailError);
        // Don't expose email errors to user
      }
      
      return { 
        success: true, 
        message: 'If an account exists, reset email sent',
        debugInfo: { 
          userFound: true, 
          emailSent: true,
          elapsed: Date.now() - startTime 
        }
      };
      
    } catch (error) {
      console.error('[PASSWORD_RESET] Unexpected error:', error);
      // Still return success to prevent information leakage
      return { 
        success: true, 
        message: 'If an account exists, reset email sent',
        debugInfo: { error: error.message }
      };
    }
  }
  
  /**
   * Validate reset token
   */
  static async validateResetToken(token: string, email?: string): Promise<{
    valid: boolean;
    userId?: number;
    email?: string;
    error?: string;
  }> {
    try {
      if (!token) {
        return { valid: false, error: 'No token provided' };
      }
      
      // Get all non-expired, unused tokens
      const tokensResult = await db.execute(sql`
        SELECT 
          prt.id,
          prt.user_id,
          prt.token,
          prt.expires_at,
          u.email
        FROM password_reset_tokens prt
        JOIN users u ON u.id = prt.user_id
        WHERE prt.used = false
          AND prt.expires_at > NOW()
      `);
      
      // Check each token
      for (const row of tokensResult.rows) {
        const isValid = await bcrypt.compare(token, row.token);
        
        if (isValid) {
          // If email provided, verify it matches
          if (email && row.email.toLowerCase() !== email.toLowerCase()) {
            return { valid: false, error: 'Token and email mismatch' };
          }
          
          return {
            valid: true,
            userId: row.user_id,
            email: row.email
          };
        }
      }
      
      return { valid: false, error: 'Invalid or expired token' };
      
    } catch (error) {
      console.error('[TOKEN_VALIDATION] Error:', error);
      return { valid: false, error: 'Token validation failed' };
    }
  }
  
  /**
   * Reset password
   */
  static async resetPassword(
    token: string,
    newPassword: string,
    email: string,
    ipAddress: string
  ): Promise<{ success: boolean; message: string }> {
    try {
      // Validate token
      const validation = await this.validateResetToken(token, email);
      
      if (!validation.valid || !validation.userId) {
        return { 
          success: false, 
          message: validation.error || 'Invalid or expired token' 
        };
      }
      
      // Hash new password
      const hashedPassword = await bcrypt.hash(newPassword, 12);
      
      // Update password
      await db.execute(sql`
        UPDATE users
        SET password = ${hashedPassword}, updated_at = NOW()
        WHERE id = ${validation.userId}
      `);
      
      // Mark token as used
      await db.execute(sql`
        UPDATE password_reset_tokens
        SET used = true, used_at = NOW()
        WHERE user_id = ${validation.userId} AND used = false
      `);
      
      console.log(`[PASSWORD_RESET] Password successfully reset for user ${validation.userId}`);
      
      // Send confirmation email
      try {
        await emailService.sendPasswordResetSuccessEmail({
          to: validation.email!,
          ipAddress,
          timestamp: new Date().toISOString()
        });
      } catch (emailError) {
        console.error('[PASSWORD_RESET] Confirmation email error:', emailError);
      }
      
      return { 
        success: true, 
        message: 'Password successfully reset' 
      };
      
    } catch (error) {
      console.error('[PASSWORD_RESET] Reset error:', error);
      return { 
        success: false, 
        message: 'Failed to reset password' 
      };
    }
  }
  
  /**
   * Clean up expired tokens (run periodically)
   */
  static async cleanupExpiredTokens(): Promise<number> {
    try {
      const result = await db.execute(sql`
        DELETE FROM password_reset_tokens
        WHERE expires_at < NOW() OR used = true
      `);
      
      return result.rowCount || 0;
    } catch (error) {
      console.error('[PASSWORD_RESET] Cleanup error:', error);
      return 0;
    }
  }
}
```

## Step 4: Update API Routes

### Update `/server/routes/auth.ts`:

```typescript
import { PasswordResetService } from '../services/password-reset.service';
import { debugListEmails } from '../utils/user-lookup';

// Password reset request
router.post('/api/auth/forgot-password', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email || typeof email !== 'string') {
      return res.status(400).json({ 
        success: false, 
        error: 'Email is required' 
      });
    }
    
    const ipAddress = req.ip || req.connection.remoteAddress || 'unknown';
    const userAgent = req.headers['user-agent'] || 'unknown';
    
    console.log(`[API] Password reset request from ${ipAddress} for ${email}`);
    
    const result = await PasswordResetService.requestPasswordReset(
      email,
      ipAddress,
      userAgent
    );
    
    // In development, include debug info
    if (process.env.NODE_ENV === 'development' && result.debugInfo) {
      console.log('[API] Debug info:', result.debugInfo);
    }
    
    // Always return the same response to prevent email enumeration
    res.json({ 
      success: true, 
      message: result.message 
    });
    
  } catch (error) {
    console.error('[API] Password reset error:', error);
    // Still return success to prevent information leakage
    res.json({ 
      success: true, 
      message: 'If an account exists, reset email sent' 
    });
  }
});

// Token validation
router.post('/api/auth/validate-reset-token', async (req, res) => {
  try {
    const { token, email } = req.body;
    
    const result = await PasswordResetService.validateResetToken(token, email);
    
    res.json(result);
  } catch (error) {
    console.error('[API] Token validation error:', error);
    res.json({ valid: false, error: 'Validation failed' });
  }
});

// Password reset
router.post('/api/auth/reset-password', async (req, res) => {
  try {
    const { token, email, password } = req.body;
    
    // Validate inputs
    if (!token || !email || !password) {
      return res.status(400).json({ 
        success: false, 
        error: 'All fields are required' 
      });
    }
    
    if (password.length < 8) {
      return res.status(400).json({ 
        success: false, 
        error: 'Password must be at least 8 characters' 
      });
    }
    
    const ipAddress = req.ip || req.connection.remoteAddress || 'unknown';
    
    const result = await PasswordResetService.resetPassword(
      token,
      password,
      email,
      ipAddress
    );
    
    res.json(result);
  } catch (error) {
    console.error('[API] Password reset error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to reset password' 
    });
  }
});

// Debug endpoint (remove in production)
if (process.env.NODE_ENV !== 'production') {
  router.get('/api/debug/list-emails', async (req, res) => {
    const emails = await debugListEmails();
    res.json({ emails });
  });
}
```

## Step 5: Add Cleanup Job

### Add to `/server/index.ts`:

```typescript
// Run cleanup every hour
setInterval(async () => {
  try {
    const deleted = await PasswordResetService.cleanupExpiredTokens();
    if (deleted > 0) {
      console.log(`[CLEANUP] Removed ${deleted} expired password reset tokens`);
    }
  } catch (error) {
    console.error('[CLEANUP] Error cleaning up tokens:', error);
  }
}, 60 * 60 * 1000); // Every hour
```

## Step 6: Email Service Optimization

### Update `/server/services/email.service.ts`:

```typescript
// Ensure immediate sending for password reset emails
async sendPasswordResetEmail(options: PasswordResetEmailOptions) {
  try {
    // Mark as high priority
    const result = await resend.emails.send({
      from: 'Clean & Flip Support <support@cleanandflip.com>',
      to: options.to,
      subject: 'Reset Your Clean & Flip Password',
      react: PasswordResetEmail(options),
      tags: [
        { name: 'category', value: 'password_reset' },
        { name: 'priority', value: 'high' }
      ],
      // Add headers for immediate delivery
      headers: {
        'X-Priority': '1',
        'X-MSMail-Priority': 'High',
        'Importance': 'high'
      }
    });
    
    console.log(`[EMAIL] Password reset email sent to ${options.to} - ID: ${result.id}`);
    
    return result;
  } catch (error) {
    console.error('[EMAIL] Failed to send password reset email:', error);
    throw error;
  }
}
```

## Step 7: Database Schema Update

### Update `/server/db/schema.ts`:

```typescript
// Add password_reset_tokens table to schema
export const passwordResetTokens = pgTable('password_reset_tokens', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  token: varchar('token', { length: 255 }).notNull().unique(),
  expiresAt: timestamp('expires_at').notNull(),
  used: boolean('used').default(false),
  createdAt: timestamp('created_at').defaultNow(),
  usedAt: timestamp('used_at'),
  ipAddress: varchar('ip_address', { length: 45 }),
  userAgent: text('user_agent')
}, (table) => ({
  tokenIdx: index('idx_password_reset_tokens_token').on(table.token),
  userIdIdx: index('idx_password_reset_tokens_user_id').on(table.userId),
  expiresIdx: index('idx_password_reset_tokens_expires_at').on(table.expiresAt),
  usedIdx: index('idx_password_reset_used').on(table.used).where(eq(table.used, false))
}));
```

## Deployment Steps

1. **Create the missing table** (CRITICAL - Do this first!):
```bash
psql $DATABASE_URL < server/db/migrations/create-password-reset-tokens.sql
```

2. **Deploy the code updates**:
```bash
git add .
git commit -m "Fix: Complete password reset system overhaul"
git push
```

3. **Test the system**:
```bash
# Check if table was created
psql $DATABASE_URL -c "SELECT COUNT(*) FROM password_reset_tokens;"

# Test password reset
curl -X POST https://cleanandflip.com/api/auth/forgot-password \
  -H "Content-Type: application/json" \
  -d '{"email": "cleanandflipyt@gmail.com"}'

# Check debug info (dev only)
curl https://cleanandflip.com/api/debug/list-emails
```

## Expected Behavior

1. **User exists**: Token created, email sent immediately
2. **User doesn't exist**: No token, no email, same response
3. **Rate limiting**: Max 1 reset every 2 minutes per email/IP
4. **No duplicates**: Recent tokens prevent new ones for 5 minutes
5. **Fast delivery**: Email sent with high priority headers
6. **Secure**: No information leakage about user existence

## Monitoring

Check logs for these messages:
- `[PASSWORD_RESET] User found: ID X`
- `[PASSWORD_RESET] Email sent successfully in Xms`
- `[RATE_LIMIT] Too many requests`
- `[PASSWORD_RESET] Recent token exists`

This complete overhaul will fix all issues and make the password reset system work perfectly!