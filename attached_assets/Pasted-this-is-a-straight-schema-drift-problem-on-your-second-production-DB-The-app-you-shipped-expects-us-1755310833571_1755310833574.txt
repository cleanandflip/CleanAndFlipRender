this is a straight schema drift problem on your second production DB. The app you shipped expects users.profile_address_id; that DB doesn’t have it, so Passport/login explodes with 42703 (“column does not exist”). Here’s how to fix it permanently and make sure it never regresses.

Replit: fix and harden prod-2 DB + auth right now
0) Identify which DB prod-2 is actually using

Open the prod-2 Replit shell and print the DB host so we don’t fix the wrong database:

node -e "console.log(new URL(process.env.DATABASE_URL).host)"


Keep this host in mind; everything below must hit this DB.

1) Check & apply migrations on prod-2

Show migration status:

npm run drizzle:status


If anything is pending:

npm run drizzle:migrate
npm run drizzle:status


Status must say up to date.

2) Hot-patch prod-2 if the column is still missing

Run these checks directly against prod-2:

SELECT column_name
FROM information_schema.columns
WHERE table_name='users' AND column_name='profile_address_id';

SELECT to_regclass('public.addresses');


If the column is missing, create it safely (nullable) + FK + index:

ALTER TABLE "users" ADD COLUMN IF NOT EXISTS "profile_address_id" uuid;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.table_constraints
    WHERE constraint_name = 'users_profile_address_id_fkey'
  ) THEN
    ALTER TABLE "users"
      ADD CONSTRAINT "users_profile_address_id_fkey"
      FOREIGN KEY ("profile_address_id") REFERENCES "addresses"("id")
      ON DELETE SET NULL;
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS "idx_users_profile_address_id"
  ON "users" ("profile_address_id");

3) Align the Drizzle schema and rebuild

Open shared/schema.ts (or wherever users lives) and ensure naming matches the DB:

export const users = pgTable('users', {
  // …existing fields
  profileAddressId: uuid('profile_address_id')
    .references(() => addresses.id, { onDelete: 'set null' })
    .default(null)
});


Then:

npm run build
npm start

4) Make auth never 500 even if DB lags for a moment

In server/auth.ts (or wherever Passport is configured), wrap deserialization:

passport.deserializeUser(async (id: string, done) => {
  try {
    const user = await dbGetUserById(id); // this SELECT must tolerate NULL profileAddressId
    return done(null, user ?? false);
  } catch (err) {
    console.error('[PASSPORT] Deserialization suppressed:', err);
    return done(null, false); // never throw 500 on static requests, sw.js, etc.
  }
});


Also ensure any getUserByEmail / getUser SELECT:

does not INNER JOIN through profile_address_id. Use LEFT JOIN and optional chaining.

Only selects columns that exist (now they do).

5) Stop static assets from touching auth/session (reduces noisy failures)

Before passport.session():

app.use((req, _res, next) => {
  const p = req.path;
  if (p === '/sw.js' || p === '/favicon.ico' || p.startsWith('/assets/') || p.startsWith('/static/')) {
    return next();
  }
  return next();
});


(With the try/catch this is extra-safe; it prevents service worker fetches from surfacing auth errors.)

6) Add a boot-time schema guard so this never surprises you again

On server start, log loudly if a required column is missing for the current DATABASE_URL:

async function assertSchemaReady(db: any) {
  const { rows } = await db.execute(`
    SELECT 1
    FROM information_schema.columns
    WHERE table_name='users' AND column_name='profile_address_id'
  `);
  if (!rows?.length) {
    console.error(
      '[SCHEMA] Missing users.profile_address_id in current DATABASE_URL. ' +
      'Migrations have NOT been applied to this database.'
    );
  }
}


Call assertSchemaReady(db) once at boot.

7) Always migrate on deploy (both productions)

In package.json:

{
  "scripts": {
    "prestart": "npm run drizzle:migrate",
    "start": "node dist/server.js"
  }
}


This guarantees each deploy applies migrations before the app serves traffic.

8) Quick smoke tests

Run these against prod-2 after the fixes:

# Health
curl -sSf http://<prod2>/status

# Login (should not 500). If you can’t post creds here, at least ensure 4xx/200, not 500.
# Observe server logs for absence of 42703 errors.

# Static should never 500
curl -i http://<prod2>/sw.js | head -5

9) (Optional) Backfill a sensible default for existing users

If you want profile_address_id prefilled from a default address:

UPDATE "users" u
SET "profile_address_id" = a.id
FROM "addresses" a
WHERE a.user_id = u.id
  AND a.is_default = TRUE
  AND u.profile_address_id IS NULL;

Why the error keeps returning

You have two prods pointing at different Neon branches; only one received the migration that added users.profile_address_id.

The app binary (compiled with the new schema) is running against the old DB → Postgres throws 42703 on every login/email lookup.

The steps above both fix the current DB and add guard rails (migrate on boot + boot schema check + Passport try/catch) so a future drift can’t take down auth.

Follow the steps exactly and your /api/login 500s and the repeated profile_address_id errors will stop.