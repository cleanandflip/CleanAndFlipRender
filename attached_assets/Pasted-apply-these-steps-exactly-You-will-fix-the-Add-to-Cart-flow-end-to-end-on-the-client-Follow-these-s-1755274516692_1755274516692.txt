apply these steps exactly
You will fix the Add to Cart flow end-to-end on the client. Follow these steps EXACTLY and do not stop until verification passes.

GOALS
- Client always sends cookies (uses connect.sid).
- Uses the V2 endpoint: POST /api/cart with { productId, qty, variantId? }.
- Correctly interprets 201 (added / capped) and 422 (ineligible/stock) responses.
- Disables the button when availability is BLOCKED and shows the server “reasons”.
- React Query invalidation uses locality version + auth to refresh cart after add.

======================================================================
STEP 1 — API wrapper must send cookies
======================================================================
Open client/src/lib/api.ts and enforce credentials:

export async function apiJson<T>(path: string, init: RequestInit = {}): Promise<T> {
  const res = await fetch(path, {
    ...init,
    headers: {
      "Content-Type": "application/json",
      ...(init.headers || {}),
    },
    credentials: "include", // <-- REQUIRED (uses connect.sid)
  });
  if (!res.ok) {
    const body = await res.json().catch(() => ({}));
    const error = new Error(body?.error || `HTTP ${res.status}`);
    (error as any).status = res.status;
    (error as any).body = body;
    throw error;
  }
  return res.json();
}

Verify your Axios instance (if any) has: axios.defaults.withCredentials = true

======================================================================
STEP 2 — Centralize cart mutations (V2 only, with graceful fallback)
======================================================================
Create/replace client/src/lib/cartApi.ts:

import { apiJson } from "@/lib/api";

export async function addToCartApi(opts: { productId: string; qty: number; variantId?: string | null }) {
  try {
    return await apiJson<{ ok: boolean; status: string; qty: number; available: number; warning?: string }>(
      "/api/cart",
      { method: "POST", body: JSON.stringify(opts) }
    );
  } catch (e: any) {
    // Graceful fallback during rollout if V2 path not wired yet on env
    if (e?.status === 404) {
      return await apiJson<any>("/api/cart/items", {
        method: "POST",
        body: JSON.stringify({ productId: opts.productId, quantity: opts.qty, variantId: opts.variantId ?? null }),
      });
    }
    throw e;
  }
}

export async function deleteByProduct(productId: string) {
  return apiJson<{ ok: boolean }>(`/api/cart/product/${productId}`, { method: "DELETE" });
}

======================================================================
STEP 3 — React Query keys must include locality + auth
======================================================================
Open client/src/lib/cartKeys.ts and ensure:

export const cartKeys = {
  all: ["cart"] as const,
  scoped: (authId: string | null, localityVersion: string) =>
    [...cartKeys.all, authId ?? "anon", localityVersion] as const,
};

Open client/src/hooks/useLocality.ts and ensure it exposes a stable string
(localityVersion) that bumps on ZIP/address changes.

Open client/src/hooks/use-auth.tsx and expose user?.id || null.

Open client/src/hooks/useCart.ts and ensure:

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { cartKeys } from "@/lib/cartKeys";
import { addToCartApi, deleteByProduct } from "@/lib/cartApi";
import { useLocality } from "@/hooks/useLocality";
import { useAuth } from "@/hooks/use-auth";

export function useCart() {
  const qc = useQueryClient();
  const { data: locality } = useLocality();
  const { user } = useAuth();
  const key = cartKeys.scoped(user?.id ?? null, locality?.localityVersion ?? "0");

  const cartQuery = useQuery({
    queryKey: key,
    queryFn: async () => await apiJson("/api/cart"),
    staleTime: 0,
  });

  const addMutation = useMutation({
    mutationFn: addToCartApi,
    onSuccess: () => qc.invalidateQueries({ queryKey: key }),
  });

  const removeByProduct = useMutation({
    mutationFn: (productId: string) => deleteByProduct(productId),
    onSuccess: () => qc.invalidateQueries({ queryKey: key }),
  });

  return { ...cartQuery, addMutation, removeByProduct };
}

======================================================================
STEP 4 — Enforce SSOT availability on the button (client-side gating)
======================================================================
Open client/src/components/AddToCartButton.tsx and REPLACE with:

import { useState } from "react";
import { useCart } from "@/hooks/useCart";
import { useLocality } from "@/hooks/useLocality";
import { modeFromProduct } from "@/shared/fulfillment"; // already in your codebase
import { computeEffectiveAvailability } from "@/shared/availability"; // SSOT function
import { toast } from "@/components/ui/use-toast"; // or your toast util

type Props = {
  product: { id: string; /* ...anything else you pass */ };
  variantId?: string | null;
  qty?: number;
  className?: string;
};

export default function AddToCartButton({ product, variantId = null, qty = 1, className }: Props) {
  const { addMutation } = useCart();
  const { data: loc } = useLocality();
  const [clicked, setClicked] = useState(false);

  // Client-side gate (UI only). Server remains source of truth.
  const productMode = modeFromProduct(product as any);
  const userMode = loc?.effectiveModeForUser ?? "NONE";
  const eff = computeEffectiveAvailability(productMode, userMode);

  const disabled =
    addMutation.isPending ||
    eff === "BLOCKED" ||
    !product?.id ||
    qty <= 0;

  async function onAdd() {
    setClicked(true);
    try {
      const res = await addMutation.mutateAsync({ productId: product.id, qty, variantId });
      if (res?.warning) {
        toast({ title: "Added with limit", description: res.warning });
      } else {
        toast({ title: "Added to cart" });
      }
    } catch (e: any) {
      if (e?.status === 422 && e?.body?.reasons?.length) {
        toast({ title: "Unavailable", description: e.body.reasons.join(", ") });
      } else {
        toast({ title: "Could not add to cart", description: e?.message ?? "Unknown error" });
      }
    } finally {
      setClicked(false);
    }
  }

  let label = "Add to cart";
  if (eff === "PICKUP_ONLY") label = "Add (Pickup only)";
  if (eff === "SHIPPING_ONLY") label = "Add (Ships only)";
  if (eff === "BLOCKED") label = "Unavailable in your area";

  return (
    <button
      type="button"
      className={className}
      disabled={disabled}
      aria-disabled={disabled}
      onClick={onAdd}
      data-availability={eff}
      data-locality-source={loc?.source ?? "unknown"}
    >
      {addMutation.isPending ? "Adding..." : label}
    </button>
  );
}

IMPORTANT:
- This button sends **qty** (not “quantity”).
- It never constructs its own ownerId; cookies are sent by the api wrapper.

======================================================================
STEP 5 — Product pages must pass product.id and optional variantId
======================================================================
Open any usages of <AddToCartButton .../> and ensure:
- You pass product.id (not slug).
- If variants exist, pass variantId (or null).
- qty is a positive integer (default to 1).

======================================================================
STEP 6 — Optional: allow UNKNOWN locality to add (feature flag)
======================================================================
If you want guests with no ZIP to still add items and defer blocking to checkout,
set this on server (policy layer), then reflect the label:

// shared/availability.ts
// Option: treat userMode 'NONE' as tentatively allowed for LOCAL_AND_SHIPPING
// and blocked for LOCAL_ONLY.
export function computeEffectiveAvailability(productMode, userMode) {
  if (userMode === 'NONE') {
    return productMode === 'LOCAL_ONLY' ? 'BLOCKED' : 'ADD_ALLOWED';
  }
  // ...rest of your existing matrix
}

(If you keep strict blocking on NONE, the button will show “Unavailable in your area”
until ZIP/address is provided—that’s fine too.)

======================================================================
STEP 7 — Verification (must ALL pass)
======================================================================
1) In browser DevTools → Network:
   - Click Add to Cart twice. Verify:
     - POST /api/cart returns 201 with { ok: true, status: "ADDED"|"ADDED_PARTIAL_STOCK_CAP", qty, available }
     - GET /api/cart is re-fetched (Query invalidation), items show increased qty.
     - All requests include Cookie: connect.sid=...

2) If your locality is OUT_OF_AREA or NONE:
   - Button label changes accordingly.
   - If clicked while eff === BLOCKED, request should NOT fire (disabled=true).

3) cURL sanity (same cookie jar):
   rm -f /tmp/c.sess
   curl -i -c /tmp/c.sess -b /tmp/c.sess -H "Content-Type: application/json" \
     -X POST http://localhost:5000/api/cart --data '{"productId":"TEST-1","qty":1}'
   curl -s -c /tmp/c.sess -b /tmp/c.sess http://localhost:5000/api/cart | head -60

4) Confirm no calls to /api/cart/items from the client (unless fallback hit due to 404).

======================================================================
STEP 8 — Commit
======================================================================
git add .
git commit -m "fix(client): AddToCart uses V2 POST /api/cart, cookies included, SSOT availability gating, proper errors + invalidation"

Likely root causes this fixes

Wrong payload name (“quantity” vs qty) → server ignored qty.

Missing cookies → server saw a new anonymous owner for each request.

Legacy endpoint (/api/cart/items) still used → mismatched handlers.

UI gating mismatch → client enabled button while server blocked (now you show server reasons + disable).

No invalidation → cart UI didn’t refresh after a successful add (now scoped keys + invalidate).