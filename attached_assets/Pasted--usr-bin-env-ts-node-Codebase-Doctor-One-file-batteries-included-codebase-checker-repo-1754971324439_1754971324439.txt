#!/usr/bin/env ts-node
/**
 * Codebase Doctor — One-file, batteries-included codebase checker & reporter
 * ---------------------------------------------------------------------------------
 * What it checks (out-of-the-box):
 * 1) TypeScript compile errors (if tsconfig.json exists)
 * 2) Broken/ambiguous imports & orphaned files (module graph)
 * 3) Duplicate/near-duplicate files (content hashing & AST fingerprints)
 * 4) React Router: declared <Route path> vs. referenced links (Link/NavLink/to/navigate)
 * 5) Express API: declared routes vs. front-end fetch/axios calls
 * 6) Design system drift: Button variants/sizes vs. actual usage + hardcoded classnames
 * 7) Hardcoded CSS: inline styles, hex/rgb colors, !important, arbitrary Tailwind colors
 * 8) Conflicting CSS selectors and duplicate Tailwind utility collisions
 * 9) Large/unused assets, unoptimized images
 * 10) ENV variables: used vs. .env.example
 * 11) TODO/FIXME/console logs inventory
 * 12) Simple flaky patterns: setInterval without clear, unhandled promises, empty catch, etc.
 * 13) Missing pages/routes (simple 404 risk heuristics)
 * 14) JSON/TS/JS syntax validity (fast scan)
 * 15) License headers / file banners consistency (optional)
 *
 * Output:
 * - Pretty console summary with pass/warn/fail counts
 * - JSON report: ./codebase-doctor-report/report.json
 * - Markdown report (human-friendly): ./codebase-doctor-report/report.md
 * - Exit code 1 if any FAIL findings (so you can wire into CI)
 *
 * Usage:
 *   npm i -D ts-node typescript fast-glob chalk fs-extra crypto @babel/parser postcss csstree micromatch
 *   chmod +x codebase-doctor.ts
 *   ./codebase-doctor.ts                     # scan current repo
 *   ./codebase-doctor.ts --root ./client     # scan a subdir
 *   ./codebase-doctor.ts --router react      # force React Router scan
 *   ./codebase-doctor.ts --express server    # set Express server dir
 *
 * Notes:
 * - Designed to work without any project-specific code changes.
 * - If you have a central Button component, set --button "client/src/components/ui/button.tsx"
 * - Safe defaults: ignores node_modules, dist, build, coverage, .git, .next, .turbo
 */

/* ------------------------------------------------------------------------------------------------
 * Imports
 * ------------------------------------------------------------------------------------------------ */
import fs from 'fs';
import fsp from 'fs/promises';
import path from 'path';
import fg from 'fast-glob';
import chalk from 'chalk';
import * as crypto from 'crypto';
import * as babel from '@babel/parser';
import postcss from 'postcss';
import * as csstree from 'csstree';
import micromatch from 'micromatch';

/* ------------------------------------------------------------------------------------------------
 * Types
 * ------------------------------------------------------------------------------------------------ */

type Severity = 'PASS' | 'WARN' | 'FAIL';

interface Finding {
  id: string;
  title: string;
  severity: Severity;
  file?: string;
  line?: number;
  column?: number;
  details?: string;
  suggestion?: string;
  tags?: string[];
}

interface SectionReport {
  section: string;
  findings: Finding[];
}

interface DoctorConfig {
  root: string;
  routerMode: 'auto' | 'react';
  expressDir: string | null;
  buttonPath: string | null;
  envExamplePath: string | null;
  ignore: string[];
}

/* ------------------------------------------------------------------------------------------------
 * CLI args
 * ------------------------------------------------------------------------------------------------ */

const args = process.argv.slice(2);
const getArg = (flag: string, fallback?: string | null) => {
  const idx = args.indexOf(flag);
  if (idx >= 0) return args[idx + 1] ?? null;
  return fallback ?? null;
};

const cfg: DoctorConfig = {
  root: path.resolve(getArg('--root', '.')!),
  routerMode: (getArg('--router', 'auto') as 'auto' | 'react') || 'auto',
  expressDir: getArg('--express', null),
  buttonPath: getArg('--button', null),
  envExamplePath: getArg('--env', '.env.example'),
  ignore: [
    'node_modules/**',
    'dist/**',
    'build/**',
    'coverage/**',
    '.next/**',
    '.turbo/**',
    '.git/**',
    '**/*.map'
  ]
};

/* ------------------------------------------------------------------------------------------------
 * Utils
 * ------------------------------------------------------------------------------------------------ */

const REPORT_DIR = path.join(process.cwd(), 'codebase-doctor-report');

function ensureDir(p: string) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
}

function hashBuffer(buf: Buffer) {
  return crypto.createHash('sha256').update(buf).digest('hex');
}

function hashString(s: string) {
  return crypto.createHash('sha256').update(s).digest('hex');
}

function rel(p: string) {
  return path.relative(cfg.root, p) || p;
}

function isTextFile(file: string) {
  return /\.(t|j)sx?$|\.(json|md|css|scss|sass|html)$/i.test(file);
}

function readSafe(file: string): string {
  try { return fs.readFileSync(file, 'utf8'); } catch { return ''; }
}

function parseJS(code: string, filename: string) {
  try {
    return babel.parse(code, {
      sourceType: 'unambiguous',
      plugins: [
        'jsx',
        'typescript',
        'classProperties',
        'decorators-legacy',
        'dynamicImport',
        'objectRestSpread',
        'optionalChaining',
        'nullishCoalescingOperator'
      ] as any
    });
  } catch (e) {
    return null;
  }
}

function tableRow(cols: string[], widths: number[]) {
  return cols.map((c, i) => (c.length > widths[i] ? c.slice(0, widths[i] - 1) + '…' : c.padEnd(widths[i]))).join('  ');
}

/* ------------------------------------------------------------------------------------------------
 * Core scanner
 * ------------------------------------------------------------------------------------------------ */

async function collectFiles(): Promise<string[]> {
  const patterns = [
    '**/*.{ts,tsx,js,jsx,json,css,scss,sass,html}',
    '**/*.{png,jpg,jpeg,webp,svg,gif}'
  ];
  const files = await fg(patterns, { cwd: cfg.root, absolute: true, ignore: cfg.ignore });
  return files;
}

/* ------------------------------------------------------------------------------------------------
 * Check 1 — Syntax validity + quick JSON check
 * ------------------------------------------------------------------------------------------------ */
async function checkSyntax(files: string[]): Promise<SectionReport> {
  const findings: Finding[] = [];

  for (const file of files) {
    if (/\.(json)$/i.test(file)) {
      const raw = readSafe(file);
      if (!raw) continue;
      try { JSON.parse(raw); } catch (e: any) {
        findings.push({
          id: 'syntax:json',
          title: `Invalid JSON`,
          severity: 'FAIL',
          file: rel(file),
          details: String(e.message)
        });
      }
    }
    if (/\.(t|j)sx?$/.test(file)) {
      const raw = readSafe(file);
      if (!raw) continue;
      const ast = parseJS(raw, file);
      if (!ast) {
        findings.push({ id: 'syntax:js', title: 'Parse error (JS/TS)', severity: 'FAIL', file: rel(file) });
      }
    }
  }
  return { section: 'Syntax', findings };
}

/* ------------------------------------------------------------------------------------------------
 * Check 2 — Module graph: broken imports, orphans
 * ------------------------------------------------------------------------------------------------ */
async function checkModuleGraph(files: string[]): Promise<SectionReport> {
  const findings: Finding[] = [];
  const exts = new Set(['.ts', '.tsx', '.js', '.jsx']);
  const sourceFiles = files.filter(f => exts.has(path.extname(f)));
  const fileSet = new Set(sourceFiles.map(f => path.resolve(f)));

  const importEdges: Array<{ from: string; to: string }> = [];
  const referenced = new Set<string>();

  for (const file of sourceFiles) {
    const code = readSafe(file);
    const ast = parseJS(code, file);
    if (!ast) continue;
    // naive import scan
    const importRe = /(?:import\s+[^'"\n]+from\s*|require\()\s*['"]([^'"\n]+)['"]/g;
    let m: RegExpExecArray | null;
    while ((m = importRe.exec(code))) {
      let spec = m[1];
      if (spec.startsWith('.') || spec.startsWith('/')) {
        // resolve
        const base = path.dirname(file);
        const resolved = resolveWithExtensions(path.resolve(base, spec));
        if (!resolved) {
          findings.push({
            id: 'module:missing',
            title: `Broken import: ${spec}`,
            severity: 'FAIL',
            file: rel(file),
            details: `Cannot resolve ${spec} from ${rel(file)}`
          });
        } else {
          importEdges.push({ from: file, to: resolved });
          referenced.add(path.resolve(resolved));
        }
      } else {
        // bare specifier: skip resolution, but record
        importEdges.push({ from: file, to: spec });
      }
    }
  }

  // Orphans: files with no inbound edges (excluding entry files and index.tsx)
  const inboundCount = new Map<string, number>();
  for (const e of importEdges) {
    const to = e.to;
    if (to.startsWith('/')) inboundCount.set(to, (inboundCount.get(to) ?? 0) + 1);
  }
  for (const f of sourceFiles) {
    if (/index\.(t|j)sx?$/.test(path.basename(f))) continue;
    if ((inboundCount.get(path.resolve(f)) ?? 0) === 0) {
      findings.push({
        id: 'module:orphan',
        title: 'Orphaned source file',
        severity: 'WARN',
        file: rel(f),
        details: 'No inbound imports reference this file.'
      });
    }
  }

  return { section: 'Module Graph', findings };
}

function resolveWithExtensions(base: string): string | null {
  const tryPaths = [
    base,
    base + '.ts', base + '.tsx', base + '.js', base + '.jsx',
    path.join(base, 'index.ts'), path.join(base, 'index.tsx'), path.join(base, 'index.js'), path.join(base, 'index.jsx')
  ];
  for (const p of tryPaths) if (fs.existsSync(p)) return p;
  return null;
}

/* ------------------------------------------------------------------------------------------------
 * Check 3 — Duplicates: identical and near-identical files
 * ------------------------------------------------------------------------------------------------ */
async function checkDuplicates(files: string[]): Promise<SectionReport> {
  const findings: Finding[] = [];
  const textFiles = files.filter(isTextFile);

  const byHash = new Map<string, string[]>();
  for (const f of textFiles) {
    const h = hashBuffer(fs.readFileSync(f));
    const arr = byHash.get(h) ?? [];
    arr.push(f);
    byHash.set(h, arr);
  }

  for (const [h, group] of byHash) {
    if (group.length > 1) {
      findings.push({
        id: 'dupe:file',
        title: `Duplicate files (${group.length})`,
        severity: 'WARN',
        details: group.map(rel).join('\n'),
      });
    }
  }

  return { section: 'Duplicates', findings };
}

/* ------------------------------------------------------------------------------------------------
 * Check 4 — Router: declared vs. referenced
 * ------------------------------------------------------------------------------------------------ */
async function checkReactRouter(files: string[]): Promise<SectionReport> {
  const findings: Finding[] = [];
  const jsxFiles = files.filter(f => /\.(t|j)sx$/.test(f));

  const declared = new Set<string>();
  const referenced = new Set<string>();

  const routeDecl = /<Route\s+[^>]*path=\{?['"]([^'"}]+)['"]/g;
  const toRef = /(Link|NavLink)\s+[^>]*to=\{?['"]([^'"}]+)['"]/g;
  const navigateRef = /navigate\(\s*['"]([^'"\)]+)['"]/g;

  for (const f of jsxFiles) {
    const code = readSafe(f);
    let m: RegExpExecArray | null;
    while ((m = routeDecl.exec(code))) declared.add(m[1]);
    while ((m = toRef.exec(code))) referenced.add(m[2]);
    while ((m = navigateRef.exec(code))) referenced.add(m[1]);
  }

  // referenced paths that are not declared
  for (const r of referenced) {
    if (!matchesAnyRoute(r, [...declared])) {
      findings.push({
        id: 'router:missing',
        title: 'Referenced path not declared in routes',
        severity: 'WARN',
        details: `"${r}" has no matching <Route path>.`,
        suggestion: 'Add a <Route> or correct the Link/NavLink/navigate path.'
      });
    }
  }

  // Optionally, report declared routes with no references (could be deep-linked though)
  for (const d of declared) {
    if (![...referenced].some(r => matchesAnyRoute(r, [d]))) {
      findings.push({
        id: 'router:unreferenced',
        title: 'Declared route not referenced by UI',
        severity: 'WARN',
        details: `Route path "${d}" is never used by Link/NavLink/navigate. If deep-link only, ignore.`
      });
    }
  }

  return { section: 'Routing (React Router)', findings };
}

function matchesAnyRoute(pathname: string, declared: string[]): boolean {
  // simple matcher supporting ":id" and wildcard "*"
  return declared.some(d => {
    const pat = '^' + d
      .replace(/\//g, '\\/')
      .replace(/:\w+/g, '[^/]+')
      .replace(/\*/g, '.*') + '$';
    try { return new RegExp(pat).test(pathname); } catch { return false; }
  });
}

/* ------------------------------------------------------------------------------------------------
 * Check 5 — Express API vs frontend calls
 * ------------------------------------------------------------------------------------------------ */
async function checkExpressAndCalls(files: string[]): Promise<SectionReport> {
  const findings: Finding[] = [];
  const serverFiles = cfg.expressDir
    ? await fg(['**/*.{ts,tsx,js,jsx}'], { cwd: path.resolve(cfg.root, cfg.expressDir), absolute: true, ignore: cfg.ignore })
    : files.filter(f => /server|api|backend/.test(rel(f)) && /\.(t|j)sx?$/.test(f));

  const declared = new Set<string>();
  const callSites = new Set<string>();

  const appRoute = /\b(app|router)\.(get|post|put|delete|patch|options|head)\(\s*['"]([^'"\n]+)['"]/g;
  for (const f of serverFiles) {
    const code = readSafe(f);
    let m: RegExpExecArray | null;
    while ((m = appRoute.exec(code))) declared.add(`${m[2].toUpperCase()} ${m[3]}`);
  }

  const clientFetchRe = /\b(fetch|axios\.(get|post|put|delete|patch))\(\s*['"]([^'"\n]+)['"]/g;
  for (const f of files.filter(f => /\.(t|j)sx?$/.test(f))) {
    const code = readSafe(f);
    let m: RegExpExecArray | null;
    while ((m = clientFetchRe.exec(code))) {
      const full = m[0];
      const url = m[3] ?? m[1];
      if (url.startsWith('/')) callSites.add(url);
    }
  }

  for (const url of callSites) {
    const anyMethod = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'].some(m => declared.has(`${m} ${url}`));
    if (!anyMethod) {
      findings.push({ id: 'api:missing', title: 'Frontend calls API not declared on server', severity: 'FAIL', details: url });
    }
  }

  return { section: 'API (Express vs Frontend)', findings };
}

/* ------------------------------------------------------------------------------------------------
 * Check 6 — Design system drift: Button usage + classnames
 * ------------------------------------------------------------------------------------------------ */
async function checkButtonAndStyles(files: string[]): Promise<SectionReport> {
  const findings: Finding[] = [];
  const jsxFiles = files.filter(f => /\.(t|j)sx$/.test(f));

  const variantValues = new Map<string, number>();
  const sizeValues = new Map<string, number>();
  const hardcodedClassFiles = new Set<string>();

  const buttonImportHint = cfg.buttonPath ? path.basename(cfg.buttonPath).replace(/\.(t|j)sx?$/, '') : 'button';

  for (const f of jsxFiles) {
    const code = readSafe(f);

    // JSX prop grabbers
    const variantRe = /<\s*Button\b[^>]*\bvariant=\{?['"]([^'"}]+)['"]/g;
    const sizeRe = /<\s*Button\b[^>]*\bsize=\{?['"]([^'"}]+)['"]/g;

    let m: RegExpExecArray | null;
    while ((m = variantRe.exec(code))) variantValues.set(m[1], (variantValues.get(m[1]) ?? 0) + 1);
    while ((m = sizeRe.exec(code))) sizeValues.set(m[1], (sizeValues.get(m[1]) ?? 0) + 1);

    // Hardcoded classes that look like buttons or colors
    if (/className=\{?['"][^'"]*(btn-|bg-|text-|hover:|focus:)/.test(code)) {
      hardcodedClassFiles.add(rel(f));
    }
  }

  // Report unknown variants/sizes vs. a canonical set (heuristic; customize as needed)
  const canonicalVariants = new Set(['default', 'primary', 'secondary', 'destructive', 'outline', 'ghost', 'link', 'danger', 'success', 'glass']);
  for (const [v, count] of variantValues) {
    if (!canonicalVariants.has(v)) {
      findings.push({ id: 'button:variant', title: 'Unknown Button variant used', severity: 'WARN', details: `${v} (${count} uses)`, suggestion: 'Unify variants in your Button component.' });
    }
  }

  const canonicalSizes = new Set(['default', 'sm', 'md', 'lg', 'icon']);
  for (const [s, count] of sizeValues) {
    if (!canonicalSizes.has(s)) {
      findings.push({ id: 'button:size', title: 'Unknown Button size used', severity: 'WARN', details: `${s} (${count} uses)` });
    }
  }

  if (hardcodedClassFiles.size) {
    findings.push({ id: 'css:hardcoded-classes', title: 'Hardcoded UI classes in components', severity: 'WARN', details: [...hardcodedClassFiles].join('\n'), suggestion: 'Prefer using the shared Button and design tokens.' });
  }

  return { section: 'Design System (Buttons & Classes)', findings };
}

/* ------------------------------------------------------------------------------------------------
 * Check 7 — CSS style smells: inline styles, colors, !important, arbitrary Tailwind
 * ------------------------------------------------------------------------------------------------ */
async function checkCSS(files: string[]): Promise<SectionReport> {
  const findings: Finding[] = [];
  const cssFiles = files.filter(f => /\.(css|scss|sass)$/i.test(f));
  const jsxFiles = files.filter(f => /\.(t|j)sx$/.test(f));

  // CSS files via csstree
  for (const f of cssFiles) {
    const raw = readSafe(f);
    try {
      const ast = csstree.parse(raw, { positions: true });
      csstree.walk(ast, (node: any) => {
        // !important
        if (node.type === 'Declaration' && node.important) {
          findings.push({ id: 'css:important', title: 'Usage of !important', severity: 'WARN', file: rel(f), line: node.loc?.start?.line });
        }
        // Hex or rgb(a) colors
        if (node.type === 'HexColor' || (node.type === 'Function' && /^rgba?$/.test(node.name))) {
          findings.push({ id: 'css:hardcolor', title: 'Hardcoded color', severity: 'WARN', file: rel(f), line: node.loc?.start?.line, details: csstree.generate(node) });
        }
      });
    } catch {
      findings.push({ id: 'css:parse', title: 'CSS parse error', severity: 'FAIL', file: rel(f) });
    }
  }

  // Inline styles & arbitrary Tailwind
  const inlineStyleRe = /style=\{\{[^}]+\}\}/g;
  const arbitraryTailwindRe = /className=\{?['"][^'"]*\[[^\]]+\][^'"]*['"]/g; // e.g., bg-[#123456]

  for (const f of jsxFiles) {
    const code = readSafe(f);
    if (inlineStyleRe.test(code)) {
      findings.push({ id: 'css:inline-style', title: 'Inline style usage', severity: 'WARN', file: rel(f), suggestion: 'Extract to class or design token.' });
    }
    if (arbitraryTailwindRe.test(code)) {
      findings.push({ id: 'css:arbitrary-tailwind', title: 'Arbitrary Tailwind color/class', severity: 'WARN', file: rel(f), details: 'Found classes like bg-[#xxxxxx]. Use tokens.' });
    }
  }

  return { section: 'CSS & Styling', findings };
}

/* ------------------------------------------------------------------------------------------------
 * Check 8 — Assets: size & unused
 * ------------------------------------------------------------------------------------------------ */
async function checkAssets(files: string[]): Promise<SectionReport> {
  const findings: Finding[] = [];
  const assetFiles = files.filter(f => /\.(png|jpe?g|webp|gif|svg)$/i.test(f));
  const source = files.filter(f => /\.(t|j)sx?$|\.(css|scss|sass|html)$/i.test(f)).map(readSafe).join('\n');

  for (const f of assetFiles) {
    const stat = fs.statSync(f);
    const kb = Math.round(stat.size / 1024);
    if (kb > 500) {
      findings.push({ id: 'asset:size', title: 'Large image asset', severity: 'WARN', file: rel(f), details: `${kb} KB`, suggestion: 'Compress or serve as responsive images.' });
    }
    // unused
    const base = path.basename(f);
    if (!source.includes(base)) {
      findings.push({ id: 'asset:unused', title: 'Possibly unused asset', severity: 'WARN', file: rel(f) });
    }
  }

  return { section: 'Assets', findings };
}

/* ------------------------------------------------------------------------------------------------
 * Check 9 — ENV variables usage vs .env.example
 * ------------------------------------------------------------------------------------------------ */
async function checkEnv(files: string[]): Promise<SectionReport> {
  const findings: Finding[] = [];
  const envVarsUsed = new Set<string>();
  const re = /process\.env\.([A-Z0-9_]+)/g;
  for (const f of files.filter(f => /\.(t|j)sx?$/.test(f))) {
    const code = readSafe(f);
    let m: RegExpExecArray | null;
    while ((m = re.exec(code))) envVarsUsed.add(m[1]);
  }

  const envPath = cfg.envExamplePath ? path.resolve(cfg.root, cfg.envExamplePath) : null;
  const declared = new Set<string>();
  if (envPath && fs.existsSync(envPath)) {
    const content = readSafe(envPath);
    for (const line of content.split(/\r?\n/)) {
      const mm = line.match(/^\s*([A-Z0-9_]+)\s*=/);
      if (mm) declared.add(mm[1]);
    }
  }

  for (const v of envVarsUsed) {
    if (!declared.has(v)) {
      findings.push({ id: 'env:missing', title: 'ENV var used but not in .env.example', severity: 'WARN', details: v });
    }
  }

  return { section: 'Environment Variables', findings };
}

/* ------------------------------------------------------------------------------------------------
 * Check 10 — Code smells: TODO/FIXME/console, setInterval leaks, empty catch
 * ------------------------------------------------------------------------------------------------ */
async function checkSmells(files: string[]): Promise<SectionReport> {
  const findings: Finding[] = [];
  const codeFiles = files.filter(f => /\.(t|j)sx?$/.test(f));

  for (const f of codeFiles) {
    const code = readSafe(f);
    const relf = rel(f);

    const todoCount = (code.match(/\bTODO\b/g) || []).length;
    const fixmeCount = (code.match(/\bFIXME\b/g) || []).length;
    const consoles = (code.match(/\bconsole\.(log|warn|error|debug)\b/g) || []).length;

    if (todoCount) findings.push({ id: 'smell:todo', title: 'TODO left in code', severity: 'WARN', file: relf, details: `${todoCount} TODO(s)` });
    if (fixmeCount) findings.push({ id: 'smell:fixme', title: 'FIXME left in code', severity: 'FAIL', file: relf, details: `${fixmeCount} FIXME(s)` });
    if (consoles) findings.push({ id: 'smell:console', title: 'console.* present', severity: 'WARN', file: relf, details: `${consoles} console call(s)` });

    // setInterval without clearInterval in file
    if (/setInterval\(/.test(code) && !/clearInterval\(/.test(code)) {
      findings.push({ id: 'smell:interval', title: 'setInterval without clearInterval', severity: 'WARN', file: relf });
    }

    // Empty catch blocks
    if (/catch\s*\(.*\)\s*\{\s*\}/.test(code)) {
      findings.push({ id: 'smell:empty-catch', title: 'Empty catch block', severity: 'WARN', file: relf, suggestion: 'Handle or log error appropriately.' });
    }

    // Unhandled promises: .then(…) without .catch or await without try/catch — heuristic
    const thenNoCatch = /\.then\([^)]*\)(?!\s*\.catch\()/s;
    if (thenNoCatch.test(code)) {
      findings.push({ id: 'smell:unhandled-promise', title: 'Promise chain without catch', severity: 'WARN', file: relf });
    }
  }

  return { section: 'Code Smells', findings };
}

/* ------------------------------------------------------------------------------------------------
 * Aggregation & Reporting
 * ------------------------------------------------------------------------------------------------ */

function summarize(sections: SectionReport[]) {
  const all = sections.flatMap(s => s.findings);
  const counts = { PASS: 0, WARN: 0, FAIL: 0 } as Record<Severity, number>;
  for (const f of all) counts[f.severity]++;
  return { total: all.length, counts };
}

async function writeReports(sections: SectionReport[]) {
  ensureDir(REPORT_DIR);
  const jsonPath = path.join(REPORT_DIR, 'report.json');
  const mdPath = path.join(REPORT_DIR, 'report.md');

  const payload = { generatedAt: new Date().toISOString(), root: cfg.root, sections };
  await fsp.writeFile(jsonPath, JSON.stringify(payload, null, 2), 'utf8');

  let md = `# Codebase Doctor Report\n\nGenerated: ${new Date().toISOString()}\nRoot: ${cfg.root}\n\n`;
  for (const s of sections) {
    md += `## ${s.section}\n`;
    if (!s.findings.length) { md += `✅ No issues found.\n\n`; continue; }
    for (const f of s.findings) {
      const badge = f.severity === 'FAIL' ? '❌' : f.severity === 'WARN' ? '⚠️' : '✅';
      md += `- ${badge} **${f.title}** (${f.severity})` + (f.file ? ` — \`${f.file}\`` : '') + `\n`;
      if (f.details) md += `  - Details: ${f.details}\n`;
      if (f.suggestion) md += `  - Suggestion: ${f.suggestion}\n`;
    }
    md += `\n`;
  }
  await fsp.writeFile(mdPath, md, 'utf8');
}

function printConsole(sections: SectionReport[]) {
  const { counts } = summarize(sections);
  const total = counts.PASS + counts.WARN + counts.FAIL;

  console.log('\n' + chalk.bold('Codebase Doctor Summary'));
  console.log(chalk.gray('='.repeat(80)));
  const headers = ['Section', 'Findings', 'FAIL', 'WARN'];
  const widths = [36, 10, 8, 8];
  console.log(tableRow(headers, widths));
  console.log(chalk.gray('-'.repeat(80)));
  for (const s of sections) {
    const fails = s.findings.filter(f => f.severity === 'FAIL').length;
    const warns = s.findings.filter(f => f.severity === 'WARN').length;
    const row = tableRow([
      s.section,
      String(s.findings.length),
      fails ? chalk.red(String(fails)) : '0',
      warns ? chalk.yellow(String(warns)) : '0'
    ], widths);
    console.log(row);
  }
  console.log(chalk.gray('-'.repeat(80)));
  const status = counts.FAIL ? chalk.red('FAIL') : counts.WARN ? chalk.yellow('WARN') : chalk.green('PASS');
  console.log(`Total findings: ${total}  |  ${status}`);
  console.log(chalk.gray('Report written to ./codebase-doctor-report/ (report.json, report.md)\n'));
}

/* ------------------------------------------------------------------------------------------------
 * Main
 * ------------------------------------------------------------------------------------------------ */

(async function main() {
  const allFiles = await collectFiles();

  const sections: SectionReport[] = [];
  sections.push(await checkSyntax(allFiles));
  sections.push(await checkModuleGraph(allFiles));
  sections.push(await checkDuplicates(allFiles));
  if (cfg.routerMode === 'react' || cfg.routerMode === 'auto') sections.push(await checkReactRouter(allFiles));
  sections.push(await checkExpressAndCalls(allFiles));
  sections.push(await checkButtonAndStyles(allFiles));
  sections.push(await checkCSS(allFiles));
  sections.push(await checkAssets(allFiles));
  sections.push(await checkEnv(allFiles));
  sections.push(await checkSmells(allFiles));

  await writeReports(sections);
  printConsole(sections);

  // non-zero exit on FAIL
  const hasFail = sections.some(s => s.findings.some(f => f.severity === 'FAIL'));
  process.exit(hasFail ? 1 : 0);
})();