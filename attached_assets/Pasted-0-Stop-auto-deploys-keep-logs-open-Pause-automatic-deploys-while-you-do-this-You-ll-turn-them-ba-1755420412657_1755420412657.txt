0) Stop auto-deploys; keep logs open

Pause automatic deploys while you do this. You’ll turn them back on at the end once verification passes.

1) File hygiene: one entrypoint, one DB module

Goal: remove the “which file is booting?” ambiguity that caused mixed logs and crash loops.

Rename & relocate:

Move the DB module to: server/db.ts

Source: your uploaded “index.ts - DB.ts”

Move the server entrypoint to: server/index.ts

Source: your uploaded “index.tx - SERVER.ts”

Fix the extension from .tx → .ts

Delete/rename any other server boot files so there’s only one entry:

If you have server/app.ts, dist/index.js, dist/server/index.js, or another index.ts at root — pick one entry (server/index.ts) and delete/stop compiling the rest.

tsconfig: make sure compiling emits to a single location that matches your start command (we’ll set that in §6).

2) Secrets: one DB URL, correct role, correct host

Goal: eliminate mismatched DB hosts and old passwords.

Replit → Tools → Secrets:

Keep only these (delete the rest: PG*, DB_URL, POSTGRES_URL, etc.):

DATABASE_URL → copy directly from Neon production branch connection page (don’t hand-edit).

NODE_ENV=production

APP_ENV=production

EXPECTED_DB_HOST=<your Neon production host>
e.g. ep-muddy-moon-aeggx6le-pooler.c-2.us-east-2.aws.neon.tech

SESSION_SECRET=<strong random>

If you ever rotated your Neon user password, regenerate the DATABASE_URL in Neon and paste it again.
The error password authentication failed for user 'neondb_owner' means the secret is stale or wrong.

3) Strict env loader + host guard (prod must hit prod DB)

Create server/config/env.ts:

import { z } from "zod";

const EnvSchema = z.object({
  NODE_ENV: z.enum(["production","development","test"]).default("development"),
  APP_ENV: z.enum(["production","staging","development"]).default("development"),
  DATABASE_URL: z.string().url(),
  EXPECTED_DB_HOST: z.string().optional(),
  SESSION_SECRET: z.string().min(10),
  PORT: z.string().optional(),
});

export const env = EnvSchema.parse(process.env);


Create server/config/guards.ts:

import { env } from "./env";

export function assertProdDB() {
  if (env.APP_ENV !== "production") return;
  const host = new URL(env.DATABASE_URL).host;
  if (env.EXPECTED_DB_HOST && host !== env.EXPECTED_DB_HOST) {
    throw new Error(`[BOOT] Wrong DB host for prod: got ${host}, expected ${env.EXPECTED_DB_HOST}`);
  }
}


Replace all direct process.env.* reads across the app with imports from server/config/env.ts.
Search and fix:

rg -n --no-heading -g '!node_modules' -e 'process\\.env\\.(DATABASE_URL|PG|POSTGRES|NEON_|APP_ENV|NODE_ENV)'

4) DB module (Neon + Drizzle) — stable, single source

Open server/db.ts and replace its content with this shape (adapt to your imports if names differ):

// server/db.ts
import { env } from "./config/env";
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";

let _db: ReturnType<typeof drizzle> | null = null;

export function getDb() {
  if (_db) return _db;
  // The Neon driver automatically uses SSL and serverless pooling
  const sql = neon(env.DATABASE_URL);
  _db = drizzle(sql);
  return _db;
}

// Optional simple health check
export async function ping() {
  const db = getDb();
  // @ts-ignore drizzle neon-http allows raw sql via db.execute
  await db.execute("select 1");
}


Do not create multiple DB clients across files; always import getDb().

5) Migrations must run before routes

Create server/db/migrate.ts:

import { drizzle } from "drizzle-orm/neon-http";
import { migrate } from "drizzle-orm/neon-http/migrator";
import { neon } from "@neondatabase/serverless";
import { env } from "../config/env";

export async function applyMigrations() {
  const sql = neon(env.DATABASE_URL);
  const db = drizzle(sql);
  console.log("[MIGRATIONS] Applying…");
  await migrate(db, { migrationsFolder: "./drizzle" });
  console.log("[MIGRATIONS] Done.");
}


Add idempotent migration scripts under ./drizzle to kill drift and old columns:

Drop retired columns (you removed onboarding; production logs showed it missing):

drizzle/001_drop_retired_columns.sql

ALTER TABLE "users" DROP COLUMN IF EXISTS "onboarding_completed_at";
ALTER TABLE "users" DROP COLUMN IF EXISTS "profile_address_id";


(Optional but recommended) Cart FKs & uniqueness (prevents dupes & missing FK warnings):

drizzle/002_cart_integrity.sql

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'fk_cart_items_product') THEN
    ALTER TABLE "cart_items"
    ADD CONSTRAINT "fk_cart_items_product"
    FOREIGN KEY ("product_id") REFERENCES "products"("id")
    ON DELETE CASCADE NOT VALID;
    ALTER TABLE "cart_items" VALIDATE CONSTRAINT "fk_cart_items_product";
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'fk_cart_items_user') THEN
    ALTER TABLE "cart_items"
    ADD CONSTRAINT "fk_cart_items_user"
    FOREIGN KEY ("user_id") REFERENCES "users"("id")
    ON DELETE SET NULL NOT VALID;
    ALTER TABLE "cart_items" VALIDATE CONSTRAINT "fk_cart_items_user";
  END IF;
END$$;

CREATE UNIQUE INDEX IF NOT EXISTS "uniq_cart_owner_product"
  ON "cart_items"(COALESCE(user_id::text, session_id), product_id, COALESCE(variant_id,''));

6) Server bootstrap (the only entrypoint)

Open server/index.ts and make it the only boot file:

// server/index.ts
import express from "express";
import session from "express-session";
import cookieParser from "cookie-parser";
import cors from "cors";
import { env } from "./config/env";
import { assertProdDB } from "./config/guards";
import { applyMigrations } from "./db/migrate";
import { ping } from "./db";

// 1) Boot logs that must appear once
console.log("[BOOT]", { env: env.APP_ENV, nodeEnv: env.NODE_ENV });

// 2) Prod DB guard + migrations before routes
assertProdDB();

await applyMigrations().catch((e) => {
  console.error("[MIGRATIONS] Failed:", e);
  process.exit(1); // fail fast; no crash loops from half-booted servers
});

// Optional DB reachability check
await ping().catch((e) => {
  console.error("[DB] Ping failed:", e);
  process.exit(1);
});

// 3) Express app
const app = express();
app.set("trust proxy", 1);

app.use(cookieParser());
app.use(cors({
  origin: process.env.CORS_ORIGIN || true,
  credentials: true,
}));

const ONE_MONTH = 30 * 24 * 60 * 60 * 1000;
app.use(session({
  secret: env.SESSION_SECRET,
  resave: false,
  saveUninitialized: true,
  cookie: {
    httpOnly: true,
    sameSite: "lax",
    secure: env.NODE_ENV === "production",
    maxAge: ONE_MONTH,
  },
}));

app.use(express.json());

// === import and register your routes here ===
// e.g. app.use("/api", apiRouter);

// 4) Error handler (last)
app.use((err, _req, res, _next) => {
  console.error("[UNCAUGHT]", err);
  res.status(500).json({ error: "Internal Server Error" });
});

// 5) Start server
const port = Number(env.PORT || 5000);
app.listen(port, () => {
  console.log(`[READY] Listening on :${port}`);
});


Important

Do not have other boot files (no dist/index.js vs dist/server/index.js split). We’re standardizing on server/index.ts → dist/index.js.

Remove duplicate DB logs elsewhere so you don’t see conflicting hosts in logs.

7) Build & start commands (clean builds only)

In package.json:

{
  "scripts": {
    "clean": "rimraf dist .next .turbo build",
    "build": "npm run clean && tsc -b && vite build || tsc -b", 
    "start": "NODE_ENV=production node dist/index.js"
  }
}


If you don’t bundle client on this process, just tsc -b. The point is: clean then compile once.

Add to .gitignore:

dist
.next
build
.turbo


Replit Deploy → Run command:

APP_ENV=production NODE_ENV=production APP_BUILD_ID=$(git rev-parse --short HEAD) npm run build && npm run start

8) Purge legacy env access & duplicate boot paths

Search & fix/remove:

# any old env readers:
rg -n --no-heading -g '!node_modules' -e 'process\\.env\\.(DATABASE_URL|PG|POSTGRES|NEON_|DB_|APP_ENV|NODE_ENV)'

# any other boot logs or app.listen duplicates:
rg -n --no-heading -g '!node_modules' -e '\\[BOOT\\]|app\\.listen|MIGRATIONS\\]|Connecting to host'


Everything should flow through server/index.ts now.

9) Verify locally (inside Replit shell) before turning deploy on
# smoke build
APP_ENV=production NODE_ENV=production APP_BUILD_ID=local npm run build

# run (one instance)
NODE_ENV=production node dist/index.js


Expected logs (and only once):

[BOOT] { env: 'production', nodeEnv: 'production' }
[MIGRATIONS] Applying…
[MIGRATIONS] Done.
[READY] Listening on :5000


No “wrong DB host” error, no “password authentication failed”, no “column does not exist”.

Hit endpoints:

curl -i http://localhost:5000/api/user
curl -i http://localhost:5000/api/products/featured
curl -i http://localhost:5000/api/cart

10) If production DB is still polluted, cut over from good env

If your staging/dev DB is correct:

In Neon, create a new branch from the good env.

Point prod DATABASE_URL to that branch in Replit Secrets.

Redeploy (migrations will run on first boot).

Archive the old prod branch once verified.

This is faster/safer than trying to hand-wipe tables.

Troubleshooting quick hits (based on your logs)

password authentication failed for user 'neondb_owner'
→ DATABASE_URL in Replit is stale or hand-edited. Regenerate in Neon and paste.

[BOOT] { env: 'development', nodeEnv: 'production' }
→ APP_ENV wasn’t set to production in Replit secrets or your env loader defaulted to development. Set APP_ENV=production.

Two different DB hosts in logs
→ You had multiple boot paths reading different envs. After §1–§4, you’ll see exactly one host (EXPECTED_DB_HOST guard will throw if wrong).

column "onboarding_completed_at" does not exist or profile_address_id does not exist
→ Keep the “drop retired columns” migration in the repo so migrations remove these everywhere at boot.

Crash loop
→ Happens when start returns or throws. We now process.exit(1) on migration failure (clear cause), and we only have one app.listen. Clean builds (§7) ensure old dist doesn’t run.

Once the above is applied, turn auto-deploys back on. If you want me to sanity-check your final server/index.ts and server/db.ts snippets, paste them here and I’ll mark any last changes so you’re 100% solid.