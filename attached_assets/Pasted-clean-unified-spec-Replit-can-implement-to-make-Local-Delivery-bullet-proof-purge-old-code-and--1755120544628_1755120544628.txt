clean, unified spec Replit can implement to make “Local Delivery” bullet-proof, purge old code, and wire the UI/logic everywhere. This version removes any “pickup” wording and treats Local = delivery only.

0) Purge legacy + remove onboarding blockers
A. Delete onboarding flow (hard gates → soft, inline prompts)
bash
Copy
Edit
git rm -r src/pages/onboarding
git rm -r src/pages/onboarding/* 2>/dev/null || true
rg -n "onboarding|ProtectedRoute" src | cut -d: -f1 | sort -u | xargs -I{} sed -i '/onboarding/d;/ProtectedRoute/d' {}
Replace with: inline “Add an address” banners wherever needed (cart/checkout/profile) — never block navigation.

B. Kill ALL legacy locality logic
Keep one source of truth (radius from warehouse). Remove or redirect anything else:

bash
Copy
Edit
# legacy zip helpers
git rm client/src/utils/submissionHelpers.ts 2>/dev/null || true

# replace imports if any slipped through
rg -n "isLocalCustomer\(" src server | cut -d: -f1 | sort -u | xargs -I{} sed -i 's/isLocalCustomer(/isLocalMiles(/g' {}

# remove random placeholder logic in checkout or routes
rg -n "Math\.random\(\) > 0\.5" server | cut -d: -f1 | sort -u | xargs -I{} sed -i 's/Math.random() > 0.5/false/g'
C. Purge duplicate/old cart endpoints
We only keep /api/cart/**. Remove or 301 any of these if they exist:

/cart/*

/api/cart/remove/:id (old)

/api/cart/delete/:id (old)

bash
Copy
Edit
rg -n "(/cart/|/api/cart/remove|/api/cart/delete)" server src
# delete or rewrite to /api/cart/items/:id (DELETE)
1) Single source of truth — Local Delivery detection
ENV (optional):

ini
Copy
Edit
WH_LAT=35.5951
WH_LNG=-82.5515
LOCAL_RADIUS_MILES=50
server/config/shipping.ts

ts
Copy
Edit
export function getWarehouseConfig() {
  return {
    lat: Number(process.env.WH_LAT ?? 35.5951),
    lng: Number(process.env.WH_LNG ?? -82.5515),
    radiusMiles: Number(process.env.LOCAL_RADIUS_MILES ?? 50),
  };
}
server/lib/locality.ts

ts
Copy
Edit
import { haversineMiles } from "./distance";
import { getWarehouseConfig } from "../config/shipping";

export type LocalityResult = {
  isLocal: boolean;
  distanceMiles: number | null;
  reason: "RADIUS" | "NO_COORDS";
};

export function isLocalMiles(lat?: number | null, lng?: number | null): LocalityResult {
  const { lat: whLat, lng: whLng, radiusMiles } = getWarehouseConfig();
  if (lat == null || lng == null) return { isLocal: false, distanceMiles: null, reason: "NO_COORDS" };
  const miles = haversineMiles({ lat, lng }, { lat: whLat, lng: whLng });
  return { isLocal: miles <= radiusMiles, distanceMiles: miles, reason: "RADIUS" };
}

export async function computeAddressLocality(addr: { latitude?: number | null; longitude?: number | null; }) {
  return isLocalMiles(addr.latitude ?? null, addr.longitude ?? null);
}
Use this everywhere we determine “local”.

2) Database schema
Addresses
sql
Copy
Edit
ALTER TABLE addresses
  ADD COLUMN IF NOT EXISTS is_local boolean DEFAULT false,
  ADD COLUMN IF NOT EXISTS is_default boolean DEFAULT false;
Boot backfill (idempotent): if a user has no default, mark their oldest address as default.

Recompute is_local on create/update using computeAddressLocality().

Products
sql
Copy
Edit
ALTER TABLE products
  ADD COLUMN IF NOT EXISTS is_local_delivery_available boolean DEFAULT true,
  ADD COLUMN IF NOT EXISTS is_shipping_available boolean DEFAULT true,
  ADD CONSTRAINT chk_availability CHECK (is_local_delivery_available OR is_shipping_available);
Text says “Local Delivery” (never “pickup”).

3) API contracts (clean + consistent)
A. Locality status (based on default address)
GET /api/locality/status →

json
Copy
Edit
{
  "isLocal": true,
  "distanceMiles": 12.4,
  "hasAddress": true,
  "defaultAddressId": "uuid"
}
B. Addresses API
Always return arrays. (Fix “addresses.find is not a function”: the response was not an array.)

Recompute is_local server-side on create/update.

On POST /api/addresses/:id/default: set default, then trigger cart revalidation (below).

C. Products API
Include is_local_delivery_available and is_shipping_available on list/detail.

D. Cart API (single namespace)
GET /api/cart — canonical read

POST /api/cart/items — add { productId, qty }

PATCH /api/cart/items/:id — update qty

DELETE /api/cart/items/:id — remove

POST /api/cart/validate — validate against current locality

Server guard (enforced on add/patch/validate):

ts
Copy
Edit
// server/services/cartGuard.ts
export function guardCartItemAgainstLocality({
  userIsLocal,
  product
}: {
  userIsLocal: boolean;
  product: { is_local_delivery_available: boolean; is_shipping_available: boolean };
}) {
  const localOnly = product.is_local_delivery_available && !product.is_shipping_available;
  if (!userIsLocal && localOnly) {
    const err: any = new Error("Local Delivery only. This item isn't available to ship to your address.");
    err.code = "LOCALITY_RESTRICTED";
    err.http = 409;
    throw err;
  }
}
E. Checkout API
Replace any placeholder local detection with isLocalMiles(...).

Ensure the order summary reads the exact same query key as cart page (see §5C).

4) Admin & editor (set availability per product)
In product create/edit modal:

Two toggles:

Available for Local Delivery (default: on)

Available for Shipping (default: on)

Validation: at least one must be enabled.

Help text: “Local Delivery is available within your service radius.”

5) Frontend UI — everywhere it matters
A. Reusable chips & badges
Locality badge (user status)

tsx
Copy
Edit
// src/components/locality/LocalBadge.tsx
import { Badge } from "@/components/ui/badge";
import { MapPin, Truck } from "lucide-react";

export function LocalBadge({ isLocal }: { isLocal: boolean }) {
  return isLocal ? (
    <Badge className="bg-emerald-600/90 text-white gap-1"><MapPin className="h-3 w-3" /> Local Delivery Area</Badge>
  ) : (
    <Badge variant="secondary" className="gap-1"><Truck className="h-3 w-3" /> Shipping Area</Badge>
  );
}
Product availability chips

tsx
Copy
Edit
// src/components/locality/ProductAvailabilityChips.tsx
import { Badge } from "@/components/ui/badge";

export function ProductAvailabilityChips({ local, ship }: { local: boolean; ship: boolean }) {
  if (local && ship) return <Badge variant="outline">Local Delivery & Shipping</Badge>;
  if (local)       return <Badge className="bg-emerald-600/90 text-white">Local Delivery Only</Badge>;
  return            <Badge>Shipping Only</Badge>;
}
Placement (critical):

Header (beside avatar): <LocalBadge isLocal={data.isLocal} />

Profile → Addresses: show “Local Delivery Eligible” on the Default address.

Product card & detail: <ProductAvailabilityChips local={p.is_local_delivery_available} ship={p.is_shipping_available} />

Cart line items: show chip per item (surface conflicts if user is non-local).

Checkout top: banner “You’re in our Local Delivery area” or “Shipping to your address”.

B. “Benefits of Local Delivery”
Place an info tooltip/modal (Header, Cart, Checkout, Product detail) explaining benefits (you can tune copy later):

Faster delivery windows (same/next day if offered)

Lower fees vs shipping (if true in config)

Exclusive local-only items

C. Cart UX and react-query hygiene
Root cause of “checkout shows empty”: inconsistent query keys/data sources.

Use a single key everywhere: ["cart"].

useCart() hook centralizes CRUD and optimistic updates:

onMutate: update cache immediately → show green “In Cart”

onError: rollback cache, toast error

onSettled: refetch ["cart"]

Ensure checkout reads the same hook and key. Delete any “custom fetch” the checkout was using.

D. Add-to-Cart button rules
If non-local and product is Local Delivery Only: disable button + tooltip

“Local Delivery only. Update your address to one in our Local Delivery area to order.”

States:

Blue Add to Cart

After add: Green In Cart (hover shows red “× Remove” control)

Keep network fast with optimistic updates + a 150–250ms busy spinner (if needed).

E. Address selection UX (checkout/profile)
Default address pre-fills and is read-only.

A “Use another saved address” dropdown (shows is_local badge per option). Switching:

updates default on server (or “use for this order only” toggle — pick one behavior and be consistent)

triggers /api/cart/validate → if conflicts, show a modal:

“Some items can’t be delivered to your address. Remove them or pick a Local Delivery address.”

New address option (only editable form) — once saved, recompute is_local, optionally set as default.

F. Shipping options block
If isLocal: show Local Delivery card (date/time window / fee / promise). Hide pickup.

If not isLocal: show shipping options only.

6) Fix the specific bugs from your logs
“addresses.find is not a function”
Ensure /api/addresses returns an array. In use-addresses.ts:

ts
Copy
Edit
const { data } = useQuery({ queryKey:["addresses"], queryFn: fetchAddresses });
const addresses = Array.isArray(data) ? data : [];
Never destructure from null. In any hook like useDefaultAddress() return { defaultAddress: null } and consumers must null-guard:

tsx
Copy
Edit
const { defaultAddress } = useDefaultAddress();
if (!defaultAddress) return <InlineAddAddressBanner />
Checkout shows no items while cart has items
Both pages must use the same useCart() hook and query key ["cart"]. Delete any custom fetch('/api/cart') code in checkout.

Remove-from-cart not working / blocked
Unify to DELETE /api/cart/items/:id. Remove any /cart/remove/:id or path-rewrites. Client must call the new route only.

Slow add/remove
Use optimistic updates in the hook, and debounce duplicate clicks. Confirm server latency is ~200ms in logs — should feel instant with optimistic cache.

Old files reappearing
Search & delete:

bash
Copy
Edit
rg -n "checkout-new|checkout-simple|legacy|old" src server
git rm <matches you confirm are dead>
Ensure router only points to src/pages/checkout.tsx.

7) Reduce console/log spam (server + client)
Server logger: default to info, gate debug behind NODE_ENV=development && process.env.DEBUG_VERBOSE === '1'.

Stop spamming /api/observability/errors with 400s. Client: batch and throttle error posts; only send when authenticated and sample rate < 5%.

Remove per-request noisy logs (userAgent, ip) unless at debug.

Keep one structured log per request: method, path, status, ms.

8) Test plan (copy/paste checklist)
Migration

Run SQL migrations; restart server.

Verify default address backfill created exactly one default per user.

Locality

Create two addresses: one inside radius, one outside.

Toggle default → /api/locality/status reflects change; cart auto-validates.

Products

Mark Product A: Local Delivery Only; Product B: Shipping Only; Product C: Both.

As Local user: can add A, B, C.

As Non-local: cannot add A (guard 409), can add B, C.

Cart/Checkout parity

Add items → see same items in cart drawer, cart page, checkout.

Remove from any page → updates everywhere (react-query cache).

UI

Badges appear in Header, Product cards/detail, Cart lines, Checkout banner, Profile default address.

Tooltips show benefits of Local Delivery.

Edge cases

No address: show inline banner to add one (do not gate route).

Address without coords: treat as non-local until geocoded; show “We couldn’t confirm Local Delivery for this address” hint.

9) Admin: product editor fields
Add to product modal:

 Available for Local Delivery (toggle)

 Available for Shipping (toggle)

Validation: at least one.

Save to is_local_delivery_available, is_shipping_available.

10) Code fences you can drop in
Cart guard (server add/update)

ts
Copy
Edit
const userIsLocal = (await getLocalityStatus(userId)).isLocal;
const product = await repo.products.getById(productId);
guardCartItemAgainstLocality({ userIsLocal, product });
// proceed to insert/update
Cart validate after default address change

ts
Copy
Edit
// in POST /api/addresses/:id/default
await repo.addresses.setDefault(userId, id);
await cartService.validateAgainstLocality(userId); // removes or flags restricted
return res.json({ ok: true });
Global locality fetch (client)

ts
Copy
Edit
export function useLocality() {
  return useQuery({ queryKey:["locality"], queryFn: () => fetchJSON("/api/locality/status") });
}
AddToCartButton (disable for non-local on local-only)

tsx
Copy
Edit
const { data: locality } = useLocality();
const localOnly = product.is_local_delivery_available && !product.is_shipping_available;
const blocked = !locality?.isLocal && localOnly;

<Button
  disabled={blocked || isMutating}
  title={blocked ? "Local Delivery only. Update your address to order." : undefined}
  onClick={handleAdd}
/>
Copy for Local Delivery benefits (you can refine later)
Local Delivery: We bring it to your door fast within our service radius.

Priority windows: Earliest available delivery slots and faster turn-around.

Exclusive items: Some products are Local Delivery Only due to size or handling.

Final routing sanity list
Keep: /api/locality/status, /api/addresses, /api/cart/**, /api/products/**, /api/shipping/**.

Delete/Redirect: /cart/*, /api/cart/remove/*, legacy checkout pages (checkout-new, checkout-simple), any “onboarding” paths.

If Replit follows this spec exactly, you’ll have:

One clear Local Delivery rule (radius) applied everywhere,

Correct badges and availability chips across the app,

Enforced server-side guards (no wrong items in cart),

Fast, consistent cart behavior in cart and checkout,

No more onboarding blockers or legacy code regressions,

Calmer logs.