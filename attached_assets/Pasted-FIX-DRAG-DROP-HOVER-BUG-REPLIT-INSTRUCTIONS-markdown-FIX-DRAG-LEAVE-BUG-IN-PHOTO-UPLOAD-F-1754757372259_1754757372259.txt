FIX DRAG & DROP HOVER BUG

REPLIT INSTRUCTIONS:
markdown## FIX DRAG LEAVE BUG IN PHOTO UPLOAD

### FILE: `/client/src/pages/SellToUs.tsx`

### ISSUE:
The drag state resets when hovering over child elements (icon, text, button) inside the drop zone.

### SOLUTION:
Use a counter to track drag enter/leave events properly.

### FIXES:

#### 1. ADD DRAG COUNTER
After the existing state declarations, ADD:
```jsx
const [isDragging, setIsDragging] = useState(false);
const dragCounter = useRef(0); // Add this to track drag depth
2. REPLACE DRAG HANDLERS
FIND the existing drag handlers and REPLACE WITH:
jsxconst handleDragEnter = (e: React.DragEvent) => {
  e.preventDefault();
  e.stopPropagation();
  dragCounter.current++;
  if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
    setIsDragging(true);
  }
};

const handleDragLeave = (e: React.DragEvent) => {
  e.preventDefault();
  e.stopPropagation();
  dragCounter.current--;
  if (dragCounter.current === 0) {
    setIsDragging(false);
  }
};

const handleDragOver = (e: React.DragEvent) => {
  e.preventDefault();
  e.stopPropagation();
  if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
    setIsDragging(true); // Keep it active
  }
};

const handleDrop = (e: React.DragEvent) => {
  e.preventDefault();
  e.stopPropagation();
  setIsDragging(false);
  dragCounter.current = 0; // Reset counter
  
  const files = Array.from(e.dataTransfer.files);
  handleFiles(files);
};
3. ALTERNATIVE FIX - POINTER EVENTS
If the above doesn't work, update the drop zone content to ignore pointer events:
jsx<div
  onDragEnter={handleDragEnter}
  onDragLeave={handleDragLeave}
  onDragOver={handleDragOver}
  onDrop={handleDrop}
  onClick={() => fileInputRef.current?.click()}
  className={`
    relative border-2 border-dashed rounded-lg p-8 text-center cursor-pointer
    transition-all duration-200
    ${isDragging 
      ? 'border-blue-500 bg-blue-500/10' 
      : 'border-gray-600 hover:border-gray-500 hover:bg-white/5'
    }
  `}
>
  {/* Add pointer-events-none to all children when dragging */}
  <div className={isDragging ? 'pointer-events-none' : ''}>
    <Upload className="mx-auto mb-4 text-gray-400" size={48} />
    <h4 className="font-semibold mb-2 text-white">
      {isDragging ? 'Drop photos here' : 'Upload Photos'}
    </h4>
    <p className="text-gray-400 mb-4">
      Drag and drop photos here, or click to select
    </p>
    <Button 
      type="button"
      variant="outline" 
      className="border-gray-600 hover:border-gray-500"
      onClick={(e) => {
        e.stopPropagation();
        fileInputRef.current?.click();
      }}
    >
      Choose Files
    </Button>
  </div>
</div>
4. ROBUST SOLUTION - USING A WRAPPER
BEST SOLUTION - Create a wrapper that handles all drag events:
jsx{/* Photo Upload */}
<Card className="p-6">
  <h3 className="font-bebas text-2xl mb-4">PHOTOS</h3>
  <p className="text-text-secondary mb-6">
    Upload clear photos showing the equipment from multiple angles. 
    Include any wear, damage, or unique features.
  </p>
  
  {/* Hidden file input */}
  <input
    ref={fileInputRef}
    type="file"
    multiple
    accept="image/*"
    onChange={handleFileSelect}
    className="hidden"
  />
  
  {/* Drag wrapper - handles all drag events */}
  <div
    className="relative"
    onDragEnter={(e) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragging(true);
    }}
    onDragOver={(e) => {
      e.preventDefault();
      e.stopPropagation();
    }}
    onDrop={(e) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragging(false);
      const files = Array.from(e.dataTransfer.files);
      handleFiles(files);
    }}
  >
    {/* Invisible overlay when dragging */}
    {isDragging && (
      <div 
        className="absolute inset-0 z-10"
        onDragLeave={(e) => {
          e.preventDefault();
          e.stopPropagation();
          setIsDragging(false);
        }}
      />
    )}
    
    {/* Drop zone content */}
    <div
      onClick={() => fileInputRef.current?.click()}
      className={`
        border-2 border-dashed rounded-lg p-8 text-center cursor-pointer
        transition-all duration-200
        ${isDragging 
          ? 'border-blue-500 bg-blue-500/10' 
          : 'border-gray-600 hover:border-gray-500 hover:bg-white/5'
        }
      `}
    >
      <Upload className="mx-auto mb-4 text-gray-400" size={48} />
      <h4 className="font-semibold mb-2 text-white">
        {isDragging ? 'Drop photos here' : 'Upload Photos'}
      </h4>
      <p className="text-gray-400 mb-4">
        Drag and drop photos here, or click to select
      </p>
      <Button 
        type="button"
        variant="outline" 
        className="border-gray-600 hover:border-gray-500"
        onClick={(e) => {
          e.stopPropagation();
          fileInputRef.current?.click();
        }}
      >
        Choose Files
      </Button>
    </div>
  </div>
  
  {/* Rest of the component stays the same */}
</Card>
EXPLANATION:
The bug happens because when you drag over child elements (text, button, icon), the browser fires:

dragLeave on the parent
dragEnter on the child

This makes the isDragging state flicker. The solutions above:

Use a counter to track nested enters/leaves
Use pointer-events-none on children when dragging
Use an overlay to capture all drag events consistently

The third solution (wrapper with overlay) is the most robust.