Here’s a blunt, do-this-now plan for Replit to delete onboarding, fix the addresses/checkout/cart regressions, and lock in a clean flow for email + Google auth. I’m giving you hard delete lists, exact API shapes, UI flow, and the patch for the addresses.find crash.

0) HARD-DELETE ONBOARDING + LEGACY
Remove files & folders (do not keep a single import):

bash
Copy
Edit
src/pages/onboarding/
src/components/onboarding/
src/lib/onboarding-guards.ts
src/middleware/requireCompleteProfile.ts
src/hooks/useOnboarding*.ts
src/components/ui/OnboardingToast*.tsx
src/components/ui/ProfileNag*.tsx
Purge legacy checkout/cart variants (route drift source):

swift
Copy
Edit
src/pages/checkout-old.tsx
src/pages/checkout-new.tsx
src/pages/checkout-simple.tsx
src/pages/checkout.tsx       // remove if not the new index.tsx below
src/components/checkout/**/Deprecated*.tsx
src/components/cart/CartPage*.tsx        // if drawer is the only cart UI
src/lib/legacy/
Keep exactly one checkout page:

bash
Copy
Edit
src/pages/checkout/index.tsx
Update routes (only one checkout route):

ts
Copy
Edit
// src/config/routes.ts
{ path: '/checkout', element: <CheckoutPage /> },
Blow away stale bundles so Vite can’t resurrect old code:

bash
Copy
Edit
rm -rf node_modules/.vite .vite dist
1) NEW AUTH + PROFILE FLOW (NO ONBOARDING)
Principle: Users can browse, add to cart, and check out without being bounced to a “wizard”. We nudge for info in context, never block.

Email users

Registration requires only: email + password.

Name fields optional and editable in Profile.

Google auth users

Pull given_name/family_name + verified email.

Prefill profile silently; no wizard.

Addresses

If user has 0 addresses: show a small inline banner on Profile and Checkout panels only (not global modal).

First address saved automatically becomes default (server-enforced).

Delete any “incomplete profile” middleware. Replace with a light client nudge component that never blocks API calls.

2) ADDRESS SYSTEM — SINGLE SOURCE OF TRUTH
DB constraints (Postgres):

sql
Copy
Edit
CREATE UNIQUE INDEX IF NOT EXISTS addresses_one_default_per_user
ON addresses (user_id) WHERE is_default = true;

ALTER TABLE addresses
  ADD COLUMN IF NOT EXISTS lat double precision,
  ADD COLUMN IF NOT EXISTS lng double precision;
API shapes (consistent everywhere):

http
Copy
Edit
GET    /api/addresses                 -> { ok:true, data: Address[] }
POST   /api/addresses                 -> { ok:true, data: Address }     // create
PATCH  /api/addresses/:id             -> { ok:true, data: Address }     // update
POST   /api/addresses/:id/default     -> { ok:true }                    // set default, clear others
DELETE /api/addresses/:id             -> { ok:true }                    // 409 if default
Server protections:

On first insert for a user, force is_default=true.

Disallow delete of default: return 409 DEFAULT_ADDRESS_CANNOT_BE_DELETED.

3) CHECKOUT PAGE — SIMPLE, ROBUST, NO WIZARD
State machine (no uncontrolled hooks):

csharp
Copy
Edit
addressMode: 'default' | 'saved' | 'new'
selectedAddressId?: string
On mount:

const {data} = await GET /api/addresses

Pick default else first; set addressMode='default'

If none exist, set addressMode='new' and render inline form.

Read-only when using default/saved (editable only in “new address” mode).

Inline “Save this new address to my profile” + “Set as default” when in new mode.

Shipping quotes load after address settles (debounce 300ms).

4) FIX THE CURRENT CRASH
Error:

vbnet
Copy
Edit
TypeError: addresses.find is not a function
Root cause: your hook/component is assuming addresses is an array, but the API returns { ok, data }.

Patch BOTH the hook and the component.

Hook (normalize to array):

ts
Copy
Edit
// src/hooks/use-addresses.ts
export function useAddresses() {
  return useQuery(['addresses'], async () => {
    const res = await api.get('/api/addresses');
    const raw = res.data;
    // Normalize: always return Address[]
    if (Array.isArray(raw)) return raw;
    if (Array.isArray(raw?.data)) return raw.data;
    return []; // never return null/undefined/object
  });
}
Checkout component (defensive):

ts
Copy
Edit
const { data: addressList = [], isLoading } = useAddresses();
const addresses = Array.isArray(addressList) ? addressList : [];

const defaultAddress =
  addresses.find(a => a.is_default) ?? addresses[0] ?? null;

if (isLoading) return <CheckoutSkeleton/>;

if (!defaultAddress && addressMode !== 'new') {
  setAddressMode('new'); // ensure form opens if user has 0 addresses
}
Inputs lock when not in “new” mode:

tsx
Copy
Edit
const readOnly = addressMode !== 'new';
// example input
<input
  value={currentAddress.first_name ?? ''}
  readOnly={readOnly}
  className={readOnly ? 'pointer-events-none opacity-90' : ''}
/>
5) CART: ONE API, OPTIMISTIC UI, GREEN/RED UX
Fix the “CART REQUEST BLOCKED” mismatch by standardizing endpoints:

http
Copy
Edit
GET    /api/cart                 -> { ok:true, data: Cart }
POST   /api/cart                 -> { ok:true, data: Cart }          // { productId, qty }
PATCH  /api/cart/:itemId         -> { ok:true, data: Cart }          // update qty
DELETE /api/cart/:itemId         -> { ok:true, data: Cart }          // remove
Remove any rewrite to /remove/:id and allow SPA DELETE.

AddToCart button behaviour (one component everywhere):

Blue Add to Cart → on success becomes Green “✓ In Cart”.

Hover reveals small red ✕ circle button to remove (optimistic).

Use react-query optimistic update for instant feel.

6) LOCAL vs SHIPPABLE — SHOW IT EVERYWHERE
Server: Add local status to /api/user response.

json
Copy
Edit
{
  "ok": true,
  "data": {
    "user": {...},
    "defaultAddress": { id, city, state, lat, lng },
    "isLocal": true,
    "localRadiusMiles": 50
  }
}
Products have shippable: boolean.
Badges:

Not shippable & not local → “Local Pickup Only (not in your area)” (red)

Not shippable & local → “Local Pickup Eligible” (green)

Shippable → “Ship Eligible” (blue)

Show on product cards, cart lines, checkout summary, and at Profile header (tiny status line).

When default address changes, invalidate ['user'] and recompute isLocal across the app.

7) REMOVE ALL ONBOARDING GUARDS & NAGS
Delete code that blocks routes (/api/orders, etc.).
Replace with a tiny footer banner ONLY on Profile/Checkout when addresses.length === 0. No modals, no redirects.

8) CLEAN LOG NOISE & PERF
In dev, don’t call /api/observability/errors without {message, stack}; otherwise skip.

Consider disabling track-activity in dev:

ts
Copy
Edit
if (import.meta.env.DEV) return; // client: do not POST activity in dev
9) BUILD CHECKLIST
Remove all onboarding & legacy files (section 0).

Ensure only /checkout/index.tsx is routed.

Implement address API shapes (section 2) and protect default deletes.

Replace cart endpoints with the unified shape; remove /remove/:id path.

Implement optimistic cart UI w/ green “In Cart” + red ✕ hover.

Add local status in /api/user; display badges everywhere.

Patch use-addresses + checkout to always treat addresses as an array (section 4).

Clear Vite caches and rebuild.

Code bits you can paste right now
Normalize addresses in the hook (prevents .find crash):

ts
Copy
Edit
// src/hooks/use-addresses.ts
import { useQuery } from '@tanstack/react-query';
import { api } from '@/lib/api';

export function useAddresses() {
  return useQuery(['addresses'], async () => {
    const r = await api.get('/api/addresses');
    const d = r.data;
    if (Array.isArray(d)) return d;
    if (Array.isArray(d?.data)) return d.data;
    return [];
  });
}
Safe default selection in checkout:

ts
Copy
Edit
// src/pages/checkout/index.tsx (inside component)
const { data: addressesRaw = [], isLoading } = useAddresses();
const addresses = Array.isArray(addressesRaw) ? addressesRaw : [];

const [addressMode, setAddressMode] = useState<'default'|'saved'|'new'>('default');
const [selectedId, setSelectedId] = useState<string | null>(null);

const defaultAddress = useMemo(
  () => addresses.find(a => a.is_default) ?? addresses[0] ?? null,
  [addresses]
);

useEffect(() => {
  if (!addresses.length) setAddressMode('new');
}, [addresses.length]);

if (isLoading) return <CheckoutSkeleton/>;
Protect default delete (server):

ts
Copy
Edit
// server/controllers/addresses.ts
export const remove = async (req, res) => {
  const addr = await Address.findByPk(req.params.id);
  if (!addr || addr.user_id !== req.user.id) return res.sendStatus(404);
  if (addr.is_default) return res.status(409).json({ ok:false, error:'DEFAULT_ADDRESS_CANNOT_BE_DELETED' });
  await addr.destroy();
  res.json({ ok:true });
};
Set default (server):

ts
Copy
Edit
export const setDefault = async (req, res) => {
  await Address.update({ is_default:false }, { where:{ user_id:req.user.id }});
  await Address.update({ is_default:true }, { where:{ id:req.params.id, user_id:req.user.id }});
  res.json({ ok:true });
};
Cart endpoints (server router):

ts
Copy
Edit
router.get('/', getCart);
router.post('/', addToCart);
router.patch('/:itemId', updateItem);
router.delete('/:itemId', removeItem);
Final notes for Replit
Do not reintroduce “onboarding”. The UI must never block core flows; it should only nudge in context.

Make the API return types boring and consistent. All list endpoints return { ok, data: [] }. Hooks normalize to arrays and never surface null.

One checkout page, one cart API. Regressions came from duplicate routes/components and mixed response shapes. That’s fixed by deleting old code and normalizing the few critical endpoints above.

If anything still throws after these changes, it’ll be obvious in logs (and not drowned out by the observability spam we just removed).









Ask ChatGPT
