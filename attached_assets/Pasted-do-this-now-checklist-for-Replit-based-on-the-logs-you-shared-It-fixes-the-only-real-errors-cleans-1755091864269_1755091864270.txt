do-this-now checklist for Replit based on the logs you shared. It fixes the only real errors, cleans up noisy warnings, and hardens performance while keeping our SSOT address/onboarding work intact.

1) Fix the only hard error showing up in prior runs (double-check)
(You previously hit column "street" does not exist during login.)
Confirm that server/storage.ts#getUserByEmail no longer selects legacy columns (street, city, state, zip_code, latitude, longitude). If it still does anywhere, replace the query with a minimal user-only selection (no legacy fields) and join address only in /api/user. This prevents that 42703 from ever returning.

2) Stop the 400s spam on /api/observability/errors
You have dozens of POST /api/observability/errors 400. That’s a bad payload/schema mismatch between the client error reporter and the server route.

2.1 Server: accept a tolerant, validated payload (Zod)
Create/replace server/routes/observability.ts:

ts
Copy
Edit
import { Router } from "express";
import { z } from "zod";

const router = Router();

const ErrorEvent = z.object({
  name: z.string().optional().default("Error"),
  message: z.string().min(1),
  stack: z.string().optional(),
  url: z.string().url().optional(),
  userId: z.string().uuid().optional(),
  meta: z.record(z.any()).optional(),
});

router.post("/api/observability/errors", async (req, res) => {
  const parse = ErrorEvent.safeParse(req.body);
  if (!parse.success) {
    // Don’t 400 spam the logs; accept and downgrade
    return res.status(202).json({ accepted: false, reason: "invalid-payload", issues: parse.error.issues });
  }

  const ev = parse.data;
  // TODO: persist to DB or console.log in dev
  if (process.env.NODE_ENV !== "production") {
    console.warn("[client-error]", ev.name, ev.message, { url: ev.url });
  }
  return res.status(202).json({ accepted: true });
});

export default router;
Mount it in server/routes.ts (or server/index.ts):

ts
Copy
Edit
import observability from "./routes/observability";
app.use(express.json({ limit: "200kb" }));
app.use(observability);
2.2 Client: send the shape the server expects
Harden client/src/lib/errorTracking.ts:

ts
Copy
Edit
export function reportClientError(err: unknown) {
  const message = err instanceof Error ? err.message : String(err);
  const stack = err instanceof Error ? err.stack : undefined;

  fetch("/api/observability/errors", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    keepalive: true,
    body: JSON.stringify({
      name: err instanceof Error ? err.name : "Error",
      message,
      stack,
      url: window.location.href,
      meta: { ua: navigator.userAgent },
    }),
  }).catch(() => {});
}
Result: no more 400s and no log spam.

3) Remove noisy 401 hits to /api/user when logged out
You’re calling /api/user before auth is established.

Client fix (React Query/SWR): only call once we know we’re authenticated.

ts
Copy
Edit
const { status } = useAuth(); // 'loading' | 'authenticated' | 'unauthenticated'

const userQuery = useQuery({
  queryKey: ["user"],
  queryFn: () => fetchJSON("/api/user"),
  enabled: status === "authenticated", // <- prevents 401 spam
  staleTime: 5 * 60 * 1000,
});
Also add a global fetchJSON interceptor that, on 401, stops retrying this query rather than hammering the endpoint.

4) Performance: fix dev slow loads & prod caching
The slow logs are dev-mode (Vite/HMR) and long CSS compile:

Dev: Set Tailwind JIT and watch efficiently

Ensure TAILWIND_MODE=watch

In tailwind.config.js, limit content globs to your actual source paths. Over-broad globs make CSS rebuilds slow.

Prod: Serve built assets with caching & compression

Add to Express (prod only):

ts
Copy
Edit
import compression from "compression";
import path from "path";
import express from "express";

if (process.env.NODE_ENV === "production") {
  app.use(compression());
  app.use(
    express.static(path.join(__dirname, "../client-dist"), {
      etag: true,
      lastModified: true,
      maxAge: "365d",
      setHeaders(res, p) {
        if (p.endsWith(".html")) res.setHeader("Cache-Control", "no-cache");
      },
    })
  );
}
And make sure CI builds the client (vite build) into client-dist/.

5) Cart & categories polling noise
You’re fetching /api/cart and /api/products/featured frequently. That’s fine, but let’s cut extra network:

ts
Copy
Edit
useQuery({
  queryKey: ["cart", userId ?? "guest"],
  queryFn: () => fetchJSON("/api/cart"),
  staleTime: 60 * 1000,
  refetchOnWindowFocus: false,
  refetchOnReconnect: false,
});
Do the same for featured/categories; they hardly change → staleTime: 5 * 60 * 1000.

6) Keep SSOT guardrails on (no legacy regressions)
Run the “banned terms” gate every start/build (prebuild/prestart). If you haven’t added it yet, add scripts/check-legacy.sh (from my previous message) and wire it in package.json. This is how we prove the old address/onboarding code stays gone.

7) Sanity checks to run now
Server boots clean (it already does) — confirm no 42703/column errors.

Open the app logged out → ensure there are no /api/user 401 repeats (Section 3).

Trigger a client error (e.g., throw in a button click) → server should log [client-error] … and return 202, not 400 (Section 2).

Navigate home/products/cart → verify fewer network calls and no slow dev warnings beyond first cold load.

Log in → confirm /api/user resolves once, cart loads once, no 4xx/5xx.

Run npm run prebuild → should print 🟢 No legacy references detected.

8) Optional quality polish
Add Helmet and CORS hardening if not already: helmet() and tight CORS in dev/prod.

Enable ETag (Express static already does) and keep compression() for Brotli/Gzip in prod.

Add LRU cache around /api/categories & /api/products/featured for unauthenticated users (1–5 min TTL) to reduce DB hits.

TL;DR (what to change right now)
Implement tolerant /api/observability/errors handler + align client payload (stops all 400 spam).

Don’t call /api/user until status==="authenticated" (removes 401 noise).

Add reasonable staleTime/no focus refetch on cart/featured (less network noise).

Keep the legacy ban script in prebuild/prestart so the purge stays real.

In prod, serve built assets with compression + long cache headers; in dev, narrow Tailwind globs.

Ship those and the logs you pasted will go from “busy but OK” → “quiet and clean,” while staying aligned with the rebuilt SSOT onboarding/address system.